<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浏览器的渲染过程</title>
    <link href="/blog/2025/08/21/browser-render/"/>
    <url>/blog/2025/08/21/browser-render/</url>
    
    <content type="html"><![CDATA[<h1 id="输入-URL-后到页面渲染的过程"><a href="#输入-URL-后到页面渲染的过程" class="headerlink" title="输入 URL 后到页面渲染的过程"></a>输入 URL 后到页面渲染的过程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>当我们在浏览器中输入一串 URL 后，比如 [百度一下，你就知道 (baidu.com)，很快百度的页面就能加载出来。那在这个过程中，<strong>浏览器都进行了哪些操作呢？</strong> 面试官经常会问到这个过程，今天我们就来把这个完整的过程给它探究明白。</p></blockquote><h2 id="输入-URL-后到页面渲染"><a href="#输入-URL-后到页面渲染" class="headerlink" title="输入 URL 后到页面渲染"></a>输入 URL 后到页面渲染</h2><p><strong>在浏览器中输入 URL 到页面渲染的整个过程可以分为多个步骤</strong>。这个过程涉及浏览器、操作系统、网络以及服务器的协作。我们可以把这个过程概括为以下几个主要阶段：</p><h3 id="1-DNS-解析"><a href="#1-DNS-解析" class="headerlink" title="1. DNS 解析"></a>1. DNS 解析</h3><p>当你在浏览器中输入一个 URL 并按下回车时，浏览器首先会解析这个 URL。<strong>URL 通常包括协议（如 <code>http</code> 或 <code>https</code>）、域名（如 <code>example.com</code>）或 IP 地址、端口和路径</strong>。</p><p>如果 URL 包含的是域名而不是IP地址，浏览器需要<strong>通过DNS（域名系统）解析来获取该域名对应的服务器IP地址</strong>。</p><ul><li><strong>本地域名服务器查询</strong>：浏览器首先会<strong>查找本地缓存中是否有该域名对应的 IP 地址</strong>。如果缓存中找不到，它会向本地域名服务器发起请求。</li><li><strong>根域名服务器查询</strong>：如果本地域名服务器没有找到结果，它会请求<strong>根域名服务器</strong>。<strong>根域名服务器会返回与该域名相关的顶级域名服务器（如 <code>.com</code>、<code>.net</code> 等）的地址</strong>。</li><li><strong>顶级域名服务器查询</strong>：接下来，<strong>本地域名服务器向返回的顶级域名服务器发起查询</strong>，顶级域名服务器会返回具体管理该域名的服务器地址。</li><li><strong>目标域名服务器查询</strong>：本地域名服务器向<strong>目标域名服务器</strong>发起查询，<strong>目标服务器返回具体的 IP 地址</strong>。</li><li><strong>DNS 缓存</strong>：本地服务器将查询到的 IP 地址返回给用户，并且会<strong>将该 IP 地址缓存起来</strong>，供未来快速访问。</li></ul><h3 id="2-TCP-协议-——-三次握手（建立连接）"><a href="#2-TCP-协议-——-三次握手（建立连接）" class="headerlink" title="2. TCP 协议 —— 三次握手（建立连接）"></a>2. <strong>TCP 协议 —— 三次握手（建立连接）</strong></h3><p>获取了服务器的 IP 地址后，<strong>浏览器会与服务器建立 TCP 连接</strong>。这时会涉及<strong>三次握手</strong>的过程：</p><h4 id="三次握手步骤："><a href="#三次握手步骤：" class="headerlink" title="三次握手步骤："></a>三次握手步骤：</h4><ol><li><strong>客户端发送连接请求（SYN）</strong> ：客户端向服务器发送一个带有 <strong>SYN</strong> 标志位的请求，表示希望建立连接。此时客户端处于 <strong>SYN-SENT</strong> 状态。</li><li><strong>服务器确认请求并回复（SYN + ACK）</strong> ：服务器收到连接请求后，会回复一个带有 <strong>SYN</strong> 和 <strong>ACK</strong> 标志的报文，表示接受连接请求并确认。此时服务器进入 <strong>SYN-RECEIVED</strong> 状态。</li><li><strong>客户端确认收到回复（ACK）</strong> ：客户端接收到服务器的确认后，再次发送一个带有 <strong>ACK</strong> 标志的确认信息，表明连接建立完成。此时双方都进入 <strong>ESTABLISHED</strong> 状态，连接成功建立。</li></ol><h4 id="为什么一定要三次握手，两次行不行？"><a href="#为什么一定要三次握手，两次行不行？" class="headerlink" title="为什么一定要三次握手，两次行不行？"></a>为什么一定要三次握手，两次行不行？</h4><p>这时，面试官就会问，一定要三次握手吗？两次握手不行吗？答案当然是不行；</p><p>如果只使用两次握手，有可能会出现以下情况：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">代码解读<br>复制代码客户端发送了一个连接请求SYN报文后，由于网络拥塞等原因，这个报文丢失了，客户端超时后重新发送了一个新的SYN报文，建立了连接并进行了数据传输。但是在连接关闭之后，第一次发送的那个SYN报文突然又到达了服务端，按照两次握手的方式，服务端会误以为这是一个新的连接请求，并发送SYN+ACK进行确认，进而建立一个无效的连接，浪费性能。而三次握手就能避免这种情况，因为服务端在收到第一个SYN报文时会回复SYN+ACK，但如果没有收到客户端的确认ACK，就不会建立连接。<br></code></pre></td></tr></table></figure><h3 id="3-HTTP-数据传输"><a href="#3-HTTP-数据传输" class="headerlink" title="3. HTTP 数据传输"></a>3. <strong>HTTP 数据传输</strong></h3><p>TCP 连接建立之后，<strong>浏览器会向服务器发送 HTTP 请求进行数据传输</strong>。关于 HTTP 协议有以下几个版本：</p><h4 id="HTTP-0-9-——-超文本传输协议的起源"><a href="#HTTP-0-9-——-超文本传输协议的起源" class="headerlink" title="HTTP 0.9 —— 超文本传输协议的起源"></a><strong>HTTP 0.9 —— 超文本传输协议的起源</strong></h4><p><strong>HTTP 0.9 是最初版本的 HTTP 协议，专为实验室设计，用于传输简单的 HTML 文本</strong>。这个版本极为简化，只有请求行，格式为 <code>GET /index.html</code>。服务器接收请求后，只返回 HTML 文本内容，且使用 <strong>ASCII 编码</strong>。虽然 HTTP 0.9 能够基本传输超文本文件，但它无法传输其他类型的资源文件，且没有请求头或响应头，导致服务器与客户端之间的通信能力非常有限。</p><h4 id="HTTP-1-0-——-支持更多资源的传输"><a href="#HTTP-1-0-——-支持更多资源的传输" class="headerlink" title="HTTP 1.0 —— 支持更多资源的传输"></a><strong>HTTP 1.0 —— 支持更多资源的传输</strong></h4><p>随着互联网的发展，不仅仅是 HTML 文件，还有<strong>图片、音频、视频等多种类型的资源需要传输</strong>，HTTP 0.9 已无法满足需求。因此，<strong>HTTP 1.0</strong> <strong>增加了请求头和响应头</strong>，允许客户端和服务器之间的更多交流，传输不同类型的资源。</p><ul><li><strong>请求头</strong>：客户端可以通过请求头来告知服务器所期望的数据类型和格式，如：<ul><li><code>accept：text/html</code> —— 表示期望返回 HTML 文件。</li><li><code>accept-encoding: gzip, deflate, br</code> —— 指定支持的压缩格式。</li><li><code>accept-language: zh-CN,zh;q=0.9,en;q=0.8</code> —— 指定优先的语言。</li><li><code>accept-charset: utf-8</code> —— 指定使用的字符编码。</li></ul></li><li><strong>响应头</strong>：服务器通过响应头告知客户端返回的数据类型、编码方式等，如：<ul><li><code>content-type: text/html</code> —— 返回 HTML 文件。</li><li><code>content-encoding: gzip</code> —— 指定内容已使用 gzip 压缩。</li></ul></li></ul><p>此外，HTTP 1.0 还引入了 <strong>HTTP 状态码</strong>，如 200（成功）、404（未找到）、500（服务器错误），用于指示请求的处理结果。</p><h4 id="HTTP-1-1-——-持久连接与虚拟主机支持"><a href="#HTTP-1-1-——-持久连接与虚拟主机支持" class="headerlink" title="HTTP 1.1 —— 持久连接与虚拟主机支持"></a><strong>HTTP 1.1 —— 持久连接与虚拟主机支持</strong></h4><p>HTTP 1.0 的一个主要问题是<strong>短连接</strong>。<strong>每次请求都会建立一次 TCP 连接，响应结束后就关闭连接，这样对服务器资源消耗较大</strong>。为了解决这个问题，<strong>HTTP 1.1</strong> 引入了<strong>长连接</strong>，即 TCP 连接在一次请求结束后不会立即关闭，多个请求可以复用同一个连接。这提高了性能，<strong>减少了连接建立和断开的开销</strong>。</p><p><strong>HTTP 1.1</strong> 版本有以下一些特性：</p><ul><li><strong>HTTP 队头阻塞</strong>：HTTP 1.1 虽然支持长连接，但多个请求在同一条 TCP 连接中发送时，如果前一个请求未完成，后面的请求会被阻塞，导致效率降低。</li><li><strong>虚拟主机支持</strong>：HTTP 1.1 增加了 <code>HOST</code> 头字段，<strong>允许一台服务器通过一个 IP 地址托管多个域名</strong>。</li><li><strong>Cookie 支持</strong>：HTTP 1.1 通过 Cookie 实现了用户状态管理，使得网站可以记住用户的登录状态等信息。</li></ul><h4 id="HTTP-2-0-——-多路复用与头部压缩"><a href="#HTTP-2-0-——-多路复用与头部压缩" class="headerlink" title="HTTP 2.0 —— 多路复用与头部压缩"></a><strong>HTTP 2.0 —— 多路复用与头部压缩</strong></h4><p><strong>虽然 HTTP 1.1 的长连接改善了性能，但仍存在带宽利用率低的等问题</strong>。主要体现在以下方面：</p><ul><li>TCP的慢启动：TCP的慢启动算法是用来控制新建立的连接初期的流量，避免突然大量的数据涌入网络造成拥塞。在慢启动阶段，发送方最初只会发送少量的数据段（通常是一个MSS，最大报文段长度），然后根据收到的确认逐步增加发送速率。</li><li>同时开启的多条TCP连接相互竞争带宽：当一个客户端同时与服务器建立了多个TCP连接时，这些连接可能会相互竞争有限的带宽资源。</li><li>http队头阻塞：HTTP&#x2F;1.1中的队头阻塞是指在一个TCP连接中，后续请求的处理必须等待前面请求的响应才能开始的问题。即使服务器已经准备好发送多个响应，但如果前面的响应没有完全发送完毕，后面的响应也无法开始传输。</li></ul><p>对此 <strong>HTTP 2.0</strong> 引入了多项优化措施，提升了协议效率：</p><ul><li><strong>多路复用</strong>：HTTP 2.0 在单一 TCP 连接上支持同时发送多个请求和响应，避免了 HTTP 1.1 中的队头阻塞。它通过一个<strong>二进制分帧层</strong>将请求和响应分解为多个帧，每个帧带有唯一的 ID，<strong>浏览器和服务器通过 ID 来区分和组合数据</strong>。这大大提高了传输效率，且<strong>避免了多个 TCP 连接之间的带宽竞争</strong>。</li><li><strong>优先级控制</strong>：<strong>在多路复用中，重要的资源可以被打上高优先级标记，服务器会优先传输这些资源</strong>（例如页面的 CSS 和 JavaScript 文件）。</li><li><strong>头部压缩</strong>：HTTP 2.0 引入了头部压缩，减少了请求和响应中头部字段的冗余数据，提升了带宽利用率。</li></ul><h4 id="HTTPS-VS-HTTP"><a href="#HTTPS-VS-HTTP" class="headerlink" title="HTTPS VS HTTP"></a><strong>HTTPS VS HTTP</strong></h4><p><strong>HTTPS</strong> 是在 HTTP 基础上增加了 <strong>TLS（Transport Layer Security）协议</strong> 的加密层，用来确保数据传输的安全性。它的主要工作机制包括：</p><ol><li><strong>对称加密</strong>：传输的数据会<strong>使用双方共享的密钥进行加密和解密</strong>，保证数据传输的机密性。</li><li><strong>非对称加密</strong>：在通信开始时，客户端生成密钥，服务器生成公钥和私钥。<strong>客户端使用服务器的公钥加密其生成的密钥，并发送给服务器，服务器用私钥解密，确保双方可以安全地共享一个密钥用于后续的对称加密</strong>。</li></ol><p>通过 HTTPS，传输的数据在网络中是加密的，避免了敏感信息被窃取或篡改。</p><h4 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h4><h5 id="TCP（Transmission-Control-Protocol）——-可靠的传输协议"><a href="#TCP（Transmission-Control-Protocol）——-可靠的传输协议" class="headerlink" title="TCP（Transmission Control Protocol）—— 可靠的传输协议"></a><strong>TCP（Transmission Control Protocol）—— 可靠的传输协议</strong></h5><p><strong>TCP</strong> 是一种面向连接的传输层协议，它提供<strong>可靠、顺序</strong>的数据传输，广泛应用于对数据传输质量要求较高的场景。</p><p><strong>特点</strong>：</p><ol><li><strong>可靠性</strong>：<ul><li><strong>建立连接</strong>：TCP 通过三次握手机制确保客户端和服务器成功建立连接后，才开始传输数据。通过四次挥手来安全断开连接，保证传输完整性。</li><li><strong>流量拥塞控制</strong>：TCP 内置了流量控制和拥塞控制机制，通过检测网络的负载情况，自动调节数据传输速度，避免网络过载。</li><li><strong>超时重传机制</strong>：如果数据包在传输中丢失或没有被及时确认，TCP 会自动触发重传，确保所有数据都能准确无误地到达目的地。</li></ul></li><li><strong>有序性</strong>：<ul><li>TCP 将传输的数据分成多个包，使用序列号来确保数据包的顺序传递。如果数据包到达顺序有误，TCP 会根据序列号进行重新排序，确保数据按照正确顺序到达接收方。</li></ul></li><li><strong>应用场景</strong>：<ul><li>TCP 适用于需要高可靠性传输的场景，如：<ul><li><strong>网页浏览</strong>：保证网页内容的完整性。</li><li><strong>文件传输</strong>：如 FTP 协议，确保文件不丢失、不损坏。</li><li><strong>电子邮件</strong>：确保邮件内容的准确性。</li></ul></li></ul></li></ol><h5 id="UDP（User-Datagram-Protocol）——-高效的传输协议"><a href="#UDP（User-Datagram-Protocol）——-高效的传输协议" class="headerlink" title="UDP（User Datagram Protocol）—— 高效的传输协议"></a><strong>UDP（User Datagram Protocol）—— 高效的传输协议</strong></h5><p><strong>UDP</strong> 是一种面向无连接的传输层协议，<strong>强调传输速度和效率</strong>，而不保证数据的可靠传输和顺序。UDP 常用于<strong>对实时性要求较高</strong>的应用场景。</p><p><strong>特点</strong>：</p><ol><li><strong>不可靠性</strong>：<ul><li><strong>无连接</strong>：UDP 在发送数据前不需要建立连接，直接将数据包发送给目标地址，不会等待确认。这样虽然减少了延时，但也带来了不可靠性。</li><li><strong>无流量控制和拥塞控制</strong>：UDP 不具备 TCP 的流量控制和拥塞控制功能，数据包的发送不会受到网络状况的调节，因此有可能导致数据丢失或过载。</li><li><strong>不管丢包</strong>：UDP 不会检测数据包是否丢失，也不会进行重传。这使得它在传输过程中，可能有数据丢失，但这也带来了高效性。</li></ul></li><li><strong>高效</strong>：<ul><li>由于没有建立连接的过程，也没有流量控制和丢包重传机制，UDP 的传输速度快，延迟低，特别适合需要快速传输数据的场景。</li></ul></li><li><strong>应用场景</strong>：<ul><li>UDP 适用于对传输可靠性要求不高，但对实时性要求较高的应用场景，如：<ul><li><strong>直播</strong>：如视频或音频直播，允许偶尔的数据丢失而不影响整体体验。</li><li><strong>在线游戏</strong>：游戏中的实时性要求高，UDP 的低延迟可以提供更流畅的游戏体验。</li><li><strong>视频通话</strong>：实时视频和音频需要低延迟传输，丢失少量数据不会影响通话质量。</li></ul></li></ul></li></ol><h4 id="HTTP-3-0-——-解决队头阻塞与连接延迟"><a href="#HTTP-3-0-——-解决队头阻塞与连接延迟" class="headerlink" title="HTTP 3.0 —— 解决队头阻塞与连接延迟"></a><strong>HTTP 3.0 —— 解决队头阻塞与连接延迟</strong></h4><p>虽然 HTTP 2.0 引入了多路复用，但它仍然依赖于 TCP 协议，存在<strong>TCP 队头阻塞</strong>的问题。HTTP 3.0 基于 <strong>QUIC（Quick UDP Internet Connections）协议</strong>，这是一个集成了 TCP 优势并基于 UDP 的全新协议，解决了 TCP 的一些固有问题。</p><ul><li><strong>队头阻塞的解决</strong>：<strong>在 TCP 中，超时重传机制导致队头阻塞</strong>，即<strong>一个数据包丢失后，后续所有数据包都必须等待重传的完成</strong>。QUIC 通过多条独立的数据流，丢失的包不会影响其他包的传输。</li><li><strong>快速握手</strong>：TCP 在建立连接时需要三次握手，而 QUIC 的连接建立速度更快，减少了握手延迟，提升了页面加载速度。</li><li><strong>集成 TLS 加密</strong>：QUIC 集成了 TLS 加密层，进一步增强了数据传输的安全性。</li></ul><h3 id="4-TCP-协议-——-四次挥手（断开连接）"><a href="#4-TCP-协议-——-四次挥手（断开连接）" class="headerlink" title="4. TCP 协议 —— 四次挥手（断开连接）"></a>4. <strong>TCP 协议 —— 四次挥手（断开连接）</strong></h3><p>在通信完成后，浏览器和服务器通过<strong>四次挥手</strong>来断开 TCP 连接。<strong>四次挥手确保双方都能安全地结束数据传输，不会丢失任何未发送的内容</strong>。</p><h4 id="四次挥手步骤："><a href="#四次挥手步骤：" class="headerlink" title="四次挥手步骤："></a>四次挥手步骤：</h4><ol><li><strong>客户端发送断开请求（FIN）</strong> ：客户端发出一个带有 <strong>FIN</strong> 标志位的报文，表示希望断开连接，进入 <strong>FIN-WAIT-1</strong> 状态。</li><li><strong>服务器回复确认（ACK）</strong> ：服务器接收到断开请求后，返回一个 <strong>ACK</strong> 报文，表示确认接收到断开请求，但它可能还有数据要发送，进入 <strong>CLOSE-WAIT</strong> 状态。</li><li><strong>服务器完成数据传输后发送断开请求（FIN）</strong> ：服务器发送完剩余数据后，向客户端发出 <strong>FIN</strong> 请求，表示它准备好断开连接，进入 <strong>LAST-ACK</strong> 状态。</li><li><strong>客户端确认断开（ACK）</strong> ：客户端接收到服务器的 FIN 报文后，返回一个 <strong>ACK</strong> 报文，进入 <strong>TIME-WAIT</strong> 状态，并等待 <strong>2MSL（最大段生命周期）时间</strong>，确保服务器接收到确认消息。随后，客户端和服务器都进入 <strong>CLOSED</strong> 状态，连接正式断开。</li></ol><h3 id="5-浏览器开始渲染页面"><a href="#5-浏览器开始渲染页面" class="headerlink" title="5. 浏览器开始渲染页面"></a>5. <strong>浏览器开始渲染页面</strong></h3><p>浏览器接收到服务器的响应后，开始处理响应内容。这个过程包含多个步骤，尤其是在渲染 HTML 页面时非常复杂：</p><h4 id="HTML-解析与-DOM-树的构建"><a href="#HTML-解析与-DOM-树的构建" class="headerlink" title="HTML 解析与 DOM 树的构建"></a><strong>HTML 解析与 DOM 树的构建</strong></h4><p>当浏览器开始加载页面时，首先会解析 HTML 文件，并将 HTML 转换为 DOM 树（Document Object Model）。DOM 树中的每个节点代表一个 HTML 标签，它们以树状结构表示页面的层次关系。</p><h4 id="CSS-解析与-CSSOM-树的构建"><a href="#CSS-解析与-CSSOM-树的构建" class="headerlink" title="CSS 解析与 CSSOM 树的构建"></a><strong>CSS 解析与 CSSOM 树的构建</strong></h4><p>与此同时，浏览器会解析 CSS 文件或嵌入式样式，构建 CSSOM（CSS Object Model）树。CSSOM 树存储了每个 DOM 节点的样式信息。</p><h4 id="合成构建-Render-Tree"><a href="#合成构建-Render-Tree" class="headerlink" title="合成构建 Render Tree"></a><strong>合成构建 Render Tree</strong></h4><p>浏览器将 DOM 树和 CSSOM 树结合起来，生成一棵新的<strong>渲染树（Render Tree）</strong> 。渲染树的每个节点对应一个可见的元素，它包含了 DOM 元素的视觉信息（例如尺寸、位置、颜色等）。在这个过程中，某些不参与渲染的元素（如 <code>display: none</code> 的元素）不会被添加到渲染树中。</p><h4 id="回流（Reflow）"><a href="#回流（Reflow）" class="headerlink" title="回流（Reflow）"></a><strong>回流（Reflow）</strong></h4><p>一旦渲染树创建完毕，浏览器开始计算每个元素在页面中的具体位置和大小，这个过程称为<strong>布局（Layout）</strong> ，也称为<strong>回流（Reflow）</strong> 。它决定了页面的几何属性，包括每个元素的尺寸、位置、边距等。</p><ul><li><strong>首次布局</strong>：在页面初次渲染时，浏览器会遍历渲染树，为每个可见元素计算它们在页面中的确切位置和尺寸。这个过程称为<strong>初次回流</strong>，因为页面的每个部分都要计算和排列。</li><li><strong>后续回流</strong>：当页面的元素结构或布局属性（如 <code>width</code>、<code>height</code>、<code>margin</code> 等）发生变化时，浏览器需要重新计算这些元素及其相关元素的布局，这个过程也被称为回流。</li></ul><p><strong>回流的触发原因</strong>：</p><ul><li>DOM 结构的变化（增加或删除元素）。</li><li>元素的几何属性（如宽度、高度、边距）发生变化。</li><li>浏览器窗口大小的变化。</li><li>读取某些会导致重新计算布局的属性（如 <code>offsetHeight</code>、<code>clientWidth</code> 等）。</li></ul><h4 id="重绘（Repaint）"><a href="#重绘（Repaint）" class="headerlink" title="重绘（Repaint）"></a><strong>重绘（Repaint）</strong></h4><p>布局完成后，浏览器开始为每个元素填充颜色、绘制边框、应用阴影和文字等，这个过程称为<strong>绘制（Paint）</strong> ，如果布局没有发生变化但样式发生了变化（例如颜色、背景、字体等），则会触发<strong>重绘（Repaint）</strong> 。</p><p><strong>重绘的触发原因</strong>：</p><ul><li>元素的视觉属性（如 <code>color</code>、<code>background-color</code>、<code>border-color</code> 等）发生变化。</li><li>虽然元素的几何属性没有变化，但它的外观发生了变化，浏览器需要将它重新绘制出来。</li></ul><p><strong>重绘的代价较回流小，因为它不涉及重新计算布局，只需要重新绘制改变了样式的部分</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从输入 URL 到页面的渲染是一个复杂的过程，在数据传输时，首先需要进行TCP建立连接，再通过HTTP进行数据得传输；然后再到页面的渲染，<strong>重绘不一定会触发回流，而回流是一定会导致重绘的，因为回流之后，需要重新去绘制页面</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>browser</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渲染过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>forEach 为什么不能被中断</title>
    <link href="/blog/2025/08/21/js-foreachNotStopReason/"/>
    <url>/blog/2025/08/21/js-foreachNotStopReason/</url>
    
    <content type="html"><![CDATA[<h1 id="forEach-为什么不能被中断？"><a href="#forEach-为什么不能被中断？" class="headerlink" title="forEach 为什么不能被中断？"></a>forEach 为什么不能被中断？</h1><p>在之前一次面试里，被问到foreach的问题，问我为什么不能被中断，我说不知道。。。然后让我手写了foreach的实现</p><h2 id="快速答案"><a href="#快速答案" class="headerlink" title="快速答案"></a>快速答案</h2><p>forEach 不能被中断是因为它的设计哲学：forEach 是一个高阶函数，它接受一个回调函数作为参数，而 break 和 continue 是控制语句，只能在循环结构中使用，不能在函数中使用。</p><h2 id="forEach-的本质"><a href="#forEach-的本质" class="headerlink" title="forEach 的本质"></a>forEach 的本质</h2><h3 id="函数式编程的体现"><a href="#函数式编程的体现" class="headerlink" title="函数式编程的体现"></a>函数式编程的体现</h3><p>forEach 本质上是一个高阶函数，它的实现原理类似于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback, thisArg</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>) &#123;<br>            callback.<span class="hljs-title function_">call</span>(thisArg, <span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从这个实现可以看出，forEach 内部使用的是 for 循环，但它将每次迭代的逻辑封装在回调函数中。</p><h3 id="为什么-break-不起作用"><a href="#为什么-break-不起作用" class="headerlink" title="为什么 break 不起作用"></a>为什么 break 不起作用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// ❌ 这样做会报错：SyntaxError: Illegal break statement</span><br>numbers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 错误！break 只能在循环中使用</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>&#125;);<br><br><span class="hljs-comment">// ❌ 这样做也会报错：SyntaxError: Illegal continue statement  </span><br>numbers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 错误！continue 只能在循环中使用</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>原因分析：</strong></p><ul><li><code>break</code> 和 <code>continue</code> 是循环控制语句，只能在 <code>for</code>、<code>while</code>、<code>do-while</code> 等循环结构中使用</li><li>forEach 的回调函数是一个普通函数，不是循环结构</li><li>JavaScript 引擎无法将函数内的 break&#x2F;continue 与外层的循环关联起来</li></ul><h2 id="forEach-的特点和限制"><a href="#forEach-的特点和限制" class="headerlink" title="forEach 的特点和限制"></a>forEach 的特点和限制</h2><h3 id="1-无法提前终止"><a href="#1-无法提前终止" class="headerlink" title="1. 无法提前终止"></a>1. 无法提前终止</h3><p>forEach 方法会遍历数组中的每个元素，无法中途停止。即使在回调函数中使用 <code>return</code> 语句，也只会跳过当前元素的处理，而不会停止后续元素的遍历。</p><h3 id="2-不改变原数组长度"><a href="#2-不改变原数组长度" class="headerlink" title="2. 不改变原数组长度"></a>2. 不改变原数组长度</h3><p>forEach 在执行过程中不会受到数组长度变化的影响。它会根据调用时的数组长度进行遍历，即使在遍历过程中数组长度发生变化，也不会重新计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>];<br>words.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">word</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(word);<br>    <span class="hljs-keyword">if</span> (word === <span class="hljs-string">&quot;two&quot;</span>) &#123;<br>        words.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 删除第一个元素</span><br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 输出:</span><br><span class="hljs-comment">// one</span><br><span class="hljs-comment">// two</span><br><span class="hljs-comment">// four</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(words); <span class="hljs-comment">// [&#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="3-跳过空槽位"><a href="#3-跳过空槽位" class="headerlink" title="3. 跳过空槽位"></a>3. 跳过空槽位</h3><p>对于稀疏数组（包含空槽位的数组），forEach 会跳过这些空槽位：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arraySparse = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, , <span class="hljs-number">7</span>];<br><span class="hljs-keyword">let</span> numCallbackRuns = <span class="hljs-number">0</span>;<br><br>arraySparse.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123; element &#125;);<br>    numCallbackRuns++;<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123; numCallbackRuns &#125;);<br><span class="hljs-comment">// &#123; element: 1 &#125;</span><br><span class="hljs-comment">// &#123; element: 3 &#125;</span><br><span class="hljs-comment">// &#123; element: 7 &#125;</span><br><span class="hljs-comment">// &#123; numCallbackRuns: 3 &#125;</span><br></code></pre></td></tr></table></figure><h3 id="4-不等待-Promise"><a href="#4-不等待-Promise" class="headerlink" title="4. 不等待 Promise"></a>4. 不等待 Promise</h3><p>forEach 不会等待 Promise 的完成，这对于异步操作来说可能不是期望的行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ratings = [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sumFunction</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><br>ratings.<span class="hljs-title function_">forEach</span>(<span class="hljs-title function_">async</span> (rating) =&gt; &#123;<br>    sum = <span class="hljs-keyword">await</span> <span class="hljs-title function_">sumFunction</span>(sum, rating);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br><span class="hljs-comment">// 期望的输出：14</span><br><span class="hljs-comment">// 实际的输出：0</span><br></code></pre></td></tr></table></figure><h2 id="尝试中断-forEach-的常见误区"><a href="#尝试中断-forEach-的常见误区" class="headerlink" title="尝试中断 forEach 的常见误区"></a>尝试中断 forEach 的常见误区</h2><h3 id="误区1：使用-return-当作-break"><a href="#误区1：使用-return-当作-break" class="headerlink" title="误区1：使用 return 当作 break"></a>误区1：使用 return 当作 break</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// ❌ 很多人以为这样可以中断循环</span><br>numbers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 这只是跳出当前回调函数，相当于 continue</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 输出: 1, 2, 4, 5</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>实际效果：</strong> <code>return</code> 只是跳出当前的回调函数执行，相当于传统循环中的 <code>continue</code>，而不是 <code>break</code>。</p><h3 id="误区2：抛出异常来中断"><a href="#误区2：抛出异常来中断" class="headerlink" title="误区2：抛出异常来中断"></a>误区2：抛出异常来中断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// ❌ 技术上可行，但不推荐</span><br><span class="hljs-keyword">try</span> &#123;<br>    numbers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (num === <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Break&#x27;</span>);<br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 输出: 1, 2</span><br>    &#125;);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">// 捕获异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题：</strong></p><ul><li>滥用异常处理机制</li><li>性能开销大</li><li>代码可读性差</li><li>违背了异常处理的设计初衷</li></ul><h2 id="正确的替代方案"><a href="#正确的替代方案" class="headerlink" title="正确的替代方案"></a>正确的替代方案</h2><h3 id="1-使用传统的-for-循环"><a href="#1-使用传统的-for-循环" class="headerlink" title="1. 使用传统的 for 循环"></a>1. 使用传统的 for 循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// ✅ 可以使用 break 和 continue</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (numbers[i] === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 正确中断</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers[i]); <span class="hljs-comment">// 输出: 1, 2</span><br>&#125;<br><br><span class="hljs-comment">// ✅ for...of 循环也支持</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> numbers) &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 正确中断</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 输出: 1, 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-使用-some-方法"><a href="#2-使用-some-方法" class="headerlink" title="2. 使用 some() 方法"></a>2. 使用 some() 方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// ✅ 使用 some() 实现可中断的遍历</span><br>numbers.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 返回 true 中断遍历</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 输出: 1, 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 返回 false 继续遍历</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="3-使用-every-方法"><a href="#3-使用-every-方法" class="headerlink" title="3. 使用 every() 方法"></a>3. 使用 every() 方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// ✅ 使用 every() 实现可中断的遍历</span><br>numbers.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 返回 false 中断遍历</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 输出: 1, 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 返回 true 继续遍历</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-使用-find-或-findIndex"><a href="#4-使用-find-或-findIndex" class="headerlink" title="4. 使用 find() 或 findIndex()"></a>4. 使用 find() 或 findIndex()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// ✅ 当找到目标时自动停止</span><br><span class="hljs-keyword">const</span> found = numbers.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 输出: 1, 2, 3</span><br>    <span class="hljs-keyword">return</span> num === <span class="hljs-number">3</span>;<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(found); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="5-使用-for…in-和-for…of（适用于可迭代对象）"><a href="#5-使用-for…in-和-for…of（适用于可迭代对象）" class="headerlink" title="5. 使用 for…in 和 for…of（适用于可迭代对象）"></a>5. 使用 for…in 和 for…of（适用于可迭代对象）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// ✅ 使用 for...in 遍历索引</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> index <span class="hljs-keyword">in</span> numbers) &#123;<br>    <span class="hljs-keyword">if</span> (numbers[index] === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers[index]);<br>&#125;<br><br><span class="hljs-comment">// ✅ 使用 for...of 遍历值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> numbers) &#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><h3 id="场景1：数据验证"><a href="#场景1：数据验证" class="headerlink" title="场景1：数据验证"></a>场景1：数据验证</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> users = [<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;alice@example.com&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;invalid-email&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;charlie@example.com&#x27;</span> &#125;<br>];<br><br><span class="hljs-comment">// ❌ 使用 forEach 无法提前中断</span><br><span class="hljs-keyword">let</span> hasInvalidEmail = <span class="hljs-literal">false</span>;<br>users.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!user.<span class="hljs-property">email</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;@&#x27;</span>)) &#123;<br>        hasInvalidEmail = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 无法中断，仍会继续检查剩余用户</span><br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// ✅ 使用 some 可以提前中断</span><br><span class="hljs-keyword">const</span> hasInvalidEmail2 = users.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> !user.<span class="hljs-property">email</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;@&#x27;</span>));<br></code></pre></td></tr></table></figure><h3 id="场景2：搜索功能"><a href="#场景2：搜索功能" class="headerlink" title="场景2：搜索功能"></a>场景2：搜索功能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> products = [<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;iPhone&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">999</span> &#125;,<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Samsung&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">899</span> &#125;,<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Google Pixel&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">799</span> &#125;<br>];<br><br><span class="hljs-comment">// ❌ 使用 forEach 效率低</span><br><span class="hljs-keyword">let</span> foundProduct = <span class="hljs-literal">null</span>;<br>products.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (product.<span class="hljs-property">name</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;iPhone&#x27;</span>)) &#123;<br>        foundProduct = product;<br>        <span class="hljs-comment">// 无法中断，继续遍历剩余产品</span><br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// ✅ 使用 find 效率高</span><br><span class="hljs-keyword">const</span> foundProduct2 = products.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span> <br>    product.<span class="hljs-property">name</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;iPhone&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><h3 id="场景3：条件处理"><a href="#场景3：条件处理" class="headerlink" title="场景3：条件处理"></a>场景3：条件处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> tasks = [<span class="hljs-string">&#x27;task1&#x27;</span>, <span class="hljs-string">&#x27;task2&#x27;</span>, <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;task4&#x27;</span>];<br><br><span class="hljs-comment">// ❌ forEach 无法处理错误后停止</span><br>tasks.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">task</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (task === <span class="hljs-string">&#x27;error&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error encountered&#x27;</span>);<br>        <span class="hljs-comment">// 无法停止，会继续处理后续任务</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Processing <span class="hljs-subst">$&#123;task&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// ✅ 使用 for...of 可以优雅处理</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> task <span class="hljs-keyword">of</span> tasks) &#123;<br>    <span class="hljs-keyword">if</span> (task === <span class="hljs-string">&#x27;error&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error encountered, stopping&#x27;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Processing <span class="hljs-subst">$&#123;task&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="设计哲学的深层思考"><a href="#设计哲学的深层思考" class="headerlink" title="设计哲学的深层思考"></a>设计哲学的深层思考</h2><h3 id="函数式-vs-命令式"><a href="#函数式-vs-命令式" class="headerlink" title="函数式 vs 命令式"></a>函数式 vs 命令式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 命令式风格 - 关注&quot;如何做&quot;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (condition) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-title function_">doSomething</span>(array[i]);<br>&#125;<br><br><span class="hljs-comment">// 函数式风格 - 关注&quot;做什么&quot;</span><br>array<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !condition)<br>    .<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title function_">doSomething</span>(item));<br></code></pre></td></tr></table></figure><p>forEach 体现了函数式编程的思想：</p><ul><li><strong>声明式</strong>：描述要做什么，而不是如何做</li><li><strong>不可变性</strong>：不改变原数组</li><li><strong>高阶函数</strong>：接受函数作为参数</li><li><strong>副作用分离</strong>：将遍历逻辑与业务逻辑分离</li></ul><h3 id="为什么不支持中断？"><a href="#为什么不支持中断？" class="headerlink" title="为什么不支持中断？"></a>为什么不支持中断？</h3><ol><li><strong>一致性</strong>：保持函数式编程的一致性</li><li><strong>简洁性</strong>：避免复杂的控制流</li><li><strong>可预测性</strong>：确保回调函数被每个元素调用一次</li><li><strong>并行化潜力</strong>：为未来的并行处理留下空间</li></ol><h2 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h2><h3 id="选择合适的遍历方法"><a href="#选择合适的遍历方法" class="headerlink" title="选择合适的遍历方法"></a>选择合适的遍历方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ✅ 根据需求选择合适的方法</span><br><br><span class="hljs-comment">// 1. 需要对每个元素执行操作，不需要中断</span><br>array.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item));<br><br><span class="hljs-comment">// 2. 需要查找特定元素</span><br><span class="hljs-keyword">const</span> found = array.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === targetId);<br><br><span class="hljs-comment">// 3. 需要检查条件</span><br><span class="hljs-keyword">const</span> hasValidItems = array.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">isValid</span>);<br><span class="hljs-keyword">const</span> allValid = array.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">isValid</span>);<br><br><span class="hljs-comment">// 4. 需要复杂的控制流</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> array) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldSkip</span>(item)) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldStop</span>(item)) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-title function_">process</span>(item);<br>&#125;<br><br><span class="hljs-comment">// 5. 需要索引和复杂逻辑</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">// 复杂的索引操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ✅ 在大数组中查找时，优先使用可中断的方法</span><br><span class="hljs-keyword">const</span> largeArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 好：可以提前中断</span><br><span class="hljs-keyword">const</span> found = largeArray.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item === target);<br><br><span class="hljs-comment">// 差：必须遍历整个数组</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>largeArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (item === target &amp;&amp; !result) &#123;<br>        result = item;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="处理异步操作"><a href="#处理异步操作" class="headerlink" title="处理异步操作"></a>处理异步操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ❌ forEach 不会等待 Promise</span><br><span class="hljs-keyword">const</span> urls = [<span class="hljs-string">&#x27;url1&#x27;</span>, <span class="hljs-string">&#x27;url2&#x27;</span>, <span class="hljs-string">&#x27;url3&#x27;</span>];<br>urls.<span class="hljs-title function_">forEach</span>(<span class="hljs-title function_">async</span> (url) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>&#125;);<br><br><span class="hljs-comment">// ✅ 使用 for...of 等待每个 Promise</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUrls</span>(<span class="hljs-params">urls</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> url <span class="hljs-keyword">of</span> urls) &#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ✅ 或者使用 Promise.all 并行处理</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUrlsParallel</span>(<span class="hljs-params">urls</span>) &#123;<br>    <span class="hljs-keyword">const</span> promises = urls.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> <span class="hljs-title function_">fetch</span>(url));<br>    <span class="hljs-keyword">const</span> responses = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);<br>    responses.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>forEach 不能被中断的根本原因是：</p><ol><li><strong>设计哲学</strong>：forEach 是函数式编程的体现，强调声明式和不可变性</li><li><strong>语法限制</strong>：break&#x2F;continue 只能在循环结构中使用，不能在函数中使用</li><li><strong>一致性考虑</strong>：保持 API 的简洁和可预测性</li></ol><p><strong>实用建议：</strong></p><ul><li>需要中断时，选择 <code>for</code>、<code>for...of</code>、<code>some</code>、<code>every</code>、<code>find</code> 等方法</li><li>forEach 适用于需要对每个元素执行操作且不需要中断的场景</li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>forEach</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 必学：Vim工具使用方法</title>
    <link href="/blog/2025/08/21/linux-Vim%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2025/08/21/linux-Vim%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-必学：Vim工具使用方法"><a href="#Linux-必学：Vim工具使用方法" class="headerlink" title="Linux 必学：Vim工具使用方法"></a>Linux 必学：Vim工具使用方法</h1><p>在 Linux 江湖里，Vim 堪称 “编辑器之神”。它不仅能让你双手不离键盘完成所有操作，更能通过代码高亮、智能补全、多窗口编辑等黑科技，把敲代码变成一场指尖舞蹈。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aP5o5iaj0QUr83fll7rQOicFibOGGmHArRehBX788wjCibatXTGSc9vSkuw9tyKicbEpTiaTVdrnpp7T29ibdQr0Fd3Lg/640?wx_fmt=png&from=appmsg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h2 id="🚀基础操作：三招解锁-Vim-世界"><a href="#🚀基础操作：三招解锁-Vim-世界" class="headerlink" title="🚀基础操作：三招解锁 Vim 世界"></a>🚀基础操作：三招解锁 Vim 世界</h2><p>Vim 有三个核心模式</p><p><strong>命令模式（启动即进入）：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">i切换输入模式（<span class="hljs-built_in">Insert</span>）<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">x</span>删除光标字符<br></code></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:wq</span>保存并退出（经典组合键）<br></code></pre></td></tr></table></figure><p><strong>输入模式：尽情打字，左下角会显示</strong><code>--INSERT--</code></p><p>**底线命令模式：**输入<code>:``set nu</code>显示行号，<code>:s/old/new/g</code>批量替换</p><h2 id="🛠️快捷键库：让操作飞起来"><a href="#🛠️快捷键库：让操作飞起来" class="headerlink" title="🛠️快捷键库：让操作飞起来"></a>🛠️快捷键库：让操作飞起来</h2><h3 id="光标移动（告别鼠标！）"><a href="#光标移动（告别鼠标！）" class="headerlink" title="光标移动（告别鼠标！）"></a>光标移动（告别鼠标！）</h3><ul><li><code>w 跳到下一个单词开头</code></li><li><code>gg回到文件顶部</code></li><li><code>G直达文件末尾</code></li></ul><h3 id="编辑魔法"><a href="#编辑魔法" class="headerlink" title="编辑魔法"></a>编辑魔法</h3><ul><li><code>dd删除整行（&quot;Double Delete&quot;）</code></li><li><code>yy复制当前行（&quot;Yank&quot;）</code></li><li><code>p粘贴到光标后（&quot;Put&quot;）</code></li></ul><h2 id="🔍进阶技能：效率翻倍秘籍"><a href="#🔍进阶技能：效率翻倍秘籍" class="headerlink" title="🔍进阶技能：效率翻倍秘籍"></a>🔍进阶技能：效率翻倍秘籍</h2><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><ul><li><code>/keyword向下搜索（回车后n下一个，N上一个）</code></li><li><code>:%s/old/new/g全文替换（记得备份！）</code></li></ul><h3 id="多窗口操作"><a href="#多窗口操作" class="headerlink" title="多窗口操作"></a>多窗口操作</h3><ul><li><code>:sp水平分割窗口</code></li><li><code>Ctrl+w  + 方向键 切换窗口</code></li></ul><h3 id="宏录制"><a href="#宏录制" class="headerlink" title="宏录制"></a>宏录制</h3><ol><li><code>qa开始录制（a 为任意字母）</code></li><li>执行操作（如<code>ddp</code>交换行）</li><li><code>q 结束录制</code></li><li><code>@a重复播放</code></li></ol><h2 id="⚙️个性化配置：打造专属编辑器"><a href="#⚙️个性化配置：打造专属编辑器" class="headerlink" title="⚙️个性化配置：打造专属编辑器"></a>⚙️个性化配置：打造专属编辑器</h2><p>编辑<code>~/.vimrc</code>文件，添加以下魔法：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> nu          <span class="hljs-comment">&quot;显示行号&quot;</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">tabstop=4</span>   <span class="hljs-comment">&quot;Tab为4空格&quot;</span><br>syntax <span class="hljs-comment">on</span>       <span class="hljs-comment">&quot;代码高亮&quot;</span><br>colorscheme <span class="hljs-comment">desert</span> <span class="hljs-comment">&quot;护眼配色&quot;</span><br></code></pre></td></tr></table></figure><h2 id="💡安装方法"><a href="#💡安装方法" class="headerlink" title="💡安装方法"></a>💡安装方法</h2><h3 id="Red-Hat-CentOS-Fedora-系（DNF-YUM包管理）"><a href="#Red-Hat-CentOS-Fedora-系（DNF-YUM包管理）" class="headerlink" title="Red Hat&#x2F;CentOS&#x2F;Fedora 系（DNF&#x2F;YUM包管理）"></a><strong>Red Hat&#x2F;CentOS&#x2F;Fedora 系（DNF&#x2F;YUM包管理）</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Fedora/CentOS 8+ 使用DNF：</span><br><span class="hljs-built_in">sudo</span> dnf install vim-enhanced<br><span class="hljs-comment"># CentOS 7及以下使用YUM：</span><br><span class="hljs-built_in">sudo</span> yum install vim-enhanced<br></code></pre></td></tr></table></figure><h3 id="Debian-Ubuntu-系（APT包管理）"><a href="#Debian-Ubuntu-系（APT包管理）" class="headerlink" title="Debian&#x2F;Ubuntu 系（APT包管理）"></a><strong>Debian&#x2F;Ubuntu 系（APT包管理）</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新软件包列表（可选但推荐）</span><br><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-comment"># 安装Vim</span><br><span class="hljs-built_in">sudo</span> apt install vim<br></code></pre></td></tr></table></figure><h3 id="openSUSE（Zypper包管理）"><a href="#openSUSE（Zypper包管理）" class="headerlink" title="openSUSE（Zypper包管理）"></a><strong>openSUSE（Zypper包管理）</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> zypper install vim<br></code></pre></td></tr></table></figure><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a><strong>验证安装</strong></h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> --<span class="hljs-keyword">version</span><br># 或运行 <span class="hljs-keyword">vim</span> 进入编辑器<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rem适配PC端和移动端</title>
    <link href="/blog/2025/01/09/css-fitter/"/>
    <url>/blog/2025/01/09/css-fitter/</url>
    
    <content type="html"><![CDATA[<h1 id="rem适配PC端和移动端-三种方式"><a href="#rem适配PC端和移动端-三种方式" class="headerlink" title="rem适配PC端和移动端(三种方式)"></a>rem适配PC端和移动端(三种方式)</h1><h3 id="一、媒体查询-根据屏幕尺寸-设置rem的值"><a href="#一、媒体查询-根据屏幕尺寸-设置rem的值" class="headerlink" title="一、媒体查询,根据屏幕尺寸,设置rem的值"></a>一、媒体查询,根据屏幕尺寸,设置rem的值</h3><p>假设目前需要适配移动端320,360,375,1920的分辨率,才用scss,设置一个变量$no为10,用于分10份,</p><ul><li>@media—开启媒体查询</li><li>screen—查询的类型(屏幕宽度)</li><li>max-width最大值</li><li>min-width最小值</li></ul><p>global.scss,在main.js中引入</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$no</span>: <span class="hljs-number">10</span>;<br><span class="hljs-comment">//表示宽度最大值为320的情况下,设置rem为 320/10 px,即32px</span><br><span class="hljs-comment">//所以只要小于320px,统一rem为32px,这样就设置了最小值</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">320px</span>) &#123;<br>  <span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">320px</span> / <span class="hljs-variable">$no</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//表示宽度最小值为320的情况下,设置rem为 320/10 px,即32px</span><br><span class="hljs-comment">//所以只要大于320,rem值就为32px</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">320px</span>) &#123;<br>  <span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">320px</span> / <span class="hljs-variable">$no</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//表示宽度最小值为360的情况下,设置rem为 360/10 px,即36px</span><br><span class="hljs-comment">//所以只要大于等于360,rem的值就为36px</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">320px</span>) &#123;<br>  <span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">320px</span> / <span class="hljs-variable">$no</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//下面也是同理,同时利用css下方样式的覆盖性,只要按顺序写就能保证能检测到</span><br><span class="hljs-comment">//表示宽度最小值为375的情况下,设置rem为 375/10 px,即37.5px</span><br><span class="hljs-comment">//所以只要大于等于375,rem的值就为37.5px</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">375px</span>) &#123;<br>  <span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">375px</span> / <span class="hljs-variable">$no</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//PC端适配--使用pc端的分辨率就行</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1920px</span>) &#123;<br>  <span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1920px</span> / <span class="hljs-variable">$no</span> <br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//最后设置个最大值,max-width: 1920px---&gt;最大值为1920px</span><br><span class="hljs-comment">//只要小于1920px,统一rem为192px,这样就设置了最大值</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">1920px</span>) &#123;<br>  <span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1920px</span> / <span class="hljs-variable">$no</span> <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在网页中使用rem做单位,假如100px在375px中长度就用2.66rem做单位(有插件可以转换,下文介绍)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">2.66rem</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">2.66rem</span>;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="二、媒体查询-flexible-js"><a href="#二、媒体查询-flexible-js" class="headerlink" title="二、媒体查询+flexible.js"></a>二、媒体查询+flexible.js</h3><p>flexible.js就是手淘团队推出转化rem的方法,复制引用就好,原理就是给每个html标签添加个行内样式 <code>style=&quot;font-size: xxx px &quot;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"> (<span class="hljs-keyword">function</span> <span class="hljs-title function_">flexible</span> (<span class="hljs-params"><span class="hljs-variable language_">window</span>, <span class="hljs-variable language_">document</span></span>) &#123;<br>  <span class="hljs-keyword">var</span> docEl = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span><br>  <span class="hljs-keyword">var</span> dpr = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span> || <span class="hljs-number">1</span><br><br>  <span class="hljs-comment">// adjust body font size</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setBodyFontSize</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>) &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = (<span class="hljs-number">12</span> * dpr) + <span class="hljs-string">&#x27;px&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, setBodyFontSize)<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">setBodyFontSize</span>();<br>   <br>   <br>  <span class="hljs-comment">//这里也是设置的份数,也是用10</span><br>  <span class="hljs-comment">// set 1rem = viewWidth / 10 </span><br>  <span class="hljs-comment">// 把屏幕平均分成10等份。比如1920/10= 192 px,这个时候1rem就是192px,配合vscod插件快速适配，在style中使用媒体查询。</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setRemUnit</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> rem = docEl.<span class="hljs-property">clientWidth</span> / <span class="hljs-number">10</span><br>    docEl.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = rem + <span class="hljs-string">&#x27;px&#x27;</span><br>  &#125;<br><br>  <span class="hljs-title function_">setRemUnit</span>()<br><br>  <span class="hljs-comment">// reset rem unit on page resize</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, setRemUnit)<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;pageshow&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">persisted</span>) &#123;<br>      <span class="hljs-title function_">setRemUnit</span>()<br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-comment">// detect 0.5px supports</span><br>  <span class="hljs-keyword">if</span> (dpr &gt;= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">var</span> fakeBody = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;body&#x27;</span>)<br>    <span class="hljs-keyword">var</span> testElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br>    testElement.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&#x27;.5px solid transparent&#x27;</span><br>    fakeBody.<span class="hljs-title function_">appendChild</span>(testElement)<br>    docEl.<span class="hljs-title function_">appendChild</span>(fakeBody)<br>    <span class="hljs-keyword">if</span> (testElement.<span class="hljs-property">offsetHeight</span> === <span class="hljs-number">1</span>) &#123;<br>      docEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;hairlines&#x27;</span>)<br>    &#125;<br>    docEl.<span class="hljs-title function_">removeChild</span>(fakeBody)<br>  &#125;<br>&#125;(<span class="hljs-variable language_">window</span>, <span class="hljs-variable language_">document</span>))<br></code></pre></td></tr></table></figure><p>在main.js引入 <code>import &#39;@/utils/flexible&#39;</code></p><p>设置最大值和最小值,加个important,提升权重</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">320px</span>) &#123;<br>  <span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">320px</span> / <span class="hljs-variable">$no</span><span class="hljs-meta">!important</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">1920px</span>) &#123;<br>  <span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1920px</span> / <span class="hljs-variable">$no</span> <span class="hljs-meta">!important</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插件转化的问题"><a href="#插件转化的问题" class="headerlink" title="插件转化的问题"></a>插件转化的问题</h3><p>vscode安装cssrem插件</p><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ac429fc15ae54cab98b58e98eda694f8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmd562SNzk5:q75.awebp?rk3s=f64ab15b&x-expires=1736691325&x-signature=8bt3rYCiLQt2r9Zgkh73ezZN5NU=" alt="Snipaste_2024-12-22_22-36-07.png"> 找到设置根字体大小的地方,假设设计稿为1920,设置为10等份,那根字体大小就为1920&#x2F;10&#x3D;192,之后写css的时候,只要写 xx px,即会有转化rem选项</p><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb9674ebbfba4b42bfa172628698a995~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmd562SNzk5:q75.awebp?rk3s=f64ab15b&x-expires=1736691325&x-signature=kiF9tnPU0qJ40Ryh0pYAkayUb4c=" alt="Snipaste_2024-12-22_22-36-42.png"></p><h3 id="三、postcss-pxtorem插件自动转化"><a href="#三、postcss-pxtorem插件自动转化" class="headerlink" title="三、postcss-pxtorem插件自动转化"></a>三、postcss-pxtorem插件自动转化</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>可能会有版本问题,遇到可以安装<a href="mailto:&#x70;&#x6f;&#115;&#116;&#x63;&#x73;&#115;&#x2d;&#x70;&#x78;&#x74;&#111;&#114;&#x65;&#109;&#64;&#x35;&#x2e;&#49;&#x2e;&#49;">postcss-pxtorem@5.1.1</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install postcss postcss-pxtorem --save-dev<br></code></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>在你的项目根目录中创建一个 <code>postcss.config.js</code> 文件，并添加以下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">//配置自行选择使用,rootValue和propList应该为必选项</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: &#123;<br>    <span class="hljs-string">&#x27;postcss-pxtorem&#x27;</span>: &#123;<br>      <span class="hljs-attr">rootValue</span>: <span class="hljs-number">37.5</span>, <span class="hljs-comment">// 表示根元素字体大小或根据input参数返回根元素字体大小</span><br>      <span class="hljs-attr">propList</span>: [<span class="hljs-string">&#x27;*&#x27;</span>], <span class="hljs-comment">// 可以从px更改为rem的属性, 通配符*表示启用所有属性</span><br>      <span class="hljs-attr">selectorBlackList</span>: [<span class="hljs-string">&#x27;.norem&#x27;</span>], <span class="hljs-comment">// 过滤掉.norem开头的class，不进行rem转换</span><br>      <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否直接替换原来的 px 单位</span><br>      <span class="hljs-attr">mediaQuery</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否转换媒体查询中的 px</span><br>      <span class="hljs-attr">minPixelValue</span>: <span class="hljs-number">1</span><span class="hljs-comment">// 设置要替换的最小像素值</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="创建utils-rem-js-在main-js中引入-之后直接使用单位px-会自动转化"><a href="#创建utils-rem-js-在main-js中引入-之后直接使用单位px-会自动转化" class="headerlink" title="创建utils&#x2F;rem.js,在main.js中引入,之后直接使用单位px,会自动转化"></a>创建utils&#x2F;rem.js,在main.js中引入,之后直接使用单位px,会自动转化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 配置基本大小</span><br><span class="hljs-keyword">let</span> baseSize = <span class="hljs-number">37.5</span>;<br><br><span class="hljs-comment">// 设置 rem 函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setRem</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//当前页面宽度相对于375px屏幕宽的缩放比例，可根据自己需要修改。</span><br>  <span class="hljs-keyword">let</span> scale = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> / <span class="hljs-number">375</span>;<br>  <span class="hljs-comment">//设置页面根节点字体大小（“Math.min(scale, 2)” 指最高放大比例为2，即最大根字体大小为37.5*2=75，可根据实际业务需求调整）</span><br>  <span class="hljs-keyword">let</span> fz = baseSize * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(scale, <span class="hljs-number">2</span>)<br>  <span class="hljs-comment">//获得根字体大小后,给全部页面设置根字体大小</span><br>  <span class="hljs-comment">//业务需要限制显示页面的最小值,我这里是根据倍数限制的,因为1倍的字体大小为37.5,具体情况可以自己设定</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = scale &gt;= <span class="hljs-number">1</span> ? fz + <span class="hljs-string">&#x27;px&#x27;</span> : <span class="hljs-number">37.5</span> + <span class="hljs-string">&#x27;px&#x27;</span><br><br>&#125;<br><span class="hljs-title function_">setRem</span>(); <span class="hljs-comment">//初始化</span><br><br><span class="hljs-comment">// 适配 - 重置函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resetRem</span> (<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-keyword">if</span> (num) baseSize = <span class="hljs-title class_">Number</span>(num);<br>  <span class="hljs-title function_">setRem</span>();<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">resetRem</span> = resetRem; <span class="hljs-comment">// 全局可调用(其他方式也可)</span><br><br><span class="hljs-comment">// 改变窗口大小时重置 rem</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">setRem</span>()<br>&#125;;<br></code></pre></td></tr></table></figure><p>三种方式都可以实现适配,个人感受如下:</p><ul><li>第一种比较原生,每多适配一个就得多写一个媒体查询</li><li>第二种属于第一种的进阶版</li><li>第三种为插件转化,更方便,但可能会有版本兼容的问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rem适配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 的泛型</title>
    <link href="/blog/2024/12/27/ts-generics/"/>
    <url>/blog/2024/12/27/ts-generics/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-的泛型"><a href="#TypeScript-的泛型" class="headerlink" title="TypeScript 的泛型"></a>TypeScript 的泛型</h1><p>TypeScript 的泛型（Generics）是用于创建可复用组件的一种强大工具。它们允许你编写能够处理任意类型数据的函数、接口或类，同时保持严格的类型检查。通过使用泛型，你可以确保代码的灵活性和类型安全性。</p><h3 id="泛型的基本概念"><a href="#泛型的基本概念" class="headerlink" title="泛型的基本概念"></a>泛型的基本概念</h3><ul><li><strong>泛型函数</strong>：可以接受任何类型的参数，并返回相同或不同的类型。</li><li><strong>泛型类</strong>：可以在定义类时指定一个或多个类型参数，使类中的属性和方法能够操作这些类型。</li><li><strong>泛型接口</strong>：为实现该接口的对象提供类型参数，以确保对象中特定成员的类型一致性。</li><li><strong>泛型约束</strong>：限制泛型参数的类型范围，以确保某些操作在这些类型上是有效的。</li></ul><h3 id="使用泛型的例子"><a href="#使用泛型的例子" class="headerlink" title="使用泛型的例子"></a>使用泛型的例子</h3><h4 id="1-泛型函数"><a href="#1-泛型函数" class="headerlink" title="1. 泛型函数"></a>1. 泛型函数</h4><p>最简单的泛型用法是定义一个泛型函数。这里有一个例子，展示了如何创建一个能返回输入值的函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-keyword">let</span> output = identity&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;myString&quot;</span>); <span class="hljs-comment">// 指定T为string类型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(output);<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>identity</code> 函数可以接受任何类型的参数，并返回相同的类型。当你调用 <code>identity</code> 函数时，可以通过尖括号 <code>&lt;T&gt;</code> 显式地指定类型参数，也可以让 TypeScript 自动推断类型。</p><h4 id="2-泛型类"><a href="#2-泛型类" class="headerlink" title="2. 泛型类"></a>2. 泛型类</h4><p>下面是一个泛型类的例子，它使用了一个类型参数来确保属性和方法的一致性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericNumber</span>&lt;T&gt; &#123;<br>    <span class="hljs-attr">zeroValue</span>: T;<br>    <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">x</span>: T, <span class="hljs-attr">y</span>: T</span>) =&gt;</span> T;<br>&#125;<br><br><span class="hljs-keyword">let</span> myGenericNumber = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericNumber</span>&lt;<span class="hljs-built_in">number</span>&gt;();<br>myGenericNumber.<span class="hljs-property">zeroValue</span> = <span class="hljs-number">0</span>;<br>myGenericNumber.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) &#123; <span class="hljs-keyword">return</span> x + y; &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myGenericNumber.<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)); <span class="hljs-comment">// 输出30</span><br></code></pre></td></tr></table></figure><h4 id="3-泛型接口"><a href="#3-泛型接口" class="headerlink" title="3. 泛型接口"></a>3. 泛型接口</h4><p>你可以使用泛型来定义接口，使得接口可以适应多种类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lengthwise</span> &#123;<br>    <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Lengthwise</span>&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);  <span class="hljs-comment">// 现在我们知道arg有length属性</span><br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-title function_">loggingIdentity</span>(&#123;<span class="hljs-attr">length</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>Lengthwise</code> 接口，它要求实现的对象必须拥有 <code>length</code> 属性。然后我们定义了一个泛型函数 <code>loggingIdentity</code>，它只接受实现了 <code>Lengthwise</code> 接口的对象作为参数。</p><h4 id="4-泛型约束"><a href="#4-泛型约束" class="headerlink" title="4. 泛型约束"></a>4. 泛型约束</h4><p>有时你可能想要限制泛型的类型范围，以确保某些操作是可以执行的。这可以通过使用类型约束来实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> getProperty&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K) &#123;<br>    <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br><br><span class="hljs-keyword">let</span> x = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span> &#125;;<br><br><span class="hljs-title function_">getProperty</span>(x, <span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// ok</span><br><span class="hljs-comment">// getProperty(x, &quot;m&quot;); // 错误，&#x27;m&#x27; 不是 &#x27;x&#x27; 的键</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>K extends keyof T</code> 表示 <code>K</code> 必须是 <code>T</code> 对象的一个有效键名。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>泛型是 TypeScript 中非常有用的功能，它可以帮助你编写更加通用和安全的代码。通过定义泛型函数、类和接口，你可以创建灵活且类型安全的组件，适用于各种不同类型的输入。同时，泛型约束让你能够在保证灵活性的同时，确保代码只能按照预期的方式工作。</p>]]></content>
    
    
    <categories>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript 的泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-router</title>
    <link href="/blog/2024/08/23/react-router/"/>
    <url>/blog/2024/08/23/react-router/</url>
    
    <content type="html"><![CDATA[<h1 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h1><h2 id="一、使用react-router"><a href="#一、使用react-router" class="headerlink" title="一、使用react-router"></a>一、使用react-router</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; createBrowserRouter, <span class="hljs-title class_">RouterProvider</span>, <span class="hljs-title class_">Navigate</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Page1</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./pages/page1&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Page2</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./pages/page2&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Page3</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./pages/page3&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/page1&#x27;</span>,<br>  <span class="hljs-title class_">Component</span>: <span class="hljs-title class_">Page1</span>,<br>&#125;, &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/page2&#x27;</span>,<br>  <span class="hljs-title class_">Component</span>: <span class="hljs-title class_">Page2</span>,<br>&#125;, &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/page3&#x27;</span>,<br>  <span class="hljs-title class_">Component</span>: <span class="hljs-title class_">Page3</span>,<br>&#125;])<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterProvider</span> <span class="hljs-attr">router</span>=<span class="hljs-string">&#123;router&#125;</span> /&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br></code></pre></td></tr></table></figure><h2 id="二、重定向"><a href="#二、重定向" class="headerlink" title="二、重定向"></a>二、重定向</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>  <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/page1&quot;</span> /&gt;</span></span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、自定义404页面"><a href="#三、自定义404页面" class="headerlink" title="三、自定义404页面"></a>三、自定义404页面</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">NotFound</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./NotFound&#x27;</span><br>...<br>&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>  <span class="hljs-title class_">Component</span>: <span class="hljs-title class_">NotFound</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、Link组件实现路由跳转"><a href="#四、Link组件实现路由跳转" class="headerlink" title="四、Link组件实现路由跳转"></a>四、Link组件实现路由跳转</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/page1&#x27;</span>&gt;</span>page1<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterProvider</span> <span class="hljs-attr">router</span>=<span class="hljs-string">frouter&#125;</span> /&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><h2 id="五、路由按需加载"><a href="#五、路由按需加载" class="headerlink" title="五、路由按需加载"></a>五、路由按需加载</h2><p>​借助react的<code>lazy</code>和<code>Suspense</code>可以轻松的实现按需加载。路由按需加载是优化首屏时间的一个重要方法，相当于把一个大的包，拆成了一个个小包，只有访问某个页面的时候，才去加载对应的js，减少了首屏js的体积。使用lazy动态导入组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>，<br><span class="hljs-title class_">Component</span>: <span class="hljs-title class_">Layout</span>,<br><span class="hljs-attr">children</span>: [&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/page1&#x27;</span><br><span class="hljs-title class_">Component</span>:<span class="hljs-title function_">lazy</span>(()=<span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/page1/index.tsx&#x27;</span>))<br>&#125;，<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/page2&#x27;</span>，<br><span class="hljs-title class_">Component</span>:<span class="hljs-title function_">lazy</span>(()<span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/page2/index.tsx&#x27;</span>))<br>&#125;，<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/page3&#x27;</span><br><span class="hljs-title class_">Component</span>:<span class="hljs-title function_">lazy</span>(()=<span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./pages/page3/index.tsx&#x27;</span>)),<br>&#125;<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>,<br><span class="hljs-attr">element</span>:<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/page1&quot;</span>/&gt;</span></span><br>&#125;，<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;*&#x27;</span>,<br><span class="hljs-title class_">Component</span>: <span class="hljs-title class_">NotFound</span><br>&#125;<br>])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端规范总结(阿里)</title>
    <link href="/blog/2024/08/23/js-web/"/>
    <url>/blog/2024/08/23/js-web/</url>
    
    <content type="html"><![CDATA[<h1 id="前端规范总结-阿里"><a href="#前端规范总结-阿里" class="headerlink" title="前端规范总结(阿里)"></a>前端规范总结(阿里)</h1><h2 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h2><p>1.规定字符编码 meta charset</p><p>2.IE 兼容模式 content&#x3D;”IE&#x3D;Edge”</p><p>3.doctype大写</p><p>4.减少div，多使用header，footer等语义标签</p><p>5.属性使用双引号</p><h2 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a>二、CSS</h2><ul><li>类目小写用中划线 fw-test-0010</li><li>子类选择器不使用.xx选择器使用 &gt; 选择器</li><li>使用缩写属性</li><li>属性单独占用一行</li><li>省略0后单位</li><li>减少使用ID选择器</li></ul><h2 id="三、LESS"><a href="#三、LESS" class="headerlink" title="三、LESS"></a>三、LESS</h2><ul><li>公共文件放在style&#x2F;less&#x2F;common中</li><li>代码顺序 @import引用 @变量声明 .page样式说明</li><li>减少嵌套层级（&lt;20行）</li></ul><h2 id="四、JavaScript"><a href="#四、JavaScript" class="headerlink" title="四、JavaScript"></a>四、JavaScript</h2><ul><li>驼峰命名不能使用下划线</li><li>变量、函数、成员变量、局部变量都是用该规则</li><li>常量命名全部大写、间隔使用下划线、意思表达完整无需简写</li></ul><h2 id="五、代码格式"><a href="#五、代码格式" class="headerlink" title="五、代码格式"></a>五、代码格式</h2><ul><li>tab缩进默认两格</li><li>字符串引号使用单引号</li><li>对象声明使用字面量 code a &#x3D; [] Not a &#x3D; new Object()</li><li>使用ES6+语法</li><li>关键词if….后必须有大括号</li><li>undefined永远不能作为判断</li><li>循环判断不能超过三层</li><li>上下文的this只能使用self</li><li>慎用console.log会导致性能问题</li></ul><h2 id="六、Vue规范"><a href="#六、Vue规范" class="headerlink" title="六、Vue规范"></a>六、Vue规范</h2><ul><li>组件名为多单词</li><li>组件文件明使用pascal-case格式</li><li>基础组件文件名使用base开头</li><li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名</li><li>data必须为函数</li><li>Prop定义必须使用驼峰、指定类型、加上注释说明、加上required或defalut、必须加上validator验证</li><li>组件样式必须使用scoped</li><li>较多特性必须换行</li><li>组件模板必须使用简单表达式(模板元素内少嵌入计算代码，多使用计算属性computed)</li><li>指令使用缩写格式</li><li>标签顺序保持一致</li><li>v-for必须设置key</li><li>v-show(高频开关显示)与v-if(低频开关显示)选择</li><li>script顺序(name &gt; components &gt; mixins &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数 &gt; methods)</li></ul><h2 id="七、Vue-Router规范"><a href="#七、Vue-Router规范" class="headerlink" title="七、Vue Router规范"></a>七、Vue Router规范</h2><ul><li>页面跳转直接使用路由传参不使用Vuex</li><li>使用懒加载</li><li>router命名 path、childrenPoints才用kebab-case命名，name使用组件命名规则</li><li>path必须使用&#x2F;开头</li></ul><h2 id="八、Vue项目结构规范"><a href="#八、Vue项目结构规范" class="headerlink" title="八、Vue项目结构规范"></a>八、Vue项目结构规范</h2><ul><li>项目结构命名必须与后端统一</li><li>使用Vue-cli作为脚手架</li><li>文件结构规则</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql">src源码目录<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> api    api接口<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> aassets   静态资源<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> components   公共组件<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> config    配置信息<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> constants   常量信息<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> directives   自定义指令<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> filters     过滤器，全局工具<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> datas   模拟数据 临时文件<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> lib    外部引用插件及修改文件<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> mock   模拟接口 临时文件<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> plugins   插件全局使用<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> router   路由统一管理<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> store  Vuex统一管理<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> themes   自定义主题文件<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> views    视图目录<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> role    role模块名<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> role<span class="hljs-operator">-</span>list   role列表页面<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> role<span class="hljs-operator">-</span><span class="hljs-keyword">add</span>    role新建页面<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> role<span class="hljs-operator">-</span><span class="hljs-keyword">update</span>   role更新页面<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> index.less    role模块样式<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> components    role模块通用组件文件夹<br> <span class="hljs-operator">|</span> <span class="hljs-operator">-</span> employee    employee模块<br></code></pre></td></tr></table></figure><h3 id="api目录"><a href="#api目录" class="headerlink" title="api目录"></a>api目录</h3><ul><li>文件、变量要与后端接口一致</li><li>一个controller对应一个api文件</li><li>api方法名字要与后端api url保持一致</li><li>api每个方法都要添加注释 与后端swagger文档一致</li></ul><h3 id="assets目录"><a href="#assets目录" class="headerlink" title="assets目录"></a>assets目录</h3><ul><li>主要放置images、styles、icons等，命名规范kebab-case</li></ul><h3 id="components目录"><a href="#components目录" class="headerlink" title="components目录"></a>components目录</h3><ul><li>目录及文件都是用kebab-case命名</li></ul><h3 id="constants目录"><a href="#constants目录" class="headerlink" title="constants目录"></a>constants目录</h3><ul><li>存放所有常量，如需放在vue使用要安装vue-enum插件（枚举插件）</li></ul><h3 id="router-与-store目录"><a href="#router-与-store目录" class="headerlink" title="router 与 store目录"></a>router 与 store目录</h3><ul><li>router与store必须拆分</li><li>router按照views结构保持一致</li><li>store按照业务拆分js</li></ul><h3 id="views目录"><a href="#views目录" class="headerlink" title="views目录"></a>views目录</h3><ul><li>命名与后端一致</li><li>组件命名用PascalCase规则</li></ul><h3 id="注释说明"><a href="#注释说明" class="headerlink" title="注释说明"></a>注释说明</h3><ul><li>公共组件说明、api接口处、store（state、mutation、action）处、vue template处、methods处、data非常见单词处必须加注释</li></ul><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><ul><li>不要手动操作DOM</li><li>删除无用的代码console.log等</li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nest.js入门</title>
    <link href="/blog/2024/08/19/nest-introduction/"/>
    <url>/blog/2024/08/19/nest-introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="nest-js入门"><a href="#nest-js入门" class="headerlink" title="nest.js入门"></a>nest.js入门</h1><h2 id="一、项目创建"><a href="#一、项目创建" class="headerlink" title="一、项目创建"></a>一、项目创建</h2><h3 id="1、创建一个新的-Nest-项目"><a href="#1、创建一个新的-Nest-项目" class="headerlink" title="1、创建一个新的 Nest 项目"></a>1、创建一个新的 Nest 项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i -g @nestjs/cli<br>nest new project-name<br></code></pre></td></tr></table></figure><p>将创建 <code>project-name</code> 目录，安装 node 模块和一些其他样板文件，将创建 <code>src/</code> 目录并填充几个核心文件。</p><p>以下是这些核心文件的简要概述：</p><table><thead><tr><th><code>app.controller.ts</code></th><th>具有单一路由的基本控制器。</th></tr></thead><tbody><tr><td><code>app.controller.spec.ts</code></td><td>控制器的单元测试。</td></tr><tr><td><code>app.module.ts</code></td><td>应用的根模块。</td></tr><tr><td><code>app.service.ts</code></td><td>具有单一方法的基本服务。</td></tr><tr><td><code>main.ts</code></td><td>使用核心函数 <code>NestFactory</code> 创建 Nest 应用实例的应用入口文件。</td></tr></tbody></table><h3 id="2、运行应用"><a href="#2、运行应用" class="headerlink" title="2、运行应用"></a>2、运行应用</h3><p>安装过程完成后，你可以在操作系统命令提示符下运行以下命令以启动应用监听入站 HTTP 请求：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm run start<br></code></pre></td></tr></table></figure><p>此命令启动应用，HTTP 服务器监听 <code>src/main.ts</code> 文件中定义的端口。应用运行后，打开浏览器并导航至 <code>http://localhost:3000/</code>。你应该会看到 <code>Hello World!</code> 消息</p><h1 id="二、文件分析"><a href="#二、文件分析" class="headerlink" title="二、文件分析"></a>二、文件分析</h1><h2 id="1-main-ts"><a href="#1-main-ts" class="headerlink" title="1. main.ts"></a>1. main.ts</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NestFactory</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AppModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.module&#x27;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AppModule</span>);<br>  <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br>&#125;<br><span class="hljs-title function_">bootstrap</span>();<br></code></pre></td></tr></table></figure><p>使用 <code>NestFactory.create()</code> 来创建一个 NestJS 应用程序的实例，并监听端口3000上的请求。</p><h2 id="2-app-module-ts"><a href="#2-app-module-ts" class="headerlink" title="2. app.module.ts"></a>2. app.module.ts</h2><p>app.module.ts是一个模块文件，以.module.ts结尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Module</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AppController</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.controller&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AppService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.service&#x27;</span>;<br><br>@<span class="hljs-title class_">Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [],<br>  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">AppController</span>],<br>  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">AppService</span>],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>模块是具有 <code>@Module()</code> 装饰器的类，Nest 用它来组织应用程序结构。对装饰器概念不熟悉的读者，可参考我的另一篇文章：<a href="https://juejin.cn/post/7402960438861070399">前端想了解后端？那得先学会 TypeScript 装饰器！</a>。</p><p>在app.module.ts中，<code>@Module()</code> 装饰器接受一个描述模块属性的对象：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>imports</td><td>导入子模块</td></tr><tr><td>controllers</td><td>导入控制器</td></tr><tr><td>providers</td><td>由 Nest 注入器实例化的提供者，并且可以至少在整个模块中共享</td></tr></tbody></table><p>module的内容不多，主要用来用于定义和配置模块的核心文件。</p><h2 id="3-app-controller-ts"><a href="#3-app-controller-ts" class="headerlink" title="3. app.controller.ts"></a>3. app.controller.ts</h2><p>app.controller.ts是一个控制器文件，以.controller.ts结尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AppService</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.service&#x27;</span>;<br><br>@<span class="hljs-title class_">Controller</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppController</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private readonly appService: AppService</span>) &#123;&#125;<br><br>  @<span class="hljs-title class_">Get</span>()<br>  <span class="hljs-title function_">getHello</span>(): string &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">appService</span>.<span class="hljs-title function_">getHello</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>@Controller()</code> 装饰器定义一个基本的控制器，控制器负责处理传入的<strong>请求</strong>和向客户端返回<strong>响应</strong>。</p><p>构造函数使用依赖注入机制注入了 AppService 实例（在module中配置的providers: [AppService],）。private readonly 表示 appService 是私有的并且不可更改。</p><p>@Get(): 此装饰器定义了一个处理HTTP GET请求的方法。默认情况下，该方法将处理根URL（即 &#x2F;）上的GET请求。因此当访问localhost:3000时，会调用getHello方法。</p><p>getHello方法调用了 AppService 的 getHello 方法。接下来继续看appService中的内容。</p><p>提示：<code>在controller中，不要编写过多的业务逻辑，复杂的逻辑应交给service处理</code></p><h2 id="4-app-service-ts"><a href="#4-app-service-ts" class="headerlink" title="4. app.service.ts"></a>4. app.service.ts</h2><p>app.service.ts是一个service文件，以.service.ts结尾。主要用于处理复杂的业务逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Injectable</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><br>@<span class="hljs-title class_">Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppService</span> &#123;<br>  <span class="hljs-title function_">getHello</span>(): string &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>@Injectable()</code> 装饰器用于标记类为可以被依赖注入系统管理的服务，即在module中被providers。</p><p>getHello方法返回字符串’Hello World!’，因此在app.controller.ts中，调用this.appService.getHello()返回的结果是’Hello World!’，访问localhost:3000接口的结果为’Hello World!’。</p><h1 id="三、创建模块"><a href="#三、创建模块" class="headerlink" title="三、创建模块"></a>三、创建模块</h1><p>通过上文，熟悉了NestJS的设计模式，主要就是 <code>Controller</code>、<code>Service</code>、<code>Module</code> 共同形成了一个模块。</p><ul><li><code>Controller</code>：传统意义上的控制器，提供 api 接口，负责处理路由、中转、验证等一些简洁的业务；</li><li><code>Service</code>：又称为 <code>Provider</code>， 是一系列服务、repo、工厂方法、helper 的总称，主要负责处理具体的业务，如数据库的增删改查、事务、并发等逻辑代码；</li><li><code>Module</code>：负责将 <code>Controller</code> 和 <code>Service</code> 连接起来，类似于 <code>namespace</code> 的概念；</li></ul><p>使用 nest-cli 提供的指令可以快速创建文件，语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">nest g [文件类型] [文件名] [文件目录]<br></code></pre></td></tr></table></figure><p>文件目录如果不提供，默认为文件名。</p><h2 id="1-创建模块"><a href="#1-创建模块" class="headerlink" title="1. 创建模块"></a>1. 创建模块</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">nest g module posts<br></code></pre></td></tr></table></figure><p>执行完命令后，我们可以发现在根模块app.module.ts中的@Model装饰器的imports中自动引入了PostsModule</p><p>命令可简写为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nest g mo posts<br></code></pre></td></tr></table></figure><h2 id="2-创建控制器"><a href="#2-创建控制器" class="headerlink" title="2. 创建控制器"></a>2. 创建控制器</h2><p>–no-spec：不生成测试文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">nest g controller posts --no-spec<br></code></pre></td></tr></table></figure><p>创建posts.controller.ts文件，并且在posts.module.ts文件下，@Module装饰器的controllers中自动注入</p><p>命令可简写为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">nest g co posts --no-spec<br></code></pre></td></tr></table></figure><h2 id="3-创建服务类"><a href="#3-创建服务类" class="headerlink" title="3. 创建服务类"></a>3. 创建服务类</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">nest g service posts --no-spec<br></code></pre></td></tr></table></figure><p>创建posts.service.ts文件，并且在posts.module.ts文件下，@Module装饰器的providers中自动注入</p><p>命令可简写为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">nest g s posts --no-spec<br></code></pre></td></tr></table></figure><p>提示：<code>注意创建顺序，先创建Module，再创建Controller和Service，这样创建出来的文件在Module中自动注册。</code></p>]]></content>
    
    
    <categories>
      
      <category>nest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nest的第一个项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滕王阁序</title>
    <link href="/blog/2024/08/16/poetry-twgx/"/>
    <url>/blog/2024/08/16/poetry-twgx/</url>
    
    <content type="html"><![CDATA[<h1 id="滕王阁序"><a href="#滕王阁序" class="headerlink" title="滕王阁序"></a>滕王阁序</h1><p>豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p><p>时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p><p>披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。</p><p>遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？</p><p>嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p><p>勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p><p>呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：</p><p>滕王高阁临江渚，佩玉鸣鸾罢歌舞。</p><p>画栋朝飞南浦云，珠帘暮卷西山雨。</p><p>闲云潭影日悠悠，物换星移几度秋。</p><p>阁中帝子今何在？槛外长江空自流。</p>]]></content>
    
    
    <categories>
      
      <category>poetry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诗歌</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>洛神赋</title>
    <link href="/blog/2024/08/16/poetry-lsf/"/>
    <url>/blog/2024/08/16/poetry-lsf/</url>
    
    <content type="html"><![CDATA[<h1 id="洛神赋"><a href="#洛神赋" class="headerlink" title="洛神赋"></a>洛神赋</h1><p>黄初三年，余朝京师，还济洛川。古人有言，斯水之神，名曰宓妃。感宋玉对楚王神女之事，遂作斯赋。其辞曰：</p><p>余从京域，言归东藩。背伊阙，越轘辕，经通谷，陵景山。日既西倾，车殆马烦。尔乃税驾乎蘅皋，秣驷乎芝田，容与乎阳林，流眄乎洛川。于是精移神骇，忽焉思散。俯则未察，仰以殊观，睹一丽人，于岩之畔。乃援御者而告之曰：“尔有觌于彼者乎？彼何人斯？若此之艳也！”御者对曰：“臣闻河洛之神，名曰宓妃。然则君王之所见也，无乃是乎？其状若何？臣愿闻之。”</p><p>余告之曰：“其形也，翩若惊鸿，婉若游龙。荣曜秋菊，华茂春松。髣髴兮若轻云之蔽月，飘飖兮若流风之回雪。远而望之，皎若太阳升朝霞；迫而察之，灼若芙蕖出渌波。秾纤得衷，修短合度。肩若削成，腰如约素。延颈秀项，皓质呈露。芳泽无加，铅华弗御。云髻峨峨，修眉联娟。丹唇外朗，皓齿内鲜，明眸善睐，靥辅承权。瑰姿艳逸，仪静体闲。柔情绰态，媚于语言。奇服旷世，骨像应图。披罗衣之璀粲兮，珥瑶碧之华琚。戴金翠之首饰，缀明珠以耀躯。践远游之文履，曳雾绡之轻裾。微幽兰之芳蔼兮，步踟蹰于山隅。</p><p>于是忽焉纵体，以遨以嬉。左倚采旄，右荫桂旗。攘皓腕于神浒兮，采湍濑之玄芝。余情悦其淑美兮，心振荡而不怡。无良媒以接欢兮，托微波而通辞。愿诚素之先达兮，解玉佩以要之。嗟佳人之信修兮，羌习礼而明诗。抗琼珶以和予兮，指潜渊而为期。执眷眷之款实兮，惧斯灵之我欺。感交甫之弃言兮，怅犹豫而狐疑。收和颜而静志兮，申礼防以自持。</p><p>于是洛灵感焉，徙倚彷徨，神光离合，乍阴乍阳。竦轻躯以鹤立，若将飞而未翔。践椒涂之郁烈，步蘅薄而流芳。超长吟以永慕兮，声哀厉而弥长。</p><p>尔乃众灵杂沓，命俦啸侣，或戏清流，或翔神渚，或采明珠，或拾翠羽。从南湘之二妃，携汉滨之游女。叹匏瓜之无匹兮，咏牵牛之独处。扬轻袿之猗靡兮，翳修袖以延伫。体迅飞凫，飘忽若神，凌波微步，罗袜生尘。动无常则，若危若安。进止难期，若往若还。转眄流精，光润玉颜。含辞未吐，气若幽兰。华容婀娜，令我忘餐。</p><p>于是屏翳收风，川后静波。冯夷鸣鼓，女娲清歌。腾文鱼以警乘，鸣玉鸾以偕逝。六龙俨其齐首，载云车之容裔，鲸鲵踊而夹毂，水禽翔而为卫。</p><p>于是越北沚。过南冈，纡素领，回清阳，动朱唇以徐言，陈交接之大纲。恨人神之道殊兮，怨盛年之莫当。抗罗袂以掩涕兮，泪流襟之浪浪。悼良会之永绝兮，哀一逝而异乡。无微情以效爱兮，献江南之明珰。虽潜处于太阴，长寄心于君王。忽不悟其所舍，怅神宵而蔽光。</p><p>于是背下陵高，足往神留，遗情想像，顾望怀愁。冀灵体之复形，御轻舟而上溯。浮长川而忘返，思绵绵而增慕。夜耿耿而不寐，沾繁霜而至曙。命仆夫而就驾，吾将归乎东路。揽騑辔以抗策，怅盘桓而不能去。</p>]]></content>
    
    
    <categories>
      
      <category>poetry</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诗歌</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript，new一个函数发生了什么及手写实现</title>
    <link href="/blog/2024/07/17/js-newFunction/"/>
    <url>/blog/2024/07/17/js-newFunction/</url>
    
    <content type="html"><![CDATA[<h1 id="new一个函数发生了什么"><a href="#new一个函数发生了什么" class="headerlink" title="new一个函数发生了什么"></a>new一个函数发生了什么</h1><p>new运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>当代码执行new Foo时，会发生以下事情：</p><ol><li>一个继承自 Foo.prototype 的新对象被创建</li><li>使用指定的参数调用构造函数 Foo,并将this绑定到新创建的对象</li><li>由构造函数返回的对象就是new表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。(一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤)</li></ol></blockquote><p>了解了new的原理，我们来自己动手实现一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 接收不定参，第一个参数是构造函数，后续参数被构造函数使用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">fn,...args</span>)&#123;<br>  <span class="hljs-comment">// 创建一个空对象</span><br>  <span class="hljs-keyword">const</span> obj = &#123;&#125;;<br>  <span class="hljs-comment">// 将该对象的 __proto__ 属性链接到构造函数原型对象</span><br>  obj.<span class="hljs-property">__proto__</span> = fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <span class="hljs-comment">// 将该对象作为 this 上下文调用构造函数并接收返回值</span><br>  <span class="hljs-keyword">const</span> res = fn.<span class="hljs-title function_">apply</span>(obj,args);<br>  <span class="hljs-comment">// 如果返回值存在并且是引用数据类型，返回构造函数返回值，否则返回创建的对象</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span>?<span class="hljs-attr">res</span>:obj<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="手写实现一个new"><a href="#手写实现一个new" class="headerlink" title="手写实现一个new"></a>手写实现一个new</h1><h3 id="1、首先，我们回顾一下new的用法："><a href="#1、首先，我们回顾一下new的用法：" class="headerlink" title="1、首先，我们回顾一下new的用法："></a>1、首先，我们回顾一下new的用法：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model, year</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> = year;<br>&#125;<br><br><span class="hljs-keyword">const</span> car1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Eagle&#x27;</span>, <span class="hljs-string">&#x27;Talon TSi&#x27;</span>, <span class="hljs-number">1993</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car1.<span class="hljs-property">make</span>);   <span class="hljs-comment">//输出: &quot;Eagle&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2、new的过程发生了什么"><a href="#2、new的过程发生了什么" class="headerlink" title="2、new的过程发生了什么"></a>2、new的过程发生了什么</h3><ol><li><strong>创建一个空对象</strong>：创建一个空的简单 JavaScript 对象。为方便起见，我们称之为 <code>newInstance</code>。</li><li><strong>指定原型链</strong>：将 <code>newInstance</code> 的 [[Prototype]] 指向构造函数的 <code>prototype</code> 属性，否则 <code>newInstance</code> 将保持为一个普通对象，其 [[Prototype]] 为 <code>Object.prototype</code>。</li><li><strong>更改this指向</strong>：使用给定参数执行构造函数，并将 <code>newInstance</code> 绑定为 this 的上下文。</li><li><strong>返回值</strong>：返回<code>newInstance</code>。</li></ol><h3 id="3、手写一个new"><a href="#3、手写一个new" class="headerlink" title="3、手写一个new"></a>3、手写一个new</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">Fun, ...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> obj = &#123;&#125;<br>    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Fun</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>    <span class="hljs-title class_">Fun</span>.<span class="hljs-title function_">apply</span>(obj, args)<br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-keyword">let</span> apple = <span class="hljs-title function_">myNew</span>(<span class="hljs-title class_">Person</span>, <span class="hljs-string">&#x27;一颗苹果&#x27;</span>,<span class="hljs-string">&#x27;18&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(apple.<span class="hljs-property">name</span>);   <span class="hljs-comment">//输出：一颗苹果</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(apple.<span class="hljs-property">age</span>);    <span class="hljs-comment">//输出：18</span><br></code></pre></td></tr></table></figure><p>这样就模拟出了一个简化版的<code>new</code>函数，其中不好理解的就是第三行的<code>obj.__proto__ = Fun.prototype</code>和第四行的<code>Fun.apply(obj, args)</code>。</p><ul><li><strong>…args</strong>：将剩下的元素都放进<code>args</code>中</li><li><strong>obj. __ proto __ &#x3D; Fun.prototype</strong>：将 <code>obj</code> 的原型链指向构造函数的 <code>prototype</code> 属性</li><li><strong>Fun.apply(obj, args)</strong>：将构造函数内部的this绑定到<code>obj</code>上，并执行构造函数</li></ul><p><em>通过这一系列操作，我们就可以拿到构造函数中的 <code>name</code>和 <code>age</code>属性了</em>。</p><h3 id="看似完成了，但其实落了很重要的一点（原型链）"><a href="#看似完成了，但其实落了很重要的一点（原型链）" class="headerlink" title="看似完成了，但其实落了很重要的一点（原型链）"></a>看似完成了，但其实落了很重要的一点（原型链）</h3><p>“你不觉得少了些什么吗？”</p><p>回想一下，我们通过new函数创建一个对象时，除了引用它的属性，我们还会做些什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>()<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br></code></pre></td></tr></table></figure><p>当然是使用它自带的方法，但是上面并没有给出方法上的引用。这就得引入原型链这个知识点了，我们只需要给Person的原型链上增加我们想要的方法就可以了，实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">Fun, ...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> obj = &#123;&#125;<br>    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Fun</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>    <span class="hljs-title class_">Fun</span>.<span class="hljs-title function_">apply</span>(obj, args)<br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">who</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是Person的实例对象&#x27;</span>);<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myname</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><span class="hljs-keyword">let</span> p = <span class="hljs-title function_">myNew</span>(<span class="hljs-title class_">Person</span>, <span class="hljs-string">&#x27;一颗苹果&#x27;</span>)<br>p.<span class="hljs-title function_">who</span>();      <span class="hljs-comment">// 输出：我是Person的实例对象</span><br>p.<span class="hljs-title function_">myname</span>();   <span class="hljs-comment">// 输出：一颗苹果</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 输出：一颗苹果</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>new function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript 策略模式</title>
    <link href="/blog/2024/07/16/js-strategy/"/>
    <url>/blog/2024/07/16/js-strategy/</url>
    
    <content type="html"><![CDATA[<h1 id="js-策略模式"><a href="#js-策略模式" class="headerlink" title="js 策略模式"></a>js 策略模式</h1><p> 策略模式是一种简单却常用的设计模式，它的应用场景非常广泛。<br> 我们先了解下策略模式的概念，再通过代码示例来更清晰的认识它。</p><p>策略模式由两部分构成：一部分是封装不同策略的策略组，另一部分是 Context。<br>通过组合和委托来让 Context 拥有执行策略的能力，从而实现可复用、可扩展和可维护，并且避免大量复制粘贴的工作。</p><h3 id="1、举例一"><a href="#1、举例一" class="headerlink" title="1、举例一"></a>1、举例一</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> strategies = &#123;<br>    <span class="hljs-string">&quot;high&quot;</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">workHours</span>) &#123;<br>        <span class="hljs-keyword">return</span> workHours * <span class="hljs-number">25</span><br>    &#125;,<br>    <span class="hljs-string">&quot;middle&quot;</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">workHours</span>) &#123;<br>        <span class="hljs-keyword">return</span> workHours * <span class="hljs-number">20</span><br>    &#125;,<br>    <span class="hljs-string">&quot;low&quot;</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">workHours</span>) &#123;<br>        <span class="hljs-keyword">return</span> workHours * <span class="hljs-number">15</span><br>    &#125;,<br>&#125;<br><br><span class="hljs-keyword">const</span> calculateSalary = <span class="hljs-keyword">function</span> (<span class="hljs-params">workerLevel, workHours</span>) &#123;<br>    <span class="hljs-keyword">return</span> strategies[workerLevel](workHours)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">calculateSalary</span>(<span class="hljs-string">&#x27;high&#x27;</span>, <span class="hljs-number">10</span>)) <span class="hljs-comment">// 250</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">calculateSalary</span>(<span class="hljs-string">&#x27;middle&#x27;</span>, <span class="hljs-number">10</span>)) <span class="hljs-comment">// 200</span><br></code></pre></td></tr></table></figure><h3 id="2、解决if判断去获取值"><a href="#2、解决if判断去获取值" class="headerlink" title="2、解决if判断去获取值"></a>2、解决if判断去获取值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> type = <span class="hljs-string">&#x27;gas&#x27;</span><br><span class="hljs-keyword">const</span> status = &#123;<br><span class="hljs-attr">co</span>: <span class="hljs-string">&#x27;一氧化碳&#x27;</span>,<br><span class="hljs-attr">watch</span>: <span class="hljs-string">&#x27;手表&#x27;</span>,<br>    <span class="hljs-attr">smartWatch</span>: <span class="hljs-string">&#x27;手环&#x27;</span>,<br>    <span class="hljs-attr">gas</span>: <span class="hljs-string">&#x27;燃气&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">if</span>(status[type])&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(status[type])<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、解决多层if-else-去判断调用方法"><a href="#3、解决多层if-else-去判断调用方法" class="headerlink" title="3、解决多层if else 去判断调用方法"></a>3、解决多层if else 去判断调用方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">upgradecommd</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;方法一&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">humanExistUpgrade</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;方法二&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">methodThree</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;方法三&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> deviceTypeStatus = &#123;<br>    <span class="hljs-attr">callhand</span>: &#123;<br>        <span class="hljs-string">&#x27;方法一&#x27;</span>: <span class="hljs-string">&#x27;upgradecommd&#x27;</span>,<br>        <span class="hljs-string">&#x27;方法二&#x27;</span>: <span class="hljs-string">&#x27;humanExistUpgrade&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">humanExist</span>: &#123;<br>        <span class="hljs-string">&#x27;方法三&#x27;</span>: <span class="hljs-string">&#x27;methodThree&#x27;</span>,<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> type = <span class="hljs-string">&#x27;方法一&#x27;</span><br><span class="hljs-keyword">const</span> value = deviceTypeStatus[type]<br><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(deviceTypeStatus)<br><span class="hljs-keyword">if</span>(keys.<span class="hljs-title function_">includes</span>(value))&#123;<br>    deviceTypeStatus[value] &amp;&amp; [statusTitle[value]]();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>策略模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript数组的reduce的高级用法</title>
    <link href="/blog/2024/07/16/js-reduceSenior/"/>
    <url>/blog/2024/07/16/js-reduceSenior/</url>
    
    <content type="html"><![CDATA[<h1 id="JS数组的reduce的高级用法"><a href="#JS数组的reduce的高级用法" class="headerlink" title="JS数组的reduce的高级用法"></a>JS数组的reduce的高级用法</h1><h3 id="1、对数字求和"><a href="#1、对数字求和" class="headerlink" title="1、对数字求和"></a>1、对数字求和</h3><p>reduce() 最直接的用例之一是对一堆数字求和。假设您有一个整数数组，并且您想要找到总和。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> sum = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc + curr, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br><span class="hljs-comment">// Output: 15</span><br></code></pre></td></tr></table></figure><p>只需一行代码，您就可以计算出数组中所有元素的总和。累加器的初始值设置为0，并且在每次迭代中，我们将当前元素添加到累加器中。</p><h3 id="2、展平数组"><a href="#2、展平数组" class="headerlink" title="2、展平数组"></a>2、展平数组</h3><p>您是否曾经发现自己有一个数组数组并想：“我希望我可以将其扁平化为一个数组”？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nestedArray = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];<br><span class="hljs-keyword">const</span> flattenedArray = nestedArray.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> acc.<span class="hljs-title function_">concat</span>(curr), []);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flattenedArray);<br><span class="hljs-comment">// Output: [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><p>我知道您也可以使用 Array.flat() 来做到这一点。然而，了解如何使用reduce 很重要，以防您想对每个项目执行额外的操作。</p><h3 id="3、对对象进行分组"><a href="#3、对对象进行分组" class="headerlink" title="3、对对象进行分组"></a>3、对对象进行分组</h3><p>假设您有一个对象数组，并且您希望根据特定属性对它们进行分组。 reduce() 是完成这项工作的完美工具。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> people = [<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;<br>];<br><br><span class="hljs-keyword">const</span> groupedByAge = people.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!acc[curr.<span class="hljs-property">age</span>]) &#123;<br>    acc[curr.<span class="hljs-property">age</span>] = [];<br>  &#125;<br>  acc[curr.<span class="hljs-property">age</span>].<span class="hljs-title function_">push</span>(curr);<br>  <span class="hljs-keyword">return</span> acc;<br>&#125;, &#123;&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(groupedByAge);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Output:</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  &#x27;25&#x27;: [&#123; name: &#x27;Alice&#x27;, age: 25 &#125;, &#123; name: &#x27;Charlie&#x27;, age: 25 &#125;],</span><br><span class="hljs-comment">  &#x27;30&#x27;: [&#123; name: &#x27;Bob&#x27;, age: 30 &#125;, &#123; name: &#x27;Dave&#x27;, age: 30 &#125;]</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="4、创建查找映射"><a href="#4、创建查找映射" class="headerlink" title="4、创建查找映射"></a>4、创建查找映射</h3><p>我个人最喜欢的是使用reduce()从数组创建查找映射。在性能和代码可读性方面，它改变了游戏规则。停止使用那些缓慢的 find() 或 filter() 调用。</p><p>做了映射之后时间复杂度为O(1)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> products = [<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Laptop&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">999</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Phone&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">699</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tablet&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">499</span> &#125;,<br>];<br><br><span class="hljs-keyword">const</span> productMap = products.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> &#123;<br>  acc[curr.<span class="hljs-property">id</span>] = curr;<br>  <span class="hljs-keyword">return</span> acc;<br>&#125;, &#123;&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(productMap);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Output:</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  &#x27;1&#x27;: &#123; id: 1, name: &#x27;Laptop&#x27;, price: 999 &#125;,</span><br><span class="hljs-comment">  &#x27;2&#x27;: &#123; id: 2, name: &#x27;Phone&#x27;, price: 699 &#125;,</span><br><span class="hljs-comment">  &#x27;3&#x27;: &#123; id: 3, name: &#x27;Tablet&#x27;, price: 499 &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// Accessing a product by ID</span><br><span class="hljs-keyword">const</span> laptop = productMap[<span class="hljs-number">1</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(laptop); <span class="hljs-comment">// </span><br><span class="hljs-title class_">Output</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Laptop&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">999</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="5、计数出现次数"><a href="#5、计数出现次数" class="headerlink" title="5、计数出现次数"></a>5、计数出现次数</h3><p>曾经需要计算数组中元素的出现次数吗？ reduce() 已经帮你解决了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>];<br><br><span class="hljs-keyword">const</span> fruitCounts = fruits.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> &#123;<br>  acc[curr] = (acc[curr] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> acc;<br>&#125;, &#123;&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruitCounts);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Output:</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  &#x27;apple&#x27;: 3,</span><br><span class="hljs-comment">  &#x27;banana&#x27;: 2,</span><br><span class="hljs-comment">  &#x27;orange&#x27;: 1</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="6、组合函数"><a href="#6、组合函数" class="headerlink" title="6、组合函数"></a>6、组合函数</h3><p>函数式编程爱好者一定会喜欢这个。 reduce() 是一个强大的函数组合工具。您可以使用它来创建逐步转换数据的函数管道。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add5</span> = (<span class="hljs-params">x</span>) =&gt; x + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply3</span> = (<span class="hljs-params">x</span>) =&gt; x * <span class="hljs-number">3</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">subtract2</span> = (<span class="hljs-params">x</span>) =&gt; x - <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> composedFunctions = [add5, multiply3, subtract2];<br><span class="hljs-keyword">const</span> result = composedFunctions.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> <span class="hljs-title function_">curr</span>(acc), <span class="hljs-number">10</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <br><span class="hljs-comment">// Output: 43</span><br></code></pre></td></tr></table></figure><h3 id="7、实现简单的类似Redux的状态管理"><a href="#7、实现简单的类似Redux的状态管理" class="headerlink" title="7、实现简单的类似Redux的状态管理"></a>7、实现简单的类似Redux的状态管理</h3><p>如果您使用过 Redux，您就会知道它在管理应用程序中的状态方面有多么强大。你猜怎么了？你可以使用reduce()来实现一个简单的类似Redux的状态管理系统。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> initialState = &#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">todos</span>: [],<br>&#125;;<br><br><span class="hljs-keyword">const</span> actions = [<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT_COUNT&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-string">&#x27;Learn Array.reduce()&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT_COUNT&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-string">&#x27;Master TypeScript&#x27;</span> &#125;,<br>];<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state, action</span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREMENT_COUNT&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD_TODO&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">todos</span>: [...state.<span class="hljs-property">todos</span>, action.<span class="hljs-property">payload</span>] &#125;;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> finalState = actions.<span class="hljs-title function_">reduce</span>(reducer, initialState);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(finalState);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Output:</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  count: 2,</span><br><span class="hljs-comment">  todos: [&#x27;Learn Array.reduce()&#x27;, &#x27;Master TypeScript&#x27;]</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="8、生成唯一值"><a href="#8、生成唯一值" class="headerlink" title="8、生成唯一值"></a>8、生成唯一值</h3><p>有时，您可能有一个包含重复值的数组，并且您需要仅提取唯一的值。 reduce() 可以帮助您轻松实现这一点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">const</span> uniqueNumbers = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!acc.<span class="hljs-title function_">includes</span>(curr)) &#123;<br>    acc.<span class="hljs-title function_">push</span>(curr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> acc;<br>&#125;, []);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueNumbers); <br><span class="hljs-comment">// Output: [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><h3 id="9、计算平均值"><a href="#9、计算平均值" class="headerlink" title="9、计算平均值"></a>9、计算平均值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> grades = [<span class="hljs-number">85</span>, <span class="hljs-number">90</span>, <span class="hljs-number">92</span>, <span class="hljs-number">88</span>, <span class="hljs-number">95</span>];<br><span class="hljs-keyword">const</span> average = grades.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr, index, array</span>) =&gt;</span> &#123;<br>  acc += curr;<br>  <span class="hljs-keyword">if</span> (index === array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> acc / array.<span class="hljs-property">length</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> acc;<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(average); <br><span class="hljs-comment">// Output: 90</span><br></code></pre></td></tr></table></figure><h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><p>虽然 Array.reduce() 非常强大且用途广泛，但了解潜在的性能缺陷非常重要，尤其是在处理大型数组或复杂操作时。一个常见的陷阱是在每次reduce()迭代中创建新的对象或数组，这可能导致过多的内存分配并影响性能。 例如，考虑以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> doubledNumbers = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> [...acc, curr * <span class="hljs-number">2</span>];<br>&#125;, []);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubledNumbers); <br><span class="hljs-comment">// Output: [2, 4, 6, 8, 10]</span><br></code></pre></td></tr></table></figure><p>在本例中，我们使用展开运算符 (…) 在每次迭代中创建一个新数组，这可能效率低下。相反，我们可以通过直接改变累加器数组来优化代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> doubledNumbers= numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, curr</span>) =&gt;</span> &#123;<br>  acc.<span class="hljs-title function_">push</span>(curr * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">return</span> acc;<br>&#125;, []);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubledNumbers); <br><span class="hljs-comment">// Output: [2, 4, 6, 8, 10]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reduce高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node打包dist代码到服务器</title>
    <link href="/blog/2024/07/03/node-automateCode/"/>
    <url>/blog/2024/07/03/node-automateCode/</url>
    
    <content type="html"><![CDATA[<h1 id="node打包dist代码到服务器"><a href="#node打包dist代码到服务器" class="headerlink" title="node打包dist代码到服务器"></a>node打包dist代码到服务器</h1><h3 id="1、node代码"><a href="#1、node代码" class="headerlink" title="1、node代码"></a>1、node代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> chalk = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;chalk&#x27;</span>)<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Client</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ssh2-sftp-client&#x27;</span>)<br><span class="hljs-keyword">const</span> sftp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>()<br><span class="hljs-keyword">const</span> envConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./env.config&#x27;</span>)<br><br><span class="hljs-keyword">const</span> defalutConfig = &#123;<br>  <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;80&#x27;</span>, <span class="hljs-comment">// 端口号</span><br>  <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-comment">// 用户名</span><br>  <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;root123&#x27;</span>, <span class="hljs-comment">// 密码</span><br>  <span class="hljs-attr">localStatic</span>: <span class="hljs-string">&#x27;./dist.tar.gz&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> config = &#123;<br>  ...defalutConfig,<br>  <span class="hljs-attr">host</span>: envConfig.<span class="hljs-property">host</span>,<br>  <span class="hljs-attr">remoteStatic</span>: envConfig.<span class="hljs-property">remoteStatic</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> error = chalk.<span class="hljs-property">bold</span>.<span class="hljs-property">red</span><br><span class="hljs-keyword">const</span> success = chalk.<span class="hljs-property">bold</span>.<span class="hljs-property">green</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">upload</span>(<span class="hljs-params">config, options</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(<span class="hljs-string">&#x27;./dist&#x27;</span>) &amp;&amp; !fs.<span class="hljs-title function_">existsSync</span>(options.<span class="hljs-property">localStatic</span>)) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 标志上传dist目录</span><br>  <span class="hljs-keyword">let</span> isDist = <span class="hljs-literal">false</span><br>  sftp<br>    .<span class="hljs-title function_">connect</span>(config)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 判断gz文件存在时 上传gz 不存在时上传dist</span><br>      <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">existsSync</span>(options.<span class="hljs-property">localStatic</span>)) &#123;<br>        <span class="hljs-keyword">return</span> sftp.<span class="hljs-title function_">put</span>(options.<span class="hljs-property">localStatic</span>, options.<span class="hljs-property">remoteStatic</span>)<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">existsSync</span>(<span class="hljs-string">&#x27;./dist&#x27;</span>)) &#123;<br>        isDist = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">return</span> sftp.<span class="hljs-title function_">uploadDir</span>(<span class="hljs-string">&#x27;./dist&#x27;</span>, options.<span class="hljs-property">remoteStatic</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">12</span>))<br>      &#125;<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      sftp.<span class="hljs-title function_">end</span>()<br>      <span class="hljs-keyword">if</span> (!isDist) &#123;<br>        <span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Client</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ssh2&#x27;</span>)<br>        <span class="hljs-keyword">const</span> conn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>()<br>        conn<br>          .<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;ready&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 远程解压</span><br>            <span class="hljs-keyword">const</span> remoteModule = options.<span class="hljs-property">remoteStatic</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;dist.tar.gz&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>            conn.<span class="hljs-title function_">exec</span>(<br>              <span class="hljs-string">`cd <span class="hljs-subst">$&#123;remoteModule&#125;</span>;tar xvf dist.tar.gz`</span>,<br>              <span class="hljs-function">(<span class="hljs-params">err, stream</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err<br>                stream<br>                  .<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;<br>                    code === <span class="hljs-number">0</span><br>                    conn.<span class="hljs-title function_">end</span>()<br>                    <span class="hljs-comment">// 解压完成 删除本地文件</span><br>                    fs.<span class="hljs-title function_">unlink</span>(options.<span class="hljs-property">localStatic</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>                      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err<br>                    &#125;)<br>                  &#125;)<br>                  .<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;&#125;)<br>              &#125;<br>            )<br>          &#125;)<br>          .<span class="hljs-title function_">connect</span>(config)<br>      &#125;<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      sftp.<span class="hljs-title function_">end</span>()<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// 上传文件</span><br><span class="hljs-title function_">upload</span>(config, &#123;<br>  <span class="hljs-attr">localStatic</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, config.<span class="hljs-property">localStatic</span>), <span class="hljs-comment">// 本地文件夹路径</span><br>  <span class="hljs-attr">remoteStatic</span>: config.<span class="hljs-property">remoteStatic</span>, <span class="hljs-comment">// 服务器文件夹路径器</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2、上传命令"><a href="#2、上传命令" class="headerlink" title="2、上传命令"></a>2、上传命令</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;vue-cli-service build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;zip&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;cd dist &amp;&amp; tar -zcvf ../dist.tar.gz css js index.html&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;upload&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node upload&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;deploy&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;npm run build &amp;&amp; &amp;&amp; npm run zip &amp;&amp; npm run upload&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS动画</title>
    <link href="/blog/2024/07/02/css-animation/"/>
    <url>/blog/2024/07/02/css-animation/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h1><h2 id="一、动画分类"><a href="#一、动画分类" class="headerlink" title="一、动画分类"></a>一、动画分类</h2><h3 id="1-渐变动画（Transition）"><a href="#1-渐变动画（Transition）" class="headerlink" title="1. 渐变动画（Transition）"></a>1. 渐变动画（Transition）</h3><ul><li><strong>定义</strong>：通过<code>transition</code>属性实现元素从一个状态到另一个状态的平滑过渡。</li><li><strong>属性</strong>：包括要过渡的属性（如<code>width</code>、<code>height</code>、<code>background-color</code>等）、过渡时间（如<code>0.5s</code>）、运动曲线（如<code>ease</code>、<code>linear</code>等）以及何时开始（可以设置延迟时间）。</li></ul><h3 id="2-变形动画（Transform）"><a href="#2-变形动画（Transform）" class="headerlink" title="2. 变形动画（Transform）"></a>2. 变形动画（Transform）</h3><ul><li><strong>定义</strong>：通过<code>transform</code>属性对元素进行旋转、缩放、倾斜、移动等2D或3D转换。</li><li>类型：<ul><li><strong>旋转</strong>（<code>rotate</code>）：包括2D旋转和3D旋转，如<code>rotate(45deg)</code>、<code>rotateX(45deg)</code>等。</li><li><strong>缩放</strong>（<code>scale</code>）：如<code>scale(2, 2)</code>表示在X轴和Y轴上都放大两倍。</li><li><strong>倾斜</strong>（<code>skew</code>）：如<code>skew(30deg, 20deg)</code>表示元素在X轴倾斜30度，Y轴倾斜20度。</li><li><strong>移动</strong>（<code>translate</code>）：如<code>translate(50px, 100px)</code>表示元素向右移动50px，向下移动100px。</li></ul></li></ul><h3 id="3-自定义动画（Animation）"><a href="#3-自定义动画（Animation）" class="headerlink" title="3. 自定义动画（Animation）"></a>3. 自定义动画（Animation）</h3><ul><li><strong>定义</strong>：通过<code>@keyframes</code>规则定义动画序列，然后使用<code>animation</code>属性将动画应用到元素上。</li><li><strong>属性</strong>：包括动画名称、动画时长、速度曲线、延迟时间、重复次数、动画方向以及执行完毕时的状态等。</li><li><strong>示例</strong>：定义一个名为<code>change</code>的动画，使元素宽度从211px变化到1111px，持续时间为2秒。</li></ul><h3 id="4-逐帧动画（Steps-Animation）"><a href="#4-逐帧动画（Steps-Animation）" class="headerlink" title="4. 逐帧动画（Steps Animation）"></a>4. 逐帧动画（Steps Animation）</h3><ul><li><strong>定义</strong>：通过<code>animation-timing-function</code>属性的<code>steps()</code>函数实现逐帧动画效果，常用于精灵图动画。</li><li><strong>特点</strong>：动画的每一帧都是离散的，类似于电影胶片中的每一帧。</li></ul><h2 id="二、自定义动画效果"><a href="#二、自定义动画效果" class="headerlink" title="二、自定义动画效果"></a>二、自定义动画效果</h2><h3 id="1-动画逐渐改变元素的样式"><a href="#1-动画逐渐改变元素的样式" class="headerlink" title="1.动画逐渐改变元素的样式"></a>1.动画逐渐改变元素的样式</h3><p>只有在指定关键帧之后才能使用。关键帧描述了动画序列中特定点上动画元素的外观。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-tag">div</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-attribute">animation-name</span>: square;<br>  <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">8s</span>;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> square&#123;<br>  <span class="hljs-selector-tag">from</span> &#123;<span class="hljs-attribute">background-color</span>: blue;&#125;<br>  <span class="hljs-selector-tag">to</span> &#123;<span class="hljs-attribute">background-color</span>: black;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-虚浮放大"><a href="#2-虚浮放大" class="headerlink" title="2. 虚浮放大"></a>2. 虚浮放大</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">  </span><br><span class="language-css">  <span class="hljs-selector-class">.zoom-on-hover</span> &#123;  </span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 示例宽度 */</span>  </span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 示例高度 */</span>  </span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: skyblue; <span class="hljs-comment">/* 示例背景色 */</span>  </span><br><span class="language-css">    <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span> ease; <span class="hljs-comment">/* 平滑过渡效果 */</span>  </span><br><span class="language-css">  &#125;  </span><br><span class="language-css">  </span><br><span class="language-css">  <span class="hljs-selector-class">.zoom-on-hover</span><span class="hljs-selector-pseudo">:hover</span> &#123;  </span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.2</span>); <span class="hljs-comment">/* 鼠标悬停时放大1.2倍 */</span>  </span><br><span class="language-css">  &#125;  </span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;zoom-on-hover&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-色相旋转动画"><a href="#3-色相旋转动画" class="headerlink" title="3. 色相旋转动画"></a>3. 色相旋转动画</h3><p>在网站的主要部分和按钮上添加色相旋转动画。</p><p>例如，天气预报网站的主要部分将因此而变得令人惊艳。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">35deg</span>, <span class="hljs-number">#8C52FF</span>, <span class="hljs-number">#C669FF</span>);<br>  <span class="hljs-attribute">animation</span>: hue-rotate <span class="hljs-number">3s</span> linear infinite alternate;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> hue-rotate &#123;<br>  <span class="hljs-selector-tag">to</span> &#123;<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">85deg</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS隐藏滚动条和文字</title>
    <link href="/blog/2024/07/02/css-scrollbar/"/>
    <url>/blog/2024/07/02/css-scrollbar/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS隐藏滚动条和文字"><a href="#CSS隐藏滚动条和文字" class="headerlink" title="CSS隐藏滚动条和文字"></a>CSS隐藏滚动条和文字</h1><h3 id="一、隐藏滚动条"><a href="#一、隐藏滚动条" class="headerlink" title="一、隐藏滚动条"></a>一、隐藏滚动条</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*element：需要隐藏的元素</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/** 谷歌 */</span><br><span class="hljs-selector-class">.element</span>::-webkit-scrollbar &#123; <br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span><br>&#125;<br><br><span class="hljs-selector-class">.element</span> &#123; <br>    -ms-<span class="hljs-attribute">overflow</span>-style: none; <span class="hljs-comment">/** IE 10+ */</span><br>    <span class="hljs-attribute">overflow</span>: -moz-scrollbars-none; <span class="hljs-comment">/** Firefox */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="二、隐藏文字"><a href="#二、隐藏文字" class="headerlink" title="二、隐藏文字"></a>二、隐藏文字</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-selector-class">.hidden</span> &#123;<br>    <span class="hljs-attribute">white-space</span>: nowrap; <span class="hljs-comment">/* 不换行 */</span><br>    <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 超出部分隐藏 */</span><br>    <span class="hljs-attribute">text-overflow</span>: ellipsis; <span class="hljs-comment">/* 添加省略号 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、设置滚动条的颜色"><a href="#三、设置滚动条的颜色" class="headerlink" title="三、设置滚动条的颜色"></a>三、设置滚动条的颜色</h3><p>1.设置谷歌浏览器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 整个滚动条区域 */</span><br>::-webkit-scrollbar &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">12px</span>;  <span class="hljs-comment">/* 垂直滚动条宽度 */</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">12px</span>; <span class="hljs-comment">/* 水平滚动条高度 */</span><br>&#125;<br> <br><span class="hljs-comment">/* 滚动条轨道 */</span><br>::-webkit-scrollbar-track &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#f1f1f1</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">6px</span>;<br>&#125;<br> <br><span class="hljs-comment">/* 滚动条滑块 */</span><br>::-webkit-scrollbar-thumb &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#888</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">6px</span>;<br>&#125;<br> <br><span class="hljs-comment">/* 滑块悬停状态 */</span><br>::-webkit-scrollbar-thumb:hover &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#555</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.通用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 通用设置 */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">scrollbar-width</span>: thin;<br>    <span class="hljs-attribute">scrollbar-color</span>: <span class="hljs-number">#888</span> <span class="hljs-number">#f1f1f1</span>;<br>&#125;<br> <br><span class="hljs-comment">/* WebKit浏览器增强设置 */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>:<span class="hljs-number">0</span>) &#123;<br>    ::-webkit-scrollbar &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">12px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">12px</span>;<br>    &#125;<br>    ::-webkit-scrollbar-track &#123;<br>        <span class="hljs-attribute">background</span>: <span class="hljs-number">#f1f1f1</span>;<br>    &#125;<br>    ::-webkit-scrollbar-thumb &#123;<br>        <span class="hljs-attribute">background</span>: <span class="hljs-number">#888</span>;<br>        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">6px</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>隐藏滚动条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS泛型</title>
    <link href="/blog/2024/01/02/ts-genericity/"/>
    <url>/blog/2024/01/02/ts-genericity/</url>
    
    <content type="html"><![CDATA[<h1 id="TS泛型"><a href="#TS泛型" class="headerlink" title="TS泛型"></a>TS泛型</h1><h3 id="一、Exclude"><a href="#一、Exclude" class="headerlink" title="一、Exclude"></a>一、Exclude</h3><p><code>Exclude&lt;T, U&gt;</code>：作用简单说就是把 <code>T</code> 里面的 <code>U</code> 去掉，再返回 <code>T</code> 里还剩下的。<code>T</code> 和 <code>U</code> 必须是同种类型(具体类型&#x2F;字面量类型)。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-comment">// type T1  = number; </span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;b&#x27;</span> | <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span> | <span class="hljs-string">&#x27;d&#x27;</span>&gt;;<br><span class="hljs-comment">// type T2  = &#x27;a&#x27; | &#x27;c&#x27;;</span><br></code></pre></td></tr></table></figure><h3 id="二、Extract"><a href="#二、Extract" class="headerlink" title="二、Extract"></a>二、Extract</h3><p><code>Extract&lt;T, U&gt;</code>：作用是取出 <code>T</code> 里面的 <code>U</code> ，返回。作用和 <code>Exclude</code> 刚好相反，传参也是一样的</p><p>看例子理解 <code>Extract</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;b&#x27;</span> | <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;d&#x27;</span>&gt;;<br><span class="hljs-comment">// type T1  = &#x27;a&#x27;;</span><br><br><span class="hljs-comment">// 源码定义</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Extract</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? T : <span class="hljs-built_in">never</span><br></code></pre></td></tr></table></figure><h3 id="三、Omit"><a href="#三、Omit" class="headerlink" title="三、Omit"></a>三、Omit</h3><p><code>Omit&lt;T, K&gt;</code>：作用是把 <code>T(对象类型)</code> 里边的 <code>K</code> 去掉，返回 <code>T</code> 里还剩下的</p><p><code>Omit</code> 的作用和 <code>Exclude</code> 是一样的，都能做类型过滤并得到新类型。</p><p>不同的是 <code>Exclude</code> 主要是处理联合类型，且会触发分发，而 <code>Omit</code> 主要是处理对象类型，所以自然的这俩参数也不一样。</p><p>用法如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 这种场景 type 和 interface 是一样的，后面就不重复说明了</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">User</span>, <span class="hljs-string">&#x27;age&#x27;</span>&gt;<br><span class="hljs-comment">// type T1 = &#123; name: string &#125;</span><br></code></pre></td></tr></table></figure><p>源码定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// keyof any 就是 string | number | symbol</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Omit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>&gt; = &#123; [P <span class="hljs-keyword">in</span> <span class="hljs-title class_">Exclude</span>&lt;keyof T, K&gt;]: T[P]; &#125;<br></code></pre></td></tr></table></figure><ul><li>首先第一个参数 <code>T</code> 要传对象类型， <code>type</code> 或 <code>interface</code> 都可以</li><li>第二个参数 <code>K</code> 限制了类型只能是 <code>string | number | symbol</code>，这一点跟 <code>js</code> 里的对象是一个意思，对象类型的属性名只支持这三种类型</li><li><code>in</code> 是映射类型，用来映射遍历枚举类型。大白话就是循环、循环语法，需要配合联合类型来对类型进行遍历。<code>in</code> 的右边是可遍历的枚举类型，左边是遍历出来的每一项</li><li>用 <code>Exclude</code> 去除掉传入的属性后，再遍历剩下的属性，生成新的类型返回</li></ul><p>示例解析：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Omit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>&gt; = &#123; [P <span class="hljs-keyword">in</span> <span class="hljs-title class_">Exclude</span>&lt;keyof T, K&gt;]: T[P]; &#125;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">User</span>, <span class="hljs-string">&#x27;age&#x27;</span>&gt;<br><span class="hljs-comment">// type T1 = &#123; name: string, gender: string &#125;</span><br></code></pre></td></tr></table></figure><p>我们调用 <code>Omit</code> 传入的参数是正确的，所以就分析一下后面的执行逻辑：</p><ul><li><code>Exclude&lt;keyof T, K&gt;</code> 等于 <code>Exclude&lt;&#39;name&#39;|&#39;age&#39;|&#39;gender&#39;, &#39;age&#39;&gt;</code>，返回的结果就是 <code>&#39;name&#39;|&#39;gender</code></li><li>然后遍历 <code>&#39;name&#39;|&#39;gender&#39;</code>，第一次循环 <code>P</code> 就是 <code>name</code>，返回 <code>T[P]</code> 就是 <code>User[&#39;name&#39;]</code></li><li>第二次循环 <code>P</code> 就是 <code>gender</code>，返回 <code>T[P]</code> 就是 <code>User[&#39;gender&#39;]</code>，然后循环结束</li><li>结果就是 <code>{ name: string, gender: string }</code></li></ul><h3 id="四、Pick"><a href="#四、Pick" class="headerlink" title="四、Pick"></a>四、Pick</h3><p><code>Pick&lt;T, K&gt;</code> ：作用是取出 <code>T(对象类型)</code> 里边儿的 <code>K</code>，返回。</p><p>好像和 <code>Omit</code> 刚好相反，<code>Omit</code> 是不要 <code>K</code> ，<code>Pick</code> 是只要 <code>K</code></p><p>传参方式和 <code>Omit</code> 是一样的，就不赘述了，用法示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-attr">gender</span>: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">User</span>, <span class="hljs-string">&#x27;name&#x27;</span> | <span class="hljs-string">&#x27;gender&#x27;</span>&gt;<br><span class="hljs-comment">// type T1 = &#123; name: string, gender: string &#125;</span><br></code></pre></td></tr></table></figure><p>源码定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Pick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123; [P <span class="hljs-keyword">in</span> K]: T[P]; &#125;<br></code></pre></td></tr></table></figure><ul><li>可以看到等号左边做了泛型约束，限制了第二个参数 <code>K</code> 必须是第一个参数 <code>T</code> 里的属性。</li><li>如果第二个参数传入联合类型，会触发分发，以此来确保准确性，联合类型中的每一个单独类型都必须是第一个对象类型中的属性(不限制的话右边就要出错了)</li><li>参数都正确之后，等号右边的逻辑其实就是和 <code>Omit</code> 一模一样的了，直接遍历 <code>K</code>，取出返回就完事儿了</li></ul><h3 id="五、Record"><a href="#五、Record" class="headerlink" title="五、Record"></a>五、Record</h3><p><code>Record&lt;K, T&gt;</code>：作用是自定义一个对象。<code>K</code> 为对象的 <code>key</code> 或 <code>key</code> 的类型，<code>T</code> 为 <code>value</code> 或 <code>value</code> 的类型。</p><p>你有没有这样用过 ↓</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-built_in">any</span> = &#123;&#125;<br></code></pre></td></tr></table></figure><p>反正我有，其实用 <code>Record</code> 定义对象，在工作中还是很好用的，而且非常灵活，不同的对象定义上也会有一点区别，如下</p><p><strong>空对象</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// never，会限制为空对象</span><br><span class="hljs-comment">// any 指的是 string | number | symbol 这几个类型都行</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">never</span>&gt;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj1</span>:<span class="hljs-variable constant_">T1</span> = &#123;&#125; <span class="hljs-comment">// ok</span><br><span class="hljs-comment">// let obj1: T1 = &#123;a:1&#125; 这样不行，只能是空对象</span><br></code></pre></td></tr></table></figure><p><strong>任意对象</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 任意对象，unknown 或 &#123;&#125; 表示对象内容不限，空对象也行</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">unknown</span>&gt;<br><span class="hljs-comment">// 或</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">any</span>, &#123;&#125;&gt;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj2</span>:<span class="hljs-variable constant_">T1</span> = &#123;&#125; <span class="hljs-comment">// ok</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj3</span>:<span class="hljs-variable constant_">T1</span> = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p><strong>自定义对象 key</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> keys = <span class="hljs-string">&#x27;name&#x27;</span> | <span class="hljs-string">&#x27;age&#x27;</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Record</span>&lt;keys, <span class="hljs-built_in">string</span>&gt;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj1</span>:<span class="hljs-variable constant_">T1</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;沐华&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;18&#x27;</span><br>    <span class="hljs-comment">// age: 18  报错，第二个参数 string 表示 value 值都只能是 string 类型</span><br>&#125;<br><br><span class="hljs-comment">// 如果需要 value 是任意类型，下面两个都行</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Record</span>&lt;keys, <span class="hljs-built_in">unknown</span>&gt;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">Record</span>&lt;keys, &#123;&#125;&gt;<br></code></pre></td></tr></table></figure><p><strong>自定义对象 value</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> keys = <span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;b&#x27;</span><br><span class="hljs-comment">// type 或 interface 都一样</span><br><span class="hljs-keyword">type</span> values&lt;T&gt; = &#123;<br>    <span class="hljs-attr">name</span>?: T,<br>    <span class="hljs-attr">age</span>?: T,<br>    <span class="hljs-attr">gender</span>?: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-comment">// 自定义 value 类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Record</span>&lt;keys, values&lt;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt;&gt;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>:<span class="hljs-variable constant_">T1</span> = &#123;<br>    <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;沐华&#x27;</span> &#125;,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;<br>&#125;<br><br><span class="hljs-comment">// 固定 value 值</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Record</span>&lt;keys, <span class="hljs-number">111</span>&gt;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj1</span>:<span class="hljs-variable constant_">T2</span> = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">111</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>源码定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Record</span>&lt;K <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>, T&gt; = &#123; [P <span class="hljs-keyword">in</span> K]: T; &#125;<br></code></pre></td></tr></table></figure><p>左边限制了第一个参数 <code>K</code> 只能是 <code>string | number | symbol</code> 类型，可以是联合类型，因为右边遍历 <code>K</code> 了，然后遍历出来的每个属性的值，直接赋值为传入的第二个参数</p><h3 id="六、Partial"><a href="#六、Partial" class="headerlink" title="六、Partial"></a>六、Partial</h3><p><code>Partial&lt;T&gt;</code>：作用生成一个将 <code>T(对象类型)</code> 里所有属性都变成可选的之后的新类型</p><p>示例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">User</span>&gt;<br><span class="hljs-comment">// 简单说 T1 和 T2 是一模一样的</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = &#123;<br>    <span class="hljs-attr">name</span>?: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>?: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure><p>源码定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = &#123; [P <span class="hljs-keyword">in</span> keyof T]?: T[P]; &#125;<br></code></pre></td></tr></table></figure><p>这下看源码定义的是不是特别简单，就是循环传进来的对象类型，给每个属性加个 <code>?</code> 变成可选属生</p><h3 id="七、Required"><a href="#七、Required" class="headerlink" title="七、Required"></a>七、Required</h3><p><code>Required&lt;T&gt;</code>：作用和 <code>Partial&lt;T&gt;</code> 刚好相反，<code>Partial</code> 是返回所有属性都是<strong>非必填</strong>的对象类型，而 <code>Required</code> 则是返回所有属性都是<strong>必填项</strong>的对象类型。参数 <code>T</code> 也是一个对象类型。</p><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>    <span class="hljs-attr">name</span>?: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>?: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Required</span>&lt;<span class="hljs-title class_">User</span>&gt;<br><span class="hljs-comment">// 简单说 T1 和 T2 是一模一样的</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure><p>源码定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Required</span>&lt;T&gt; = &#123; [P <span class="hljs-keyword">in</span> keyof T]-?: T[P]; &#125;<br></code></pre></td></tr></table></figure><p>和 <code>Partial</code> 的源码定义相比基本一样的，只是这里多了个减号 <code>-</code>，没错，就是减去的意思，<code>-?</code> 就是去掉 <code>?</code>，然后就变成必填项了，这样解释是不是很好理解</p><h3 id="八、Readonly"><a href="#八、Readonly" class="headerlink" title="八、Readonly"></a>八、Readonly</h3><p><code>Readonly&lt;T&gt;</code> ：作用是返回一个所有属性都是只读不可修改的对象类型，与 <code>Partial</code> 和 <code>Required</code> 是非常相似的。参数 <code>T</code> 也是一个对象类型。</p><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>?: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Readonly</span>&lt;<span class="hljs-title class_">User</span>&gt;<br><span class="hljs-comment">// 简单说 T1 和 T2 是一模一样的</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = &#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">age</span>?: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Readonly</span>&lt;T&gt; = &#123; <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P]; &#125;<br></code></pre></td></tr></table></figure><h3 id="九、NonNullable"><a href="#九、NonNullable" class="headerlink" title="九、NonNullable"></a>九、NonNullable</h3><p><code>NonNullable&lt;T&gt;</code>：作用是去掉 <code>T</code> 中的 <code>null</code> 和 <code>undefined</code>。<code>T</code> 为字面量&#x2F;具体类型的联合类型，如果是对象类型是没有效果的。如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>&gt;;<br><span class="hljs-comment">// type T1 = string | number</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span>[] | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>&gt;;    <br><span class="hljs-comment">// type T2 = string[]</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-literal">undefined</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-variable constant_">T3</span>&gt; <span class="hljs-comment">// 对象是不行的</span><br></code></pre></td></tr></table></figure><p>源码定义</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-comment">// 4.8版本之前的版本</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">NonNullable</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">never</span> : T;<br><span class="hljs-comment">// 4.8</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">NonNullable</span>&lt;T&gt; = T &amp; &#123;&#125;<br></code></pre></td></tr></table></figure><p><code>TS 4.8版本</code> 之前的就是用一个三元表达式来过滤 <code>null | undefined</code>。而在 <code>4.8</code> 版本直接就是 <code>T &amp; {}</code>，这是什么原理呢？其实是因为这个版本对 <code>--strictNullChecks</code> 做了增加，这主要体现还是在联合类型和交叉类型上，为什么这么说？</p><p>在 <code>js</code> 中都知道万物皆对象，原型链的最终点的正常对象就是 <code>Object</code> 了(<code>null</code> 算不正常的)，数据类型都是在原型链中继承于 <code>Object</code> 派生出来的。</p><p>在 <code>ts</code> 中也一样，由于 <code>{}</code> 是一个空对象，所以除了 <code>null</code> 和 <code>undefined</code> 之外的基础类型都可以视作继承于 <code>{}</code> 派生出来的。或者说如果一个值不是 <code>null</code> 和 <code>undefined</code> 就等于 <code>这个值 &amp; {}</code> 的结果，如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-string">&#x27;a&#x27;</span> &amp; &#123;&#125;;  <span class="hljs-comment">// &#x27;a&#x27;</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-built_in">number</span> &amp; &#123;&#125;;  <span class="hljs-comment">// number</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-built_in">object</span> &amp; &#123;&#125;;  <span class="hljs-comment">// object</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = &#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> &#125; &amp; &#123;&#125;;  <span class="hljs-comment">// &#123; a: string &#125;</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T5</span> = <span class="hljs-literal">null</span> &amp; &#123;&#125;;  <span class="hljs-comment">// never</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T6</span> = <span class="hljs-literal">undefined</span> &amp; &#123;&#125;;  <span class="hljs-comment">// never</span><br></code></pre></td></tr></table></figure><p>如果 <code>T &amp; {}</code> 中的 <code>T</code> 不是 <code>null/undefined</code> 就可以认为它肯定符合 <code>{}</code> 类型，就可以把 <code>{}</code> 从交叉类型中去掉了，如果是，则会被判为 <code>never</code>，而 <code>never</code> 是会被忽略的(上面 <code>Exclude</code> 源码定义里有提到)，所以在结果里自然就排除掉了 <code>null</code> 和 <code>undefined</code>。</p><p>还有如果 <code>T &amp; {}</code> 中的 <code>T</code> 是联合类型，是会触发分发的</p><h3 id="十、Awaited"><a href="#十、Awaited" class="headerlink" title="十、Awaited"></a>十、Awaited</h3><p><code>Awaited&lt;T&gt;</code>：作用是获取 <code>async/await</code> 函数或 <code>promise</code> 的 <code>then()</code> 方法的返回值的类型。而且自带递归效果，如果是这样嵌套的异步方法，也能拿到最终的返回值类型</p><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-comment">// Promise</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;;<br><span class="hljs-comment">// type T1 = string</span><br><br><span class="hljs-comment">// 嵌套 Promise，会递归</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;&gt;;<br><span class="hljs-comment">// type T2 = number</span><br><br><span class="hljs-comment">// 联合类型，会触发分发</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">Awaited</span>&lt;<span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt;;<br><span class="hljs-comment">// type T3 = number | boolean</span><br></code></pre></td></tr></table></figure><p>来看下源码定义，看下到底是怎么执行的，是怎么拿到结果的呢？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-comment">// 源码定义</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Awaited</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span><br>? T<br>: T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span> &amp; &#123; <span class="hljs-title function_">then</span>(<span class="hljs-attr">onfulfilled</span>: infer F): <span class="hljs-built_in">any</span> &#125;<br>? F <span class="hljs-title function_">extends</span> (<span class="hljs-attr">value</span>: infer V, ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span><br>? <span class="hljs-title class_">Awaited</span>&lt;V&gt;<br>: <span class="hljs-built_in">never</span><br>: T<br></code></pre></td></tr></table></figure><p>泛型条件有点多，就换了下行，方便看</p><ul><li><p>如果 <code>T</code> 是 <code>null</code> 或 <code>undefined</code> 就直接返回 <code>T</code></p></li><li><p>如果 <code>T</code> 是对象类型，并且里面有 <code>then</code>方法，就用 <code>infer</code>  类型推断出 <code>then</code></p><p>方法的第一个参数<code>onfulfilled</code>的类型赋值给 <code>F</code>，<code>onfulfilled</code>其实就是我们熟悉的 <code>resolve</code>。所以这里可以看出或者准确的说，<code>Awaited</code> 拿的不是 <code>then()</code> 的返回值类型，而是<code>resolve()</code> 的返回值类型</p><ul><li><p>既然 <code>F</code>是回调函数 <code>resolve</code>，就推断出该函数第一个参数类型赋值给 <code>V</code>，<code>resolve</code>的参数自然就是返回值</p></li><li><p>传入 <code>V</code> 递归调用</p></li><li><p><code>F</code> 不是函数就返回 <code>never</code></p></li></ul></li><li><p>如果 <code>T</code> 不是对象类型 或者 是对象但没有 <code>then</code> 方法，返回 <code>T</code> ，就是最后一行的 <code>T</code></p></li></ul><h3 id="十一、Parameters"><a href="#十一、Parameters" class="headerlink" title="十一、Parameters"></a>十一、Parameters</h3><p><code>Parameters&lt;T&gt;</code>：作用是获取函数所有参数的类型集合，返回的是元组。<code>T</code> 自然就是函数了</p><p>使用示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"><span class="hljs-attr">arg</span>: &#123; a: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">string</span> &#125;</span>): <span class="hljs-built_in">void</span>;<br><br><span class="hljs-comment">// 没有参数的函数</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-comment">// type T1 = []</span><br><br><span class="hljs-comment">// 一个参数的函数</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;;<br><span class="hljs-comment">// type T2 = [s: string]</span><br><br><span class="hljs-comment">// 泛型参数的函数</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">Parameters</span>&lt;&lt;T&gt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: T</span>) =&gt;</span> T&gt;;<br><span class="hljs-comment">// type T3 = [arg: unknown]</span><br><br><span class="hljs-comment">// typeof f1 结果为 (arg: &#123; a: number; b: string &#125;) =&gt; void</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-keyword">typeof</span> f1&gt;;<br><span class="hljs-comment">// type T4 = [arg: &#123;</span><br><span class="hljs-comment">//     a: number;</span><br><span class="hljs-comment">//     b: string;</span><br><span class="hljs-comment">// &#125;]</span><br><br><span class="hljs-comment">// any 和 never</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T5</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br><span class="hljs-comment">// type T5 = unknown[]</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T6</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-built_in">never</span>&gt;;<br><span class="hljs-comment">// type T6 = never</span><br><br><span class="hljs-comment">// 下面这样传参是会报错的</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T7</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T8</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-title class_">Function</span>&gt;;<br> <span class="hljs-comment">// 源码定义</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parameters</span>&lt;T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: infer P) =&gt; <span class="hljs-built_in">any</span> ? P : <span class="hljs-built_in">never</span><br></code></pre></td></tr></table></figure><p>可以看到限制了函数类型，然后 <code>...args</code> 取参数和 <code>js</code> 中的用法是一样的，<code>infer</code> 表示待推断的类型变量，打断出 <code>...args</code> 取到的类型赋值给 <code>P</code></p><h3 id="十二、ReturnType"><a href="#十二、ReturnType" class="headerlink" title="十二、ReturnType"></a>十二、ReturnType</h3><p><code>ReturnType&lt;T&gt;</code>：作用是获取函数返回值的类型。<code>T</code> 为函数</p><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>): &#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> &#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-comment">// type T1 = string</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">s</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;;<br><span class="hljs-comment">// type T2 = void</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">ReturnType</span>&lt;&lt;T&gt;<span class="hljs-function">() =&gt;</span> T&gt;;<br><span class="hljs-comment">// type T3 = unknown</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = <span class="hljs-title class_">ReturnType</span>&lt;&lt;T <span class="hljs-keyword">extends</span> U, U <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>[]&gt;<span class="hljs-function">() =&gt;</span> T&gt;;<br><span class="hljs-comment">// type T4 = number[]</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T5</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> f1&gt;;<br><span class="hljs-comment">// type T5 = &#123;</span><br><span class="hljs-comment">//     a: number;</span><br><span class="hljs-comment">//     b: string;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// any 和 never</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T6</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br><span class="hljs-comment">// type T6 = any</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T7</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">never</span>&gt;;<br><span class="hljs-comment">// type T7 = never</span><br><br><span class="hljs-comment">// 下面这样是不行的</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T8</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T9</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-title class_">Function</span>&gt;;<br> <span class="hljs-comment">// 源码定义</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>) =&gt; infer R ? R : <span class="hljs-built_in">any</span><br></code></pre></td></tr></table></figure><p>可以看到源码定义上和 <code>Parameters</code> 是基本一样的，只是把类型推断的参数换成返回值了</p><h3 id="十三、ConstructorParameters-InstanceType"><a href="#十三、ConstructorParameters-InstanceType" class="headerlink" title="十三、ConstructorParameters&#x2F;InstanceType"></a>十三、ConstructorParameters&#x2F;InstanceType</h3><p>我们知道 <code>Parameters</code> 和 <code>ReturnType</code> 这一对是获取普通&#x2F;箭头函数的<strong>参数类型集合</strong>以及<strong>返回值类型</strong>的了，还有一对组合<code>ConstructorParameters</code> 和 <code>InstanceType</code> 是获取<strong>构造函数</strong>的参数类型集合以及<strong>返回值类型</strong>的。</p><h3 id="十四、Uppercase-Lowercase"><a href="#十四、Uppercase-Lowercase" class="headerlink" title="十四、Uppercase&#x2F;Lowercase"></a>十四、Uppercase&#x2F;Lowercase</h3><p>Uppercase的作用是转换全部字母大写，Lowercase的作用是转换全部字母小写。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Uppercase</span>&lt;<span class="hljs-string">&quot;abcd&quot;</span>&gt;<br><span class="hljs-comment">// type T1 = &quot;ABCD&quot;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Lowercase</span>&lt;<span class="hljs-string">&quot;ABCD&quot;</span>&gt;<br><span class="hljs-comment">// type T2 = &quot;abcd&quot;</span><br></code></pre></td></tr></table></figure><h3 id="十五、Capitalize-Uncapitalize"><a href="#十五、Capitalize-Uncapitalize" class="headerlink" title="十五、Capitalize&#x2F;Uncapitalize"></a>十五、Capitalize&#x2F;Uncapitalize</h3><p>Capitalize的作用是转换首字母大小写，Uncapitalize的作用是转换非首字母大小写。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Capitalize</span>&lt;<span class="hljs-string">&quot;abcd efg&quot;</span>&gt;<br><span class="hljs-comment">// type T1 = &quot;Abcd efg&quot;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Uncapitalize</span>&lt;<span class="hljs-string">&quot;ABCD EFG&quot;</span>&gt;<br><span class="hljs-comment">// type T2 = &quot;aBCD EFG&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS新特性（ES10、ES11、ES12）</title>
    <link href="/blog/2023/12/15/js-es-new/"/>
    <url>/blog/2023/12/15/js-es-new/</url>
    
    <content type="html"><![CDATA[<h1 id="ES10"><a href="#ES10" class="headerlink" title="ES10"></a>ES10</h1><p>ES2019（ES10）新增了如下新特性👇：</p><ul><li><code>Array.prototype.{flat, flatMap}</code>扁平化嵌套数组</li><li><code>Object.fromEntries</code></li><li><code>String.prototype.{trimStart, trimEnd}</code></li><li><code>Symbol.prototype.description</code></li><li><code>Optional catch binding</code></li><li>Array.prototype.sort() is now required to be stable</li></ul><h2 id="一、Array-prototype-flat-flatMap-扁平化嵌套数组"><a href="#一、Array-prototype-flat-flatMap-扁平化嵌套数组" class="headerlink" title="一、Array.prototype.{flat, flatMap} 扁平化嵌套数组"></a>一、<code>Array.prototype.{flat, flatMap}</code> 扁平化嵌套数组</h2><h3 id="1-1-Array-prototype-flat"><a href="#1-1-Array-prototype-flat" class="headerlink" title="1.1 Array.prototype.flat"></a>1.1 Array.prototype.flat</h3><p><code>flat()</code>方法会按照一个可指定的深度遍历递归<strong>数组</strong>，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p><p><strong>返回值</strong>：一个新数组，不会改变旧数组。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">flat</span>([depth]);<br></code></pre></td></tr></table></figure><ul><li><code>depth</code> 是数组遍历的深度，默认是1。</li></ul><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [[[[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]]]];<br>arr.<span class="hljs-title function_">flat</span>();          <span class="hljs-comment">// [1, 2, [[[3, 4]]]]</span><br>arr.<span class="hljs-title function_">flat</span>(<span class="hljs-number">3</span>);         <span class="hljs-comment">// [1, 2, [3, 4]]</span><br>arr.<span class="hljs-title function_">flat</span>(-<span class="hljs-number">1</span>);        <span class="hljs-comment">// [1, 2, [[[[3, 4]]]]]</span><br>arr.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>);  <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><code>flat()</code>会移除数组中的空项</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, , , <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">flat</span>();           <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><h4 id="手撕-flat"><a href="#手撕-flat" class="headerlink" title="手撕 flat"></a>手撕 flat</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">customFlat</span>(<span class="hljs-params">arr, depth = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr) || depth &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) &#123;<br>         <span class="hljs-keyword">return</span> pre.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">customFlat</span>(cur, depth - <span class="hljs-number">1</span>));<br>      &#125;<br>      <span class="hljs-keyword">return</span> pre.<span class="hljs-title function_">concat</span>(cur);<br>  &#125;, []);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><ul><li><code>reduce</code>与<code>concat</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br>arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">arr, val</span>) =&gt;</span> arr.<span class="hljs-title function_">concat</span>(val), []);<br></code></pre></td></tr></table></figure><ul><li><code>...</code> 扩展运算符与<code>concat</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br>[].<span class="hljs-title function_">concat</span>(...arr);<br></code></pre></td></tr></table></figure><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">更多替换方式请查看MDN</a></p><h3 id="1-2-Array-prototype-flatMap"><a href="#1-2-Array-prototype-flatMap" class="headerlink" title="1.2 Array.prototype.flatMap"></a>1.2 Array.prototype.flatMap</h3><p><code>flatMap()</code>方法首先使用映射函数映射数组（<strong>深度值为1</strong>）的每个元素，然后将结果压缩成一个新数组。</p><p><strong>返回值</strong>：一个新数组，并且每个元素都是回调函数的结果。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">flatMap</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">currentVal[, index[, array]]</span>) &#123;<br><br>&#125;[, thisArg])<br></code></pre></td></tr></table></figure><ul><li>callback: 可以生成一个新数组所调用的函数<ul><li>currentVal: 当前数组在处理的元素</li><li>index: 可选，正在处理的元素索引</li><li>array: 可选，被调用的数组</li></ul></li><li>thisArg: 执行callback函数时使用的this值</li></ul><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;My name&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;Lisa&#x27;</span>];<br><span class="hljs-keyword">let</span> newArr1 = arr.<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">cur</span> =&gt;</span> cur.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>));<br><span class="hljs-keyword">let</span> newArr2 = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">cur</span> =&gt;</span> cur.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr1); <span class="hljs-comment">// [&quot;My&quot;, &quot;name&quot;, &quot;is&quot;, &quot;&quot;, &quot;Lisa&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr2); <span class="hljs-comment">// [[&quot;My&quot;, &quot;name&quot;], [&quot;is&quot;], [&quot;&quot;], [&quot;Lisa&quot;]]</span><br></code></pre></td></tr></table></figure><h2 id="二、Object-fromEntries"><a href="#二、Object-fromEntries" class="headerlink" title="二、Object.fromEntries"></a>二、<code>Object.fromEntries</code></h2><p><code>fromEntries()</code> 方法会把键值对列表转换成一个对象</p><p><strong>返回值</strong>：一个新的对象</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(iterable)<br></code></pre></td></tr></table></figure><ul><li>iterable: Array、Map等可迭代对象</li></ul><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>]]);<br><span class="hljs-keyword">let</span> mapToObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(map);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mapToObj);  <span class="hljs-comment">// &#123;a: 1, b: 2&#125;</span><br><br><span class="hljs-keyword">let</span> arr = [[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>]];<br><span class="hljs-keyword">let</span> arrToObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrToObj);   <span class="hljs-comment">// &#123;a: 1, b: 2&#125;</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">let</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj).<span class="hljs-title function_">map</span>(<br>    <span class="hljs-function">(<span class="hljs-params">[key, val]</span>) =&gt;</span> [key, val * <span class="hljs-number">2</span>]<br>  )<br>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj);   <span class="hljs-comment">// &#123;a: 2, b: 4&#125;</span><br></code></pre></td></tr></table></figure><h2 id="三、String-prototype-trimStart-trimEnd"><a href="#三、String-prototype-trimStart-trimEnd" class="headerlink" title="三、String.prototype.{trimStart, trimEnd}"></a>三、<code>String.prototype.{trimStart, trimEnd}</code></h2><h3 id="3-1-String-prototype-trimStart"><a href="#3-1-String-prototype-trimStart" class="headerlink" title="3.1 String.prototype.trimStart"></a>3.1 <code>String.prototype.trimStart</code></h3><p><code>trimStart()</code> 方法用来删除字符串的开头的空白字符。</p><p><code>trimLeft()</code> 是它的别名。</p><p><strong>返回值</strong>：一个新的字符串，这个字符串左边的空格已经被去除掉了。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">str.<span class="hljs-title function_">trimStart</span>();<br>str.<span class="hljs-title function_">trimLeft</span>();<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;    a b cd  &#x27;</span>;<br>str.<span class="hljs-title function_">trimStart</span>();   <span class="hljs-comment">// &#x27;a b cd  &#x27;</span><br>str.<span class="hljs-title function_">trimLeft</span>();    <span class="hljs-comment">// &#x27;a b cd  &#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-2-String-prototype-trimEnd"><a href="#3-2-String-prototype-trimEnd" class="headerlink" title="3.2 String.prototype.trimEnd"></a>3.2 <code>String.prototype.trimEnd</code></h3><p><code>trimEnd()</code> 方法用来删除字符串末尾的空白字符。</p><p><code>trimRight()</code> 是它的别名</p><p><strong>返回值</strong>：一个新的字符串，这个字符串右边的空格已经被去除了</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">str.<span class="hljs-title function_">trimEnd</span>()<br>str.<span class="hljs-title function_">trimRight</span>()<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;    a b cd  &#x27;</span>;<br>str.<span class="hljs-title function_">trimEnd</span>();                           <span class="hljs-comment">// &#x27;    a b cd&#x27;</span><br>str.<span class="hljs-title function_">trimRight</span>();                         <span class="hljs-comment">// &#x27;    a b cd&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="四、Symbol-prototype-description"><a href="#四、Symbol-prototype-description" class="headerlink" title="四、Symbol.prototype.description"></a>四、<code>Symbol.prototype.description</code></h2><p><code>description</code> 是一个只读属性</p><p><strong>返回值</strong>：它返回Symbol对象的可选描述的字符串</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;myDescription&#x27;</span>).<span class="hljs-property">description</span>;<br><span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>.<span class="hljs-property">description</span>;<br><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>).<span class="hljs-property">description</span>;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>).<span class="hljs-property">description</span>;      <span class="hljs-comment">// &#x27;foo&#x27;</span><br><span class="hljs-title class_">Symbol</span>().<span class="hljs-property">description</span>;           <span class="hljs-comment">// undefined</span><br><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>).<span class="hljs-property">description</span>;  <span class="hljs-comment">// &#x27;foo&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="五、Optional-catch-binding"><a href="#五、Optional-catch-binding" class="headerlink" title="五、Optional catch binding"></a>五、<code>Optional catch binding</code></h2><p>可选的捕获绑定，允许省略catch绑定和它后面的圆括号</p><p>以前的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;<br><br>&#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;err&#x27;</span>, err);<br>&#125;<br></code></pre></td></tr></table></figure><p>ES10 的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;<br><br>&#125; <span class="hljs-keyword">catch</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、JSON-stringify-的增强力"><a href="#六、JSON-stringify-的增强力" class="headerlink" title="六、JSON.stringify() 的增强力"></a>六、<code>JSON.stringify()</code> 的增强力</h2><p><code>JSON.stringify()</code> 在 ES10 修复了对于一些超出范围的 Unicode 展示错误的问题，所以遇到 0xD800-0xDFF 之内的字符会因为无法编码成 UTF-8 进而导致显示错误。在 ES10 它会用转义字符的方式来处理这部分字符而非编码的方式，这样就会正常显示了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;😊&#x27;</span>); <span class="hljs-comment">// &#x27;&quot;😊&quot;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="七、修订-Function-prototype-toString"><a href="#七、修订-Function-prototype-toString" class="headerlink" title="七、修订 Function.prototype.toString()"></a>七、修订 <code>Function.prototype.toString()</code></h2><p>以前的 toString 方法来自 <code>Object.prototype.toString()</code>，现在 的 <code>Function.prototype.toString()</code> 方法返回一个表示当前函数源代码的字符串。以前只会返回这个函数，不会包含空格、注释等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// es10新特性</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;imooc&#x27;</span>)<br>  &#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-title function_">toString</span>());<br><span class="hljs-comment">// function foo() &#123;</span><br><span class="hljs-comment">//     // es10新特性</span><br><span class="hljs-comment">//     console.log(&#x27;imooc&#x27;)</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h1 id="ES11"><a href="#ES11" class="headerlink" title="ES11"></a>ES11</h1><p>ES2020(ES11)新增了如下新特性👇：</p><ul><li>空值合并运算符（Nullish coalescing Operator）</li><li>可选链 Optional chaining</li><li>globalThis</li><li>BigInt</li><li><code>String.prototype.matchAll()</code></li><li><code>Promise.allSettled()</code></li><li>Dynamic import（按需 import）</li></ul><h2 id="一、空值合并运算符（Nullish-coalescing-Operator）"><a href="#一、空值合并运算符（Nullish-coalescing-Operator）" class="headerlink" title="一、空值合并运算符（Nullish coalescing Operator）"></a>一、空值合并运算符（Nullish coalescing Operator）</h2><h3 id="1-1-空值合并操作符（-）"><a href="#1-1-空值合并操作符（-）" class="headerlink" title="1.1 空值合并操作符（??）"></a>1.1 空值合并操作符（<code>??</code>）</h3><p><strong>空值合并操作符</strong>（<code>??</code>）是一个逻辑操作符，当左边的操作数为 <code>null</code> 或 <code>undefined</code> 的时候，返回其右侧操作符，否则返回左侧操作符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">undefined</span> ?? <span class="hljs-string">&#x27;foo&#x27;</span>  <span class="hljs-comment">// &#x27;foo&#x27;</span><br><span class="hljs-literal">null</span> ?? <span class="hljs-string">&#x27;foo&#x27;</span>  <span class="hljs-comment">// &#x27;foo&#x27;</span><br><span class="hljs-string">&#x27;foo&#x27;</span> ?? <span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-comment">// &#x27;foo&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-逻辑或操作符（-）"><a href="#1-2-逻辑或操作符（-）" class="headerlink" title="1.2 逻辑或操作符（||）"></a>1.2 逻辑或操作符（<code>||</code>）</h3><p><strong>逻辑或操作符</strong>（<code>||</code>），会在左侧操作数为假值时返回右侧操作数，也就是说如果使用 <code>||</code> 来为某些变量设置默认值，可能会出现意料之外的情况。比如 0、’’、NaN、false：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0</span> || <span class="hljs-number">1</span>  <span class="hljs-comment">// 1</span><br><span class="hljs-number">0</span> ?? <span class="hljs-number">1</span>  <span class="hljs-comment">// 0</span><br><br><span class="hljs-string">&#x27;&#x27;</span> || <span class="hljs-string">&#x27;bar&#x27;</span>  <span class="hljs-comment">// &#x27;bar&#x27;</span><br><span class="hljs-string">&#x27;&#x27;</span> ?? <span class="hljs-string">&#x27;bar&#x27;</span>  <span class="hljs-comment">// &#x27;&#x27;</span><br><br><span class="hljs-title class_">NaN</span> || <span class="hljs-number">1</span>  <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">NaN</span> ?? <span class="hljs-number">1</span>  <span class="hljs-comment">// NaN</span><br><br><span class="hljs-literal">false</span> || <span class="hljs-string">&#x27;bar&#x27;</span>  <span class="hljs-comment">// &#x27;bar&#x27;</span><br><span class="hljs-literal">false</span> ?? <span class="hljs-string">&#x27;bar&#x27;</span>  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="1-3-注意"><a href="#1-3-注意" class="headerlink" title="1.3 注意"></a>1.3 注意</h3><p>不可以将 <code>??</code> 与 AND（<code>&amp;&amp;</code>）OR（<code>||</code>）一起使用，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">null</span> || <span class="hljs-literal">undefined</span> ?? <span class="hljs-string">&quot;foo&quot;</span>; <span class="hljs-comment">// 抛出 SyntaxError</span><br><span class="hljs-literal">true</span> || <span class="hljs-literal">undefined</span> ?? <span class="hljs-string">&quot;foo&quot;</span>; <span class="hljs-comment">// 抛出 SyntaxError</span><br></code></pre></td></tr></table></figure><h2 id="二、可选链-Optional-chaining"><a href="#二、可选链-Optional-chaining" class="headerlink" title="二、可选链 Optional chaining"></a>二、可选链 Optional chaining</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>可选链操作符</strong>（<code>?.</code>）允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用都是否有效。<code>?.</code> 操作符的功能类似于<code>.</code>链式操作符，不同之处在于，在引用为 <code>null</code> 或 <code>undefined</code> 时不会报错，该链路表达式返回值为 <code>undefined</code>。</p><p>以前的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> street = user &amp;&amp; user.<span class="hljs-property">address</span> &amp;&amp; user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span>;<br><span class="hljs-keyword">const</span> num = user &amp;&amp; user.<span class="hljs-property">address</span> &amp;&amp; user.<span class="hljs-property">address</span>.<span class="hljs-property">getNum</span> &amp;&amp; user.<span class="hljs-property">address</span>.<span class="hljs-title function_">getNum</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(street, num);<br></code></pre></td></tr></table></figure><p>ES11 的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> street2 = user?.<span class="hljs-property">address</span>?.<span class="hljs-property">street</span>;<br><span class="hljs-keyword">const</span> num2 = user?.<span class="hljs-property">address</span>?.<span class="hljs-property">getNum</span>?.();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(street2, num2);<br></code></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>可选链不能用于赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> object = &#123;&#125;;<br>object?.<span class="hljs-property">property</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span><br></code></pre></td></tr></table></figure><h2 id="三、globalThis"><a href="#三、globalThis" class="headerlink" title="三、globalThis"></a>三、globalThis</h2><p>以前，在 Web 中，可以通过 <code>window</code>、<code>self</code> 取到全局对象，在 node.js 中，必须使用 <code>global</code>。</p><p>在松散模式下，可以在函数中返回 <code>this</code> 来获取全局对象，但是在严格模式和模块环境下，<code>this</code> 会返回 <code>undefined</code>。</p><p>以前要获取全局对象，可以定义一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getGlobal</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> self !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> self<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">global</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">global</span><br>  &#125;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;无法找到全局对象&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> globals = <span class="hljs-title function_">getGlobal</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globals)<br></code></pre></td></tr></table></figure><p>现在 <code>globalThis</code> 提供了一个标准的方式来获取不同环境下的全局对象自身值。</p><h2 id="四、BigInt"><a href="#四、BigInt" class="headerlink" title="四、BigInt"></a>四、BigInt</h2><p>BigInt 是一种内置对象，用来创建比 2^53 - 1（Number 可创建的最大数字） 更大的整数。可以用来表示任意大的<strong>整数</strong></p><h3 id="如何定义一个-BigInt"><a href="#如何定义一个-BigInt" class="headerlink" title="如何定义一个 BigInt"></a>如何定义一个 BigInt</h3><ul><li>在一个整数字面量后面加 n，例如 <code>10n</code></li><li>调用函数 <code>BigInt()</code> 并传递一个整数值或字符串值，例如 <code>BigInt(10)</code></li></ul><h3 id="BigInt-的特点"><a href="#BigInt-的特点" class="headerlink" title="BigInt 的特点"></a>BigInt 的特点</h3><ul><li><p>BigInt 不能用于 Math 对象中的方法；</p></li><li><p>BigInt 不能与任何 Number 实例混合运算，两者必须转换成同一种类型。但是需要注意，BigInt 在转换成 Number 时可能会丢失精度。</p></li><li><p>当使用 BigInt 时，带小数的运算会被向下取整</p></li><li><p>BigInt 和 Number 不是严格相等，但是宽松相等</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0n</span> === <span class="hljs-number">0</span> <span class="hljs-comment">// false</span><br><span class="hljs-number">0n</span> == <span class="hljs-number">0</span>  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li>BigInt 和 Number 可以比较</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">2n</span> &gt; <span class="hljs-number">2</span>   <span class="hljs-comment">// false</span><br><span class="hljs-number">2n</span> &gt; <span class="hljs-number">1</span>   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li>BigInt 和 Number 可以混在一个数组中排序</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mixed = [<span class="hljs-number">4n</span>, <span class="hljs-number">6</span>, -<span class="hljs-number">12n</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0n</span>];<br>mixed.<span class="hljs-title function_">sort</span>();  <span class="hljs-comment">// [-12n, 0, 0n, 10, 4n, 4, 6] </span><br></code></pre></td></tr></table></figure><ul><li>被 Object 包装的 BigInt 使用 object 的比较规则进行比较，只用同一个对象比较时才相等</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0n</span> === <span class="hljs-title class_">Object</span>(<span class="hljs-number">0n</span>); <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Object</span>(<span class="hljs-number">0n</span>) === <span class="hljs-title class_">Object</span>(<span class="hljs-number">0n</span>); <span class="hljs-comment">// false</span><br><span class="hljs-keyword">const</span> o = <span class="hljs-title class_">Object</span>(<span class="hljs-number">0n</span>);<br>o === o <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="BigInt-的方法"><a href="#BigInt-的方法" class="headerlink" title="BigInt 的方法"></a>BigInt 的方法</h3><h4 id="BigInt-asIntN"><a href="#BigInt-asIntN" class="headerlink" title="BigInt.asIntN()"></a>BigInt.asIntN()</h4><p>将 BigInt 值转换为一个 -2^(width-1) 与 2^(width-1) - 1 之间的有符号整数。</p><h4 id="BigInt-asUintN"><a href="#BigInt-asUintN" class="headerlink" title="BigInt.asUintN()"></a>BigInt.asUintN()</h4><p>将一个 BigInt 值转换为 0 与 2^(width) - 1 之间的无符号整数。</p><h4 id="BigInt-prototype-toLocaleString"><a href="#BigInt-prototype-toLocaleString" class="headerlink" title="BigInt.prototype.toLocaleString()"></a>BigInt.prototype.toLocaleString()</h4><p>返回此数字的 language-sensitive 形式的字符串。覆盖 <code>Object.prototype.toLocaleString()</code> 方法。</p><h4 id="BigInt-prototype-toString"><a href="#BigInt-prototype-toString" class="headerlink" title="BigInt.prototype.toString()"></a>BigInt.prototype.toString()</h4><p>返回以指定基数 (base) 表示指定数字的字符串。覆盖 <code>Object.prototype.toString()</code> 方法。</p><h4 id="BigInt-prototype-valueOf"><a href="#BigInt-prototype-valueOf" class="headerlink" title="BigInt.prototype.valueOf()"></a>BigInt.prototype.valueOf()</h4><p>返回指定对象的基元值。覆盖 <code>Object.prototype.valueOf()</code> 方法。</p><h3 id="为什么会有-Bigint-的提案？"><a href="#为什么会有-Bigint-的提案？" class="headerlink" title="为什么会有 Bigint 的提案？"></a>为什么会有 Bigint 的提案？</h3><p>JavaScript 中 <code>Number.MAX_SAFE_INTEGER</code>表示最大安全数字，计算结果是 9007199254740991，即在这个数字范围内不会出现精度丢失（小数除外）。但是一旦超过这个范围，js 就会出现计算不准确的情况，这在大数计算的时候就不得不依靠一些第三方库进行解决，因此官方提出了 BigInt 来解决此问题。</p><h2 id="五、String-prototype-matchAll"><a href="#五、String-prototype-matchAll" class="headerlink" title="五、String.prototype.matchAll()"></a>五、<code>String.prototype.matchAll()</code></h2><p>返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/t(e)(st(\d?))/g</span>;<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;test1test2&#x27;</span>;<br><br><span class="hljs-keyword">const</span> array = [...str.<span class="hljs-title function_">matchAll</span>(regexp)];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[<span class="hljs-number">1</span>]); <span class="hljs-comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;]</span><br></code></pre></td></tr></table></figure><h2 id="六、Promise-allSettled"><a href="#六、Promise-allSettled" class="headerlink" title="六、Promise.allSettled()"></a>六、<code>Promise.allSettled()</code></h2><p>类方法，返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">33</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">66</span>), <span class="hljs-number">0</span>)),<br>    <span class="hljs-number">99</span>,<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;an error&quot;</span>)),<br>  ]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values)); <br><br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//   &#123; status: &#x27;fulfilled&#x27;, value: 33 &#125;,</span><br><span class="hljs-comment">//   &#123; status: &#x27;fulfilled&#x27;, value: 66 &#125;,</span><br><span class="hljs-comment">//   &#123; status: &#x27;fulfilled&#x27;, value: 99 &#125;,</span><br><span class="hljs-comment">//   &#123; status: &#x27;rejected&#x27;, reason: Error: an error &#125;</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><h2 id="七、Dynamic-import（按需-import）"><a href="#七、Dynamic-import（按需-import）" class="headerlink" title="七、Dynamic import（按需 import）"></a>七、Dynamic import（按需 import）</h2><p><code>import</code> 可以在需要的时候，再加载某个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./dialogBox.js&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">dialogBox</span> =&gt;</span> &#123;<br>    dialogBox.<span class="hljs-title function_">open</span>();<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">/* Error handling */</span><br>  &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="ES12"><a href="#ES12" class="headerlink" title="ES12"></a>ES12</h1><p>ES 2021（ES12）新增了如下新特性👇：</p><ul><li>逻辑运算符和赋值表达式（&amp;&amp;&#x3D;，||&#x3D;，??&#x3D;）</li><li><code>String.prototype.replaceAll()</code></li><li>数字分隔符</li><li><code>Promise.any</code></li></ul><h2 id="一、逻辑运算符和赋值表达式（-，-，-）"><a href="#一、逻辑运算符和赋值表达式（-，-，-）" class="headerlink" title="一、逻辑运算符和赋值表达式（&amp;&amp;&#x3D;，||&#x3D;，??&#x3D;）"></a>一、逻辑运算符和赋值表达式（&amp;&amp;&#x3D;，||&#x3D;，??&#x3D;）</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1 &amp;&amp;&#x3D;"></a>1.1 &amp;&amp;&#x3D;</h3><p>逻辑与赋值运算符 <code>x &amp;&amp;= y</code> 等价于 <code>x &amp;&amp; (x=y)</code>：意思是当 x 为真时，x &#x3D; y。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">0</span>;<br><br>a &amp;&amp;= <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span><br><br>b &amp;&amp;= <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);  <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2 ||&#x3D;"></a>1.2 ||&#x3D;</h3><p>逻辑或赋值运算符 <code>x ||= y</code> 等价于 <code>x || (x = y)</code>：意思是仅在 x 为 false 的时候，x &#x3D; y。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = &#123; <span class="hljs-attr">duration</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;;<br><br>a.<span class="hljs-property">duration</span> ||= <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">duration</span>);  <span class="hljs-comment">// 50</span><br><br>a.<span class="hljs-property">title</span> ||= <span class="hljs-string">&#x27;title is empty.&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">title</span>);  <span class="hljs-comment">// &quot;title is empty&quot;</span><br></code></pre></td></tr></table></figure><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3 ??&#x3D;"></a>1.3 ??&#x3D;</h3><p>逻辑空赋值运算符 <code>x ??= y</code> 等价于 <code>x ?? (x = y)</code>：意思是仅在 x 为 null 或 undefined 的时候，x &#x3D; y。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = &#123; <span class="hljs-attr">duration</span>: <span class="hljs-number">50</span> &#125;;<br><br>a.<span class="hljs-property">duration</span> ??= <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">duration</span>);  <span class="hljs-comment">// 50</span><br><br>a.<span class="hljs-property">speed</span> ??= <span class="hljs-number">25</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">speed</span>);  <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><h2 id="二、String-prototype-replaceAll"><a href="#二、String-prototype-replaceAll" class="headerlink" title="二、String.prototype.replaceAll()"></a>二、<code>String.prototype.replaceAll()</code></h2><p>返回一个新字符串，字符串中所有满足 pattern 的部分都会被 replacement 替换掉。原字符串保持不变。</p><ul><li>pattern 可以是一个字符串或 RegExp；</li><li>replacement 可以是一个字符串或一个在每次被匹配被调用的函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">js<br> <span class="hljs-string">&#x27;aabbcc&#x27;</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>);  <span class="hljs-comment">// &#x27;aa..cc&#x27;</span><br></code></pre></td></tr></table></figure><p>使用正则表达式搜索值时，必须是全局的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-string">&#x27;aabbcc&#x27;</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/b/</span>, <span class="hljs-string">&#x27;.&#x27;</span>);  <span class="hljs-comment">// TypeError: replaceAll must be called with a global RegExp</span><br><br><span class="hljs-string">&#x27;aabbcc&#x27;</span>.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/b/g</span>, <span class="hljs-string">&#x27;.&#x27;</span>);  <span class="hljs-comment">// &quot;aa..cc&quot;</span><br></code></pre></td></tr></table></figure><h2 id="三、数字分隔符"><a href="#三、数字分隔符" class="headerlink" title="三、数字分隔符"></a>三、数字分隔符</h2><p>ES12 允许 JavaScript 的数值使用下划线（_）作为分隔符，但是没有规定间隔的位数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">123_00</span><br></code></pre></td></tr></table></figure><p>小数和科学记数法也可以使用分隔符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0.1_23</span><br><span class="hljs-number">1e10_00</span><br></code></pre></td></tr></table></figure><p>⚠️ 注意：</p><ul><li>不能放在数值的最前面和最后面；</li><li>不能将两个及两个以上的分隔符连在一起；</li><li>小数点的前后不能有分隔符；</li><li>科学记数法里，e 或 E 前后不能有分隔符。</li></ul><h2 id="四、Promise-any"><a href="#四、Promise-any" class="headerlink" title="四、Promise.any"></a>四、<code>Promise.any</code></h2><p>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p><p>只要参数实例有一个变成 fulfilled 状态，包装实例就会变成 fulfilled 状态；如果所有参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">promise1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;promise1&quot;</span>);<br>      <span class="hljs-comment">//  reject(&quot;error promise1 &quot;);</span><br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;);<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">promise2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;promise2&quot;</span>);<br>      <span class="hljs-comment">// reject(&quot;error promise2 &quot;);</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">promise3</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;promise3&quot;</span>);<br>      <span class="hljs-comment">// reject(&quot;error promise3 &quot;);</span><br>    &#125;, <span class="hljs-number">2000</span>);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([<span class="hljs-title function_">promise1</span>(), <span class="hljs-title function_">promise2</span>(), <span class="hljs-title function_">promise3</span>()])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">first</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只要有一个请求成功 就会返回第一个请求成功的</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first); <span class="hljs-comment">// 会返回promise2</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 所有三个全部请求失败 才会来到这里</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;error&quot;</span>, error);<br>  &#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([<span class="hljs-title function_">promise1</span>(), <span class="hljs-title function_">promise2</span>(), <span class="hljs-title function_">promise3</span>()])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">first</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只要有一个请求成功 就会返回第一个请求成功的</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first); <span class="hljs-comment">// 会返回promise2</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 所有三个全部请求失败 才会来到这里</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;error&quot;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端常用npm、yarn、pnpm命令</title>
    <link href="/blog/2023/12/15/linux-common/"/>
    <url>/blog/2023/12/15/linux-common/</url>
    
    <content type="html"><![CDATA[<h1 id="前端常用命令"><a href="#前端常用命令" class="headerlink" title="前端常用命令"></a>前端常用命令</h1><h2 id="一、npm命令"><a href="#一、npm命令" class="headerlink" title="一、npm命令"></a>一、npm命令</h2><h3 id="1-基础命令"><a href="#1-基础命令" class="headerlink" title="1.基础命令"></a>1.基础命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm init<span class="hljs-comment">#初始化一个新的npm项目，跳过npm init命令行接口(CLI)。</span><br>npm install<span class="hljs-comment">#根据项目中的package.json文件自动下载项目所需的全部依赖。</span><br>npm install 包名 --save-dev<span class="hljs-comment">#安装的包只用于开发环境，不用于生产环境，会出现在package.json文件中的dependencies属性中。</span><br>npm install 包名 --save<span class="hljs-comment">#安装的包需要发布到生产环境的，会出现在package.json文件中的dependencies属性中。</span><br>npm list<span class="hljs-comment">#查看当前目录下已安装的node包。</span><br>npm list -g<span class="hljs-comment">#查看全局已经安装过的node包。</span><br>npm update <span class="hljs-comment">#包名：更新指定包。</span><br>npm uninstall <span class="hljs-comment">#包名：卸载指定包。</span><br>npm config list<span class="hljs-comment">#查看配置信息。</span><br>npm info 包名<span class="hljs-comment">#查看包的详细信息。</span><br>npm search 字符串/正则表达式<span class="hljs-comment">#搜索npm仓库。</span><br>npm <span class="hljs-built_in">logout</span><span class="hljs-comment">#退出npm的登录状态。</span><br>npm login<span class="hljs-comment">#登录npm，输入用户名和密码。</span><br>npm <span class="hljs-built_in">whoami</span><span class="hljs-comment">#查看当前登录的用户名。</span><br>npm cache clean<span class="hljs-comment">#清理npm缓存。</span><br>npm cache verify<span class="hljs-comment">#检查npm缓存的有效性。</span><br></code></pre></td></tr></table></figure><h3 id="2-进阶命令"><a href="#2-进阶命令" class="headerlink" title="2.进阶命令"></a>2.进阶命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm config list：列出npm的所有配置。<br>npm config edit：编辑npm的配置文件。<br>npm unpublish 包名：从npm仓库中删除指定的包。<br>npm config get always-auth：获取npm始终进行身份验证的设置。<br>npm config <span class="hljs-built_in">set</span> always-auth <span class="hljs-literal">false</span>：取消设置npm始终进行身份验证。<br>npm config <span class="hljs-built_in">set</span> email [email]**：设置npm的邮箱地址。<br>npm config <span class="hljs-built_in">set</span> username [username]**：设置npm的用户名。<br>npm config <span class="hljs-built_in">rm</span> username：删除npm的用户名配置。<br>npm config <span class="hljs-built_in">rm</span> email：删除npm的邮箱地址配置。<br>npm config <span class="hljs-built_in">env</span>：打印出配置相关的环境变量。<br>npm config list：列出所有的配置选项及其值。<br>npm config delete **：删除特定的配置选项。<br><br><span class="hljs-comment"># 设置淘宝的镜像源</span><br>npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com<br><span class="hljs-comment"># 腾讯云镜像源</span><br>npm config <span class="hljs-built_in">set</span> registry http://mirrors.cloud.tencent.com/npm/<br><span class="hljs-comment"># 华为云镜像源</span><br>npm config <span class="hljs-built_in">set</span> registry https://mirrors.huaweicloud.com/repository/npm/<br><span class="hljs-comment"># 官方默认全局镜像</span><br>npm config <span class="hljs-built_in">set</span> registry https://registry.npmjs.org<br><span class="hljs-comment"># 检查当前镜像</span><br>npm config get registry<br></code></pre></td></tr></table></figure><h2 id="二、yarn命令"><a href="#二、yarn命令" class="headerlink" title="二、yarn命令"></a>二、yarn命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#1、安装yarn </span><br>npm install -g yarn<br><br><span class="hljs-comment">#2、安装成功后，查看版本号： </span><br>yarn --version<br><br><span class="hljs-comment">#3、初始化项目 </span><br>yarn init <span class="hljs-comment"># 同npm init，执行输入信息后，会生成package.json文件</span><br>yarn的配置项： <br>yarn config list <span class="hljs-comment"># 显示所有配置项</span><br>yarn config get &lt;key&gt; <span class="hljs-comment"># 显示某配置项</span><br>yarn config delete &lt;key&gt; <span class="hljs-comment"># 删除某配置项</span><br>yarn config <span class="hljs-built_in">set</span> &lt;key&gt; &lt;value&gt; [-g|--global] <span class="hljs-comment">#设置配置项</span><br>yarn config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com <span class="hljs-comment"># 添加淘宝源</span><br><br><span class="hljs-comment">#4、安装包： </span><br>yarn install <span class="hljs-comment"># 安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lock</span><br>yarn install --flat <span class="hljs-comment"># 安装一个包的单一版本</span><br>yarn install --force <span class="hljs-comment"># 强制重新下载所有包</span><br>yarn install --production <span class="hljs-comment"># 只安装dependencies里的包</span><br>yarn install --no-lockfile <span class="hljs-comment"># 不读取或生成yarn.lock</span><br>yarn install --pure-lockfile <span class="hljs-comment"># 不生成yarn.lock</span><br><br><span class="hljs-comment">#5、添加包（会更新package.json和yarn.lock）</span><br>yarn add [package] <span class="hljs-comment">#  在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中</span><br>yarn add [package]@[version] <span class="hljs-comment">#  安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数</span><br>yarn add [package]@[tag] <span class="hljs-comment">#  安装某个tag（比如beta,next或者latest）</span><br><br><span class="hljs-comment"># 不指定依赖类型默认安装到dependencies里，你也可以指定依赖类型：</span><br><br>yarn add --dev/-D <span class="hljs-comment">#  加到 devDependencies</span><br>yarn add --peer/-P <span class="hljs-comment">#  加到 peerDependencies</span><br>yarn add --optional/-O <span class="hljs-comment">#  加到 optionalDependencies</span><br><br><span class="hljs-comment"># 默认安装包的主要版本里的最新版本，下面两个命令可以指定版本：</span><br><br><span class="hljs-comment"># 安装包的精确版本。例如yarn add test@1.2.3会接受1.9.1版，但是yarn add test@1.2.3 --exact只会接受1.2.3版</span><br><br>yarn add --exact/-E <br><br><span class="hljs-comment">#  安装包的次要版本里的最新版。例如yarn add foo@1.2.3 --tilde会接受1.2.9，但不接受1.3.0</span><br><br>yarn add --tilde/-T <br><br><span class="hljs-comment">#6、发布包</span><br>yarn publish<br><br><span class="hljs-comment">#7、移除一个包 </span><br>yarn remove &lt;packageName&gt;：移除一个包，会自动更新package.json和yarn.lock<br><br><span class="hljs-comment">#8、更新一个依赖 </span><br>yarn upgrade 用于更新包到基于规范范围的最新版本<br><br><span class="hljs-comment">#9、运行脚本 </span><br>yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本<br><br><span class="hljs-comment">#10、显示某个包的信息 </span><br>yarn info &lt;packageName&gt; 可以用来查看某个模块的最新版本信息<br><br><span class="hljs-comment">#11、缓存 </span><br>yarn cache <br>yarn cache list <span class="hljs-comment"># 列出已缓存的每个包 </span><br>yarn cache <span class="hljs-built_in">dir</span> <span class="hljs-comment"># 返回 全局缓存位置 </span><br>yarn cache clean <span class="hljs-comment"># 清除缓存</span><br></code></pre></td></tr></table></figure><h2 id="三、pnpm"><a href="#三、pnpm" class="headerlink" title="三、pnpm"></a>三、pnpm</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装指定版本pnpm</span><br>npm install -g pnpm@6.32.2<br><br><span class="hljs-comment">#安装软件包及其依赖的任何软件包 如果workspace有配置会优先从workspace安装</span><br>pnpm add &lt;pkg&gt;<br><span class="hljs-comment">#安装项目所有依赖</span><br>pnpm install<br><span class="hljs-comment">#更新软件包的最新版本</span><br>pnpm update<br><span class="hljs-comment">#移除项目依赖</span><br>pnpm remove<br><span class="hljs-comment">#运行脚本</span><br>pnpm run<br><span class="hljs-comment">#创建一个 package.json 文件</span><br>pnpm init<br><span class="hljs-comment">#以一个树形结构输出所有的已安装package的版本及其依赖</span><br>pnpm list<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>common</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm、yarn、pnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter 常用命令</title>
    <link href="/blog/2023/12/15/linux-flutter/"/>
    <url>/blog/2023/12/15/linux-flutter/</url>
    
    <content type="html"><![CDATA[<h1 id="Flutter-常用命令"><a href="#Flutter-常用命令" class="headerlink" title="Flutter 常用命令"></a>Flutter 常用命令</h1><h3 id="一、环境安装"><a href="#一、环境安装" class="headerlink" title="一、环境安装"></a>一、环境安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutter --version  <span class="hljs-comment">#查看当前安装的flutter 版本</span><br>flutter upgrade    <span class="hljs-comment">#升级当前的flutter 版本</span><br>flutter doctor    <span class="hljs-comment">#检查环境安装是否完成</span><br>flutter emulators  <span class="hljs-comment">#获取模拟器列表（iOS、Android模拟器）</span><br>flutter channel    <span class="hljs-comment">#查看flutter sdk的所有分支</span><br>flutter channel stable <span class="hljs-comment">#切换sdk分支</span><br>flutter   <span class="hljs-comment">#获取flutter所有命令</span><br>flutter <span class="hljs-built_in">help</span><span class="hljs-comment">#查看命令的帮助信息</span><br>flutter analyze<span class="hljs-comment">#分析代码</span><br></code></pre></td></tr></table></figure><h3 id="二、项目编译运行"><a href="#二、项目编译运行" class="headerlink" title="二、项目编译运行"></a>二、项目编译运行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutter clean  <span class="hljs-comment">#清空build目录</span><br>flutter pub get <span class="hljs-comment">#获取pub插件包</span><br>flutter run --设备名称  <span class="hljs-comment">#运行项目到指定设备</span><br>flutter packages get  <span class="hljs-comment">#获取flutter项目中以来的包，不包括flutter sdk</span><br>flutter packages upgrade <span class="hljs-comment">#更新flutter项目所有依赖包，不包括flutter sdk</span><br></code></pre></td></tr></table></figure><h3 id="三、打包"><a href="#三、打包" class="headerlink" title="三、打包"></a>三、打包</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutter build apk --release --target-platform android-arm64 <span class="hljs-comment">#生成指定CPU架构的apk</span><br>flutter build ios <span class="hljs-comment">#iOS打包 这一步并不能生成ipa文件，需要使用Xcode 打包</span><br></code></pre></td></tr></table></figure><h3 id="四、创建项目"><a href="#四、创建项目" class="headerlink" title="四、创建项目"></a>四、创建项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutter create --project-name hello_flutter --org cn.coderpig --platforms=android,ios --android-language java --ios-language objc hello_flutter <br><br><span class="hljs-comment"># 上述参数解析 (更多参数可以键入 flutter create --help 查看更多详细参数 )：</span><br><br><span class="hljs-comment"># --project-name → 项目名称，只能由 小写字母、下划线 和 数字 组成，不然会报错：xxx is not a valid Dart package name</span><br><span class="hljs-comment"># --org → 项目包名</span><br><span class="hljs-comment"># --platforms → 限定支持的平台，这里限定只支持 android 和 ios</span><br><span class="hljs-comment"># --android-language → 设定安卓端项目语言，可选值：java, kotlin(默认)</span><br><span class="hljs-comment"># --ios-language → 设置iOS端项目语言，可选值：objc, swift(默认)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>common</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter common</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue2 组件通信方式</title>
    <link href="/blog/2023/12/13/vue-components/"/>
    <url>/blog/2023/12/13/vue-components/</url>
    
    <content type="html"><![CDATA[<h1 id="vue2-组件通信方式"><a href="#vue2-组件通信方式" class="headerlink" title="vue2 组件通信方式"></a>vue2 组件通信方式</h1><h2 id="1-父子组件传值"><a href="#1-父子组件传值" class="headerlink" title="1.父子组件传值"></a>1.父子组件传值</h2><p> 父组件通过 props 属性向子组件传递数据，子组件通过 $emit 方法向父组件传递事件。<br> vue组件通信方式：</p><ul><li>props</li><li>emit</li><li>vuex<br> 下面是一个简单的例子：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">send</span>=<span class="hljs-string">&quot;handleSend&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">ChildComponent</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">handleSend</span>(<span class="hljs-params">message</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSend&quot;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">handleSend</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;send&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，父组件通过 props 属性向子组件传递了一个名为 message 的数据，子组件通过 $emit 方法向父组件传递了一个名为 send 的事件，并将 message 数据作为参数传递给父组件。父组件通过 @send 监听子组件的 send 事件，并在 handleSend 方法中获取 message 数据。</p><h2 id="1-兄弟组件传值"><a href="#1-兄弟组件传值" class="headerlink" title="1.兄弟组件传值"></a>1.兄弟组件传值</h2><p>在 Vue.js 中。兄弟组件可以通过父组件的 props 属性来传递数据，通过 $emit 方法来触发事件。下面是一个简单的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child-component-1</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">send</span>=<span class="hljs-string">&quot;handleSend&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component-1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child-component-2</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component-2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent1</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent1.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent2</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent2.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">ChildComponent1</span>,</span><br><span class="language-javascript">    <span class="hljs-title class_">ChildComponent2</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">handleSend</span>(<span class="hljs-params">message</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = message;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 子组件1 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSend&quot;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">handleSend</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;send&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 子组件2 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，父组件包含了两个子组件：ChildComponent1 和 ChildComponent2。ChildComponent1 通过 props 属性向父组件传递了一个名为 message 的数据，通过 $emit 方法向父组件传递了一个名为 send 的事件，并将 message 数据作为参数传递给父组件。父组件接收到子组件1的 send 事件后，将 message 数据保存在自己的 data 中，并通过 props 属性将 message 数据传递给 ChildComponent2。</p><h2 id="3-跨级组件传值"><a href="#3-跨级组件传值" class="headerlink" title="3.跨级组件传值"></a>3.跨级组件传值</h2><p> 跨级组件可以通过父组件的 props 属性来传递数据，通过 $emit 方法来触发事件。下面是一个简单的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child-component-1</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">send</span>=<span class="hljs-string">&quot;handleSend&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component-1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child-component-3</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component-3</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent1</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent1.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent3</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent3.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">ChildComponent1</span>,</span><br><span class="language-javascript">    <span class="hljs-title class_">ChildComponent3</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">handleSend</span>(<span class="hljs-params">message</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = message;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 子组件1 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSend&quot;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">handleSend</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;send&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 子组件3 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，父组件包含了两个子组件：ChildComponent1 和 ChildComponent3。ChildComponent1 通过 props 属性向父组件传递了一个名为 message 的数据，通过 $emit 方法向父组件传递了一个名为 send 的事件，并将 message 数据作为参数传递给父组件。父组件接收到子组件1的 send 事件后，将 message 数据保存在自己的 data 中，并通过 props 属性将 message 数据传递给 ChildComponent3。</p><h2 id="4-Vuex-状态管理"><a href="#4-Vuex-状态管理" class="headerlink" title="4.Vuex 状态管理"></a>4.Vuex 状态管理</h2><p>在 Vue.js 中，组件传值的另一种方式是使用 Vuex 状态管理。Vuex 是一种状态管理模式，用于管理应用程序中的共享状态。Vuex 中的状态可以被任何组件访问和修改，因此可以用来实现组件之间的通信。下面是一个简单的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child-component-1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component-1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child-component-3</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component-3</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent1</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent1.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent3</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent3.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">ChildComponent1</span>,</span><br><span class="language-javascript">    <span class="hljs-title class_">ChildComponent3</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  store</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 子组件1 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSend&quot;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; mapActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    ...<span class="hljs-title function_">mapActions</span>([<span class="hljs-string">&#x27;sendMessage&#x27;</span>]),</span><br><span class="language-javascript">    <span class="hljs-title function_">handleSend</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendMessage</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 子组件3 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; mapState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;message&#x27;</span>])</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，父组件通过引入 store 对象来使用 Vuex 状态管理。子组件1通过 mapActions 方法将 sendMessage 方法映射到组件中，并在 handleSend 方法中调用 sendMessage 方法来发送消息。sendMessage 方法将消息保存在 Vuex 的 state 中。子组件3通过 mapState 方法将 message 属性映射到组件中，并在模板中使用 message 属性来显示消息。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>本文详细介绍了 Vue.js 中的组件传值机制，包括父子组件传值、兄弟组件传值、跨级组件传值和使用 Vuex 状态管理等多种方式。在实际开发中，我们可以根据具体的场景和需求来选择合适的方式来实现组件之间的通信。同时，我们也需要注意传递数据的类型和格式，以保证数据的正确性和可靠性。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件传值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter组件和路由</title>
    <link href="/blog/2023/12/08/flutter-components/"/>
    <url>/blog/2023/12/08/flutter-components/</url>
    
    <content type="html"><![CDATA[<h1 id="flutter-组件和路由"><a href="#flutter-组件和路由" class="headerlink" title="flutter 组件和路由"></a>flutter 组件和路由</h1><h3 id="1-路由"><a href="#1-路由" class="headerlink" title="1.路由"></a>1.路由</h3><p>实际的项目，是有多个不同的页面的，页面之间的跳转，就要用到路由了。 我们增加一个list页面，点击Home页的“Click Me”按钮，跳转到列表页list。</p><h4 id="1-1-单个页面的跳转"><a href="#1-1-单个页面的跳转" class="headerlink" title="1.1 单个页面的跳转"></a>1.1 单个页面的跳转</h4><p>增加list.dart</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">//定义列表widget的list</span><br>    <span class="hljs-built_in">List</span>&lt;Widget&gt; list=&lt;Widget&gt;[];<br><br>    <span class="hljs-comment">//Demo数据定义</span><br>    <span class="hljs-keyword">var</span> data=[<br>      &#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;测试数据AAA&quot;</span>,<span class="hljs-string">&quot;subtitle&quot;</span>:<span class="hljs-string">&quot;ASDFASDFASDF&quot;</span>&#125;,<br>      &#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;测试数据bbb&quot;</span>,<span class="hljs-string">&quot;subtitle&quot;</span>:<span class="hljs-string">&quot;ASDFASDFASDF&quot;</span>&#125;,<br>      &#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;测试数据ccc&quot;</span>,<span class="hljs-string">&quot;subtitle&quot;</span>:<span class="hljs-string">&quot;ASDFASDFASDF&quot;</span>&#125;,<br>      &#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;测试数据eee&quot;</span>,<span class="hljs-string">&quot;subtitle&quot;</span>:<span class="hljs-string">&quot;ASDFASDFASDF&quot;</span>&#125;,<br>    ];<br><br>    <span class="hljs-comment">//根据Demo数据，构造列表ListTile组件list</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> data) &#123;<br>      <span class="hljs-built_in">print</span>(item[<span class="hljs-string">&quot;title&quot;</span>]);<br><br>      list.add( ListTile( <br>          title: Text(item[<span class="hljs-string">&quot;title&quot;</span>],style: TextStyle(fontSize: <span class="hljs-number">18.0</span>) ),<br>          subtitle: Text(item[<span class="hljs-string">&quot;subtitle&quot;</span>]),<br>          leading:  Icon( Icons.fastfood, color:Colors.orange ),<br>          trailing: Icon(Icons.keyboard_arrow_right)<br>      ));<br>    &#125;<br><br>    <span class="hljs-comment">//返回整个页面</span><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;List Page&quot;</span>),<br>      ),<br>      body: Center(<br>        child: ListView(<br>          children: list,<br>        )<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在main.dart增加list页面的引入</p><p>import ‘list.dart’;</p><p>修改Home页的按钮事件，增加Navigator.push跳转</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">FlatButton(<br>  color: Colors.blue,textColor: Colors.white,<br>  onPressed: () &#123;    <br>      Navigator.push(context, MaterialPageRoute(builder:(context) &#123;<br>        <span class="hljs-keyword">return</span>  ListPage();<br>      &#125;));<br>    &#125;,<br>    child: Text(<span class="hljs-string">&quot;Click ME&quot;</span>,style: TextStyle(fontSize: <span class="hljs-number">20.0</span>) ),<br>)<br></code></pre></td></tr></table></figure><p>核心方法就是： Navigator.push(context,MaterialPageRoute)</p><p>跳转示例：</p><h4 id="1-2-更多页面跳转使用路由表"><a href="#1-2-更多页面跳转使用路由表" class="headerlink" title="1.2 更多页面跳转使用路由表"></a>1.2 更多页面跳转使用路由表</h4><p>在MaterialApp中，有一个属性是routes，我们可以对路由进行命名，这样跳转的时候，只需要使用对应的路由名字即可，如： Navigator.pushNamed(context, RouterName) 。点击两个不同的按钮，分别跳转到ListPage，和Page2去。</p><p>Main.dart修改一下如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;list.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;page2.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() =&gt; runApp(MyApp());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>      <span class="hljs-comment">//路由表定义</span><br>      routes:&#123;<br>        <span class="hljs-string">&quot;ListPage&quot;</span>:(context)=&gt; ListPage(),<br>        <span class="hljs-string">&quot;Page2&quot;</span>:(context)=&gt; Page2(),<br>      &#125;,<br>      home: MyHomePage(),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  MyHomePageState createState() =&gt; MyHomePageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt;</span>&#123;<br>   <span class="hljs-meta">@override</span><br>   Widget build(BuildContext context) &#123;<br>       <span class="hljs-keyword">return</span> Scaffold(<br>          appBar: AppBar(<br>            title: Text(<span class="hljs-string">&quot;我是Title&quot;</span>),<br>          ),<br>          body: Center(<br>            child:Column(<br>              children:&lt;Widget&gt;[<br>                RaisedButton(<br>                  child: Text(<span class="hljs-string">&quot;Clikc to ListPage&quot;</span> ),<br>                  onPressed: () &#123;<br>                    <span class="hljs-comment">//根据命名路由做跳转</span><br>                    Navigator.pushNamed(context, <span class="hljs-string">&quot;ListPage&quot;</span>);<br>                  &#125;,<br>                ),<br>                RaisedButton(<br>                  child: Text(<span class="hljs-string">&quot;Click to Page2&quot;</span> ),<br>                  onPressed: () &#123;<br>                    <span class="hljs-comment">//根据命名路由做跳转</span><br>                    Navigator.pushNamed(context, <span class="hljs-string">&quot;Page2&quot;</span>);<br>                  &#125;,<br>                )<br>              ]<br>            )<br>          )<br>      );<br>  &#125;  <br><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><p>当我们有了路由以后，就可以开始在一个项目里用不同的页面，去学习不同的功能了。</p><h4 id="1-3-路由传参"><a href="#1-3-路由传参" class="headerlink" title="1.3 路由传参"></a>1.3 路由传参</h4><p>列表页跳转到详情页，需要路由传参，这个在flutter体系里，又是怎么做的呢？</p><p>首先，在main.dart里，增加详情页DedailPage的路由配置</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//路由表定义</span><br>  routes:&#123;<br>    <span class="hljs-string">&quot;ListPage&quot;</span>:(context)=&gt; ListPage(),<br>    <span class="hljs-string">&quot;Page2&quot;</span>:(context)=&gt; Page2(),<br>    <span class="hljs-string">&quot;DetailPage&quot;</span>:(context)=&gt; DetailPage(), <span class="hljs-comment">//增加详情页的路由配置</span><br>  &#125;,<br></code></pre></td></tr></table></figure><p>并修改ListPage里ListTile的点击事件，增加路由跳转传参，这里是将整个item数据对象传递</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">ListTile( <br>  title: Text(item[<span class="hljs-string">&quot;title&quot;</span>],style: TextStyle(fontSize: <span class="hljs-number">18.0</span>) ),<br>  subtitle: Text(item[<span class="hljs-string">&quot;subtitle&quot;</span>]),<br>  leading:  Icon( Icons.fastfood, color:Colors.orange ),<br>  trailing: Icon(Icons.keyboard_arrow_right),<br>  onTap:()&#123;<br>    <span class="hljs-comment">//点击的时候，进行路由跳转传参</span><br>      Navigator.pushNamed(context, <span class="hljs-string">&quot;DetailPage&quot;</span>, arguments:item);<br>  &#125;,<br>)<br></code></pre></td></tr></table></figure><p>详情页DetailPage里，获取传参并显示</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>     <span class="hljs-comment">//获取路由传参</span><br>     <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span> args = ModalRoute.of(context).settings.arguments;<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Detail Page&quot;</span>),<br>      ),<br>      body: <br>        <span class="hljs-keyword">new</span> Column(<br>          children: &lt;Widget&gt;[<br>             Text(<span class="hljs-string">&quot;我是Detail页面&quot;</span>),<br>             Text(<span class="hljs-string">&quot;id:<span class="hljs-subst">$&#123;args[<span class="hljs-string">&#x27;id&#x27;</span>]&#125;</span>&quot;</span> ),<br>             Text(<span class="hljs-string">&quot;id:<span class="hljs-subst">$&#123;args[<span class="hljs-string">&#x27;title&#x27;</span>]&#125;</span>&quot;</span>),<br>             Text(<span class="hljs-string">&quot;id:<span class="hljs-subst">$&#123;args[<span class="hljs-string">&#x27;subtitle&#x27;</span>]&#125;</span>&quot;</span>)<br>          ],<br>        )<br>      );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Demo效果：</p><h3 id="2-widget"><a href="#2-widget" class="headerlink" title="2.widget"></a>2.widget</h3><p>Flutter提供了很多默认的组件，而每个组件的都继承自widget 。 在Flutter眼里： 一切都是widget 。 这句看起来是不是很熟悉？ 还记得在webpack里，一切都是module吗？ 类似的还有java的一切都是对象。貌似任何一个技术，最后都是用哲学作为指导思想。</p><p>widget，作为可视化的UI组件，包含了显示UI、功能交互两部分。大的widget，也可以由多个小的widget组合而成。</p><p>常用的widget组件：</p><h4 id="2-1-Text"><a href="#2-1-Text" class="headerlink" title="2.1 Text"></a>2.1 Text</h4><p>Demo:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">Text(<br>  <span class="hljs-string">&quot;Hello world&quot;</span>,<br>  style: TextStyle(<br>      fontSize: <span class="hljs-number">50</span>,<br>      fontWeight: FontWeight.bold,<br>      color:Color(<span class="hljs-number">0xFF0000ff</span>)<br>    )<br>  ),<br></code></pre></td></tr></table></figure><p>Text的样式，来自另一个widget：TextStyle。 而TextStyle里的color，又是另一个widget Color的实例。</p><p>如果用flutter的缩进的方法，看起来确实有点丑陋，习惯写CSS的前端同学，可以看看下面的风格：</p><p>Text( “Hello world”, style: TextStyle( fontSize: 50,fontWeight: FontWeight.bold,color:Color(0xFF0000ff) ) )<br>写成一行，是不是就顺眼多了？这算前端恶习吗？ _</p><h4 id="2-2-Button"><a href="#2-2-Button" class="headerlink" title="2.2 Button"></a>2.2 Button</h4><p>对于flutter来说，Button就提供了很多种，我们来看看他们的区别：</p><p>RaisedButton: 凸起的按钮</p><p>FlatButton：扁平化按钮</p><p>OutlineButton：带边框按钮</p><p>IconButton：带图标按钮</p><p>按钮测试页dart:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ButtonPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Button Page&quot;</span>),<br>      ),<br>      body: Column(<br>        children: &lt;Widget&gt;[<br>          RaisedButton(<br>              child: Text(<span class="hljs-string">&quot;我是 RaiseButton&quot;</span> ),<br>              onPressed: () &#123;&#125;,<br>          ),<br>            FlatButton(<br>              child: Text(<span class="hljs-string">&quot;我是 FlatButton&quot;</span> ),<br>              color: Colors.blue,<br>              onPressed: () &#123;&#125;,<br>          ),<br>          OutlineButton(<br>              child: Text(<span class="hljs-string">&quot;我是 OutlineButton&quot;</span> ),<br>              textColor: Colors.blue,<br>              onPressed: () &#123;&#125;,<br>          ),<br>          IconButton(<br>              icon: Icon(Icons.add),<br>              onPressed: () &#123;&#125;,<br>          )  <br>        ]<br>      )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Demo:</p><p>项目中要用哪个，就各取所需吧~</p><h4 id="2-3-Container"><a href="#2-3-Container" class="headerlink" title="2.3 Container"></a>2.3 Container</h4><p>Container是非常常用的一个widget，他一般是用作一个容器。我们先来看看他的基础属性，顺便可以想想他像HTML里的啥？</p><p>基础属性：width，height，color，child</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">body: Center(<br>  child: Container(<br>      color: Colors.blue,<br>      width: <span class="hljs-number">200</span>,<br>      height: <span class="hljs-number">200</span>,<br>      child: Text(<span class="hljs-string">&quot;Hello Container &quot;</span>,style:TextStyle(fontSize: <span class="hljs-number">20</span>,color: Colors.white)),<br>  )<br>)<br></code></pre></td></tr></table></figure><p>Padding</p><p>我们也可以不设置宽高，用 padding 在内部撑开增加留白：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">Container(<br>  color: Colors.blue,<br>  padding: EdgeInsets.all(<span class="hljs-number">30</span>),<br>  child: Text(<span class="hljs-string">&quot;Hello Container &quot;</span>,style:TextStyle(fontSize: <span class="hljs-number">20</span>,color: Colors.white)),<br>)<br></code></pre></td></tr></table></figure><p>Margin</p><p>我们还可以使用 margin ，在容器的外部撑开增加偏移量，</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">Container(<br>  color: Colors.blue,<br>  padding: EdgeInsets.all(<span class="hljs-number">30</span>),<br>  margin: EdgeInsets.only(left: <span class="hljs-number">150</span>,top: <span class="hljs-number">0</span>,right: <span class="hljs-number">0</span>,bottom: <span class="hljs-number">0</span>),<br>  child: Text(<span class="hljs-string">&quot;Hello Container &quot;</span>,style:TextStyle(fontSize: <span class="hljs-number">20</span>,color: Colors.white)),<br>)<br></code></pre></td></tr></table></figure><p>Transform</p><p>我们还可以给这个矩形，使用tansform做一些变化，比如，旋转一个角度</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">Container(<br>  color: Colors.blue,<br>  padding: EdgeInsets.all(<span class="hljs-number">30</span>),<br>  child: Text(<span class="hljs-string">&quot;Hello Container &quot;</span>,style:TextStyle(fontSize: <span class="hljs-number">20</span>,color: Colors.white)),<br>  transform: Matrix4.rotationZ(<span class="hljs-number">0.5</span>)<br>)<br></code></pre></td></tr></table></figure><p>看到这里，好多前端同学要说了，好熟悉啊。 对，他就是很像Html里的一个东西： DIV ，你确实可以对应的去加强理解。</p><h4 id="2-4-Image"><a href="#2-4-Image" class="headerlink" title="2.4 Image"></a>2.4 Image</h4><h5 id="2-4-1-网络图片加载"><a href="#2-4-1-网络图片加载" class="headerlink" title="2.4.1 网络图片加载"></a>2.4.1 网络图片加载</h5><p>使用NetworkImage，可以做网络图片的加载：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">child:Image(<br>  image: NetworkImage(<span class="hljs-string">&quot;https://mat1.gtimg.com/pingjs/ext2020/qqindex2018/dist/img/qq_logo_2x.png&quot;</span>),<br>  width: <span class="hljs-number">200.0</span>,<br>)<br></code></pre></td></tr></table></figure><h5 id="2-4-2-本地图片加载"><a href="#2-4-2-本地图片加载" class="headerlink" title="2.4.2 本地图片加载"></a>2.4.2 本地图片加载</h5><p>加载本地图片，就稍微复杂一些，首先要把图片的路径配置，加入到之前说过的pubspec.yaml配置文件里去:</p><p>image</p><p>加载本地图片时使用AssetImage：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">child:Image(<br>  image: AssetImage(<span class="hljs-string">&quot;assets/images/logo.png&quot;</span>),<br>  width: <span class="hljs-number">200.0</span>,<br>)<br></code></pre></td></tr></table></figure><p>也可以使用简写：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Image.asset(<span class="hljs-string">&quot;assets/images/logo.png&quot;</span>,width:<span class="hljs-number">200.0</span>)<br></code></pre></td></tr></table></figure><p>flutter提供的组件很多，这里就不一一举例说明，有兴趣的还是建议大家去看API： <a href="https://api.flutter.dev/">https://api.flutter.dev/</a></p><h3 id="3-布局"><a href="#3-布局" class="headerlink" title="3.布局"></a>3.布局</h3><p>我们已经了解了这么多组件，那么怎么绘制一个完整的页面呢？ 这就到了页面布局的部分了。</p><h4 id="3-1-Row-Column-Center-行列轴布局"><a href="#3-1-Row-Column-Center-行列轴布局" class="headerlink" title="3.1 Row &amp; Column &amp; Center 行列轴布局"></a>3.1 Row &amp; Column &amp; Center 行列轴布局</h4><p>字面意义也很好理解，行布局、列布局、居中布局，这些布局对于Flutter来说，也都是一个个的widget。</p><p>区别在于，row、column 是有多个children的widget， 而Center是只有 1个child的 widget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">Row(<br>  children:&lt;Widget&gt;[]<br>) <br><br>Column(<br>  children:&lt;Widget&gt;[]<br>)    <br><br>Center(<br>  child:Text(<span class="hljs-string">&quot;Hello&quot;</span>)<br>）<br></code></pre></td></tr></table></figure><h4 id="3-2-Align-角定位布局"><a href="#3-2-Align-角定位布局" class="headerlink" title="3.2 Align 角定位布局"></a>3.2 Align 角定位布局</h4><p>我们常常在Container里，需要显示的内容在左上角，左下角，右上角，右下角。 在html时代，使用CSS可以很容易的实现，但是flutter里，必须依赖Align 这个定位的Widget</p><p>右下角定位示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">child: Container(<br>  color: Colors.blue,<br>  width: <span class="hljs-number">300</span>,<br>  height: <span class="hljs-number">200</span>,<br>  child: Align(<br>    alignment: Alignment.bottomRight,<br>    child:Text(<span class="hljs-string">&quot;Hello Align &quot;</span>,style:TextStyle(fontSize: <span class="hljs-number">20</span>,color: Colors.white)),<br>  )<br>)<br></code></pre></td></tr></table></figure><p>显示效果：</p><p>Alignment提供了多种定位供选择，还算是很贴心的。</p><h4 id="3-3-Stack-Positioned-绝对定位"><a href="#3-3-Stack-Positioned-绝对定位" class="headerlink" title="3.3 Stack &amp; Positioned 绝对定位"></a>3.3 Stack &amp; Positioned 绝对定位</h4><p>当然还有绝对定位的需求，这在css里，使用position：absolute就搞定了，但是在flutter里，需要借助stack+ positioned两个widget一起组合使用。</p><p>Stack: 支持元素堆叠</p><p>Positioned：支持绝对定位</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">child:Stack(<br>  children: &lt;Widget&gt;[<br>      Image.network(<span class="hljs-string">&quot;https://ossweb-img.qq.com/upload/adw/image/20191022/627bdf586e0de8a29d5a48b86700a790.jpeg&quot;</span>),<br>      Positioned(<br>        top: <span class="hljs-number">20</span>,<br>        right: <span class="hljs-number">10</span>,<br>        child:Image.asset(<span class="hljs-string">&quot;assets/images/logo.png&quot;</span>,width:<span class="hljs-number">200.0</span>)<br>      )<br>  ],<br>)<br></code></pre></td></tr></table></figure><h4 id="3-4-Flex-Expanded-流式布局"><a href="#3-4-Flex-Expanded-流式布局" class="headerlink" title="3.4 Flex &amp; Expanded 流式布局"></a>3.4 Flex &amp; Expanded 流式布局</h4><p>Flex流式布局作为前端同学都熟悉，之前讲过的Row，Column，其实都是继承自Flex，也属于流式布局。</p><p>如果轴向不确定，使用Flex，通过修改 direction的值设定轴向<br>如果轴向已确定，使用Row，Column，布局更简洁，更有语义化</p><p>Flex测试页：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlexPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Flex Page&quot;</span>),<br>      ),<br>      body:  Flex(<br>          direction: Axis.horizontal,<br>          children: &lt;Widget&gt;[<br>            Container(<br>              width: <span class="hljs-number">30</span>,<br>              height: <span class="hljs-number">100</span>,<br>              color: Colors.blue,<br>            ),<br>            Expanded(<br>              flex: <span class="hljs-number">1</span>,<br>              child: Container(<br>                height: <span class="hljs-number">100.0</span>,<br>                color: Colors.red,<br>              ),<br>            ),<br>            Expanded(<br>              flex: <span class="hljs-number">1</span>,<br>              child: Container(<br>                height: <span class="hljs-number">100.0</span>,<br>                color: Colors.green,<br>              ),<br>            ),<br>          ],<br>        ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中，轴向横向排列，最左边一个固定宽度的Container，右边两个Expanded，各自占剩下的宽度的一半。</p><h3 id="4-动画"><a href="#4-动画" class="headerlink" title="4.动画"></a>4.动画</h3><p>Flutter既然说了，一切都是Widget，包括动画实现，也是一个Widget。 我们还是看一个示例</p><h4 id="4-1-简单动画：淡入淡出："><a href="#4-1-简单动画：淡入淡出：" class="headerlink" title="4.1 简单动画：淡入淡出："></a>4.1 简单动画：淡入淡出：</h4><p>使用flutter提供的现成的Widget：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimatePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  _AnimatePage  createState()=&gt; _AnimatePage();<br>&#125; <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_AnimatePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">AnimatePage</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">bool</span> _visible=<span class="hljs-keyword">true</span>;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Animate Page&quot;</span>),<br>      ),<br>      body: <br>        Center(<br>          child: Column(<br>            children: &lt;Widget&gt;[<br>              AnimatedOpacity(<br>                opacity: _visible ? <span class="hljs-number">1.0</span>:<span class="hljs-number">0.0</span>,<br>                duration: <span class="hljs-built_in">Duration</span>(milliseconds: <span class="hljs-number">1000</span>),<br>                child: Image.asset(<span class="hljs-string">&quot;assets/images/logo.png&quot;</span>),<br>              ),<br>              RaisedButton(<br>                child: Text(<span class="hljs-string">&quot;显示隐藏&quot;</span>),<br>                onPressed: ()&#123;<br>                  setState(() &#123;<br>                    _visible=!_visible;<br>                  &#125;);<br>                &#125;,<br>              ),<br>            ],<br>          ),<br>        )    <br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的AnimatedOpacity就是动画透明度变化的的Widget，而被透明度控制变化的Image则是AnimatedOpacity的子元素。这个和以往前端写动画的方式，就完全不一样了，需要改变一下思维方式。</p><p>Demo效果</p><h4 id="4-2-复杂一些的动画：放大缩小"><a href="#4-2-复杂一些的动画：放大缩小" class="headerlink" title="4.2 复杂一些的动画：放大缩小"></a>4.2 复杂一些的动画：放大缩小</h4><p>当写复杂一些动画的时候，没有对应的widget组件，就需要自己使用Animation，和AnimationController，以及Tween来组合。</p><p>Animation: 保存动画的值和状态</p><p>AnimationController: 控制动画，包含：启动forward()、停止stop()、反向播放reverse()等方法</p><p>Tween: 提供begin，end作为动画变化的取值范围</p><p>Curve：设置动画使用曲线变化，如非匀速动画，先加速，后减速等的设定。</p><p>动画示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimatePage2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  _AnimatePage  createState()=&gt; _AnimatePage();<br>&#125; <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_AnimatePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">AnimatePage2</span>&gt;  <span class="hljs-title">with</span> <span class="hljs-title">SingleTickerProviderStateMixin</span> </span>&#123;<br><br>  Animation&lt;<span class="hljs-built_in">double</span>&gt; animation;<br>  AnimationController controller;<br><br>  initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    controller =  AnimationController(duration:  <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">3</span>), vsync: <span class="hljs-keyword">this</span>);<br><br>     <span class="hljs-comment">//使用弹性曲线，数据变化从0到300</span><br>     animation = CurvedAnimation(parent: controller, curve: Curves.bounceIn);<br>     animation = Tween(begin: <span class="hljs-number">0.0</span>, end: <span class="hljs-number">300.0</span>).animate(animation)<br>      ..addListener(() &#123;<br>        setState(() &#123;<br>        &#125;);<br>      &#125;);<br><br>    <span class="hljs-comment">//启动动画(正向执行)</span><br>    controller.forward();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Animate Page&quot;</span>),<br>      ),<br>      body: <br>        Center(<br>          child: Image.asset(<br>            <span class="hljs-string">&quot;assets/images/logo.png&quot;</span>,<br>            width: animation.value, <br>            height: animation.value<br>          ),<br>        )  <br>      );   <br>  &#125;<br><br>  dispose() &#123;<br>    <span class="hljs-comment">//路由销毁时需要释放动画资源</span><br>    controller.dispose();<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>很重要的一点， 在路由销毁的时候，需要释放动画资源，否则容易导致内存泄漏 。</p><h3 id="5-http请求"><a href="#5-http请求" class="headerlink" title="5.http请求"></a>5.http请求</h3><p>做业务逻辑，总离不开http请求，接下来，就来看下flutter的http请求是如何做的。</p><h4 id="5-1-HttpClient"><a href="#5-1-HttpClient" class="headerlink" title="5.1 HttpClient"></a>5.1 HttpClient</h4><p>httpClient在 dart:io库中，不需要引入第三方库就可以使用，示例代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:convert&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:io&#x27;</span>;<br><br>Future _getByHttpClient() <span class="hljs-keyword">async</span>&#123;<br>    <span class="hljs-comment">//接口地址</span><br>    <span class="hljs-keyword">const</span> url=<span class="hljs-string">&quot;https://www.demo.com/api&quot;</span>;<br><br>    <span class="hljs-comment">//定义httpClient</span><br>    HttpClient client = <span class="hljs-keyword">new</span> HttpClient();<br>    <span class="hljs-comment">//定义request</span><br>    HttpClientRequest request = <span class="hljs-keyword">await</span> client.getUrl(<span class="hljs-built_in">Uri</span>.parse(url));<br>    <span class="hljs-comment">//定义reponse</span><br>    HttpClientResponse response = <span class="hljs-keyword">await</span> request.close();<br>    <span class="hljs-comment">//respinse返回的数据，是字符串</span><br>    <span class="hljs-built_in">String</span> responseBody = <span class="hljs-keyword">await</span> response.transform(utf8.decoder).join();<br>    <span class="hljs-comment">//关闭httpClient</span><br>    client.close();<br>    <span class="hljs-comment">//字符串需要转化为JSON</span><br>    <span class="hljs-keyword">var</span> json= jsonDecode(responseBody);<br>    <span class="hljs-keyword">return</span> json;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>总的看起来，代码还是挺繁琐的，使用起来并不方便。</p><h4 id="5-2-http"><a href="#5-2-http" class="headerlink" title="5.2 http"></a>5.2 http</h4><p>这是Dart.dev提供的第三方类库，地址： <a href="https://pub.dev/packages/http">https://pub.dev/packages/http</a></p><p>需要先在pubspec.yaml里添加类库应用</p><p>dependencies:<br>  flutter:<br>    sdk: flutter<br>  json_annotation: ^2.0.0<br>  http: ^0.12.0+2<br>使用示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future _getByDartHttp() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-comment">// 接口地址</span><br> <span class="hljs-keyword">const</span> url=<span class="hljs-string">&quot;https://www.demo.com/api&quot;</span>;<span class="hljs-comment">//获取接口的返回值</span><br> <span class="hljs-keyword">final</span> response = <span class="hljs-keyword">await</span> http.<span class="hljs-keyword">get</span>(url);<br> <span class="hljs-comment">//接口的返回值转化为JSON</span><br> <span class="hljs-keyword">var</span> json = jsonDecode(response.body); <br> <span class="hljs-keyword">return</span> json;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法，比上面的httpClient简洁了许多。</p><p>Dio<br>国内使用最广泛的，还是flutterchina在github上提供的Dio第三方库，目前Star达到了5800多个。</p><p>官网地址： <a href="https://github.com/flutterchina/dio">https://github.com/flutterchina/dio</a></p><p>使用Dio，因为是第三方库，所以同样要先在 pubspec.yaml 添加第三方库引用。</p><p>dependencies:<br>  flutter:<br>    sdk: flutter<br>  json_annotation: ^2.0.0<br>  dio: 2.1.16<br>使用示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:dio/dio.dart&#x27;</span>;<br><br>Future _getByDio() <span class="hljs-keyword">async</span>&#123;<br><br>      <span class="hljs-comment">// 接口地址</span><br>      <span class="hljs-keyword">const</span> url=<span class="hljs-string">&quot;https://www.demo.com/api&quot;</span>;<br><br>      <span class="hljs-comment">//定义 Dio实例</span><br>      Dio dio = <span class="hljs-keyword">new</span> Dio();<br>      <span class="hljs-comment">//获取dio返回的Response</span><br>      Response response = <span class="hljs-keyword">await</span> dio.<span class="hljs-keyword">get</span>(url);<br>      <span class="hljs-comment">//返回值转化为JSON</span><br>      <span class="hljs-keyword">var</span> json=jsonDecode(response.data);<br>      <span class="hljs-keyword">return</span> json;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口调用也是比httpclient简单很多，可能由于fluterchina在他的官方教程里，极力推荐这个dio库，所以目前这个第三方库的使用情况最为广泛。和Dart.dev的http不同的是，他需要new一个Dio的实例，在创建实例的时候，还可以传入更多的扩展配置参数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">BaseOptions options = <span class="hljs-keyword">new</span> BaseOptions(<br>    baseUrl: <span class="hljs-string">&quot;https://www.xx.com/api&quot;</span>,<br>    connectTimeout: <span class="hljs-number">5000</span>,<br>    receiveTimeout: <span class="hljs-number">3000</span>,<br>);<br>Dio dio = <span class="hljs-keyword">new</span> Dio(options);<br></code></pre></td></tr></table></figure><h3 id="6-缺点"><a href="#6-缺点" class="headerlink" title="6.缺点"></a>6.缺点</h3><p>学习Flutter的过程中，其实还是有很多坎坷和需要吐槽的地方。</p><h4 id="6-1-墙"><a href="#6-1-墙" class="headerlink" title="6.1 墙"></a>6.1 墙</h4><p>因为有墙在，所以在配置flutter，或者下载flutter插件和第三方库的时候，需要墙内外来回切换。</p><h4 id="6-2-组件过度设计"><a href="#6-2-组件过度设计" class="headerlink" title="6.2 组件过度设计"></a>6.2 组件过度设计</h4><p>提供的各种widget组件很多，但是真正核心的组件、常用的组件，也就哪些。 比如Flex 和column、row的关系，比如，Tween 与IntTween，ColorTween，SizeTween等20多个Tween子类之间的关系，你需要花很大的精力，去看每个具体子类的实现差别。</p><h4 id="6-3-嵌套太多不适应"><a href="#6-3-嵌套太多不适应" class="headerlink" title="6.3 嵌套太多不适应"></a>6.3 嵌套太多不适应</h4><p>因为嵌套层级很多，而且布局、动画、功能都在一起，第一次上手Flutter和Dart，这种嵌套关系让人很晕菜，这个只能去慢慢克服。 另外，多开发自定义的组件，可以让嵌套关系看起来清晰一些。</p><h4 id="6-4-布局修改会导致嵌套关系修改"><a href="#6-4-布局修改会导致嵌套关系修改" class="headerlink" title="6.4 布局修改会导致嵌套关系修改"></a>6.4 布局修改会导致嵌套关系修改</h4><p>前端的html+css分离世界里，不改变嵌套关系，修改CSS就可以调整布局。 但是在Flutter里因为布局也是嵌套关系，这就导致必须去改变嵌套关系。 要让嵌套更简单变动影响更小，页面拆分成子组件变得尤为重要。</p><h4 id="6-5-Dart语言升级"><a href="#6-5-Dart语言升级" class="headerlink" title="6.5 Dart语言升级"></a>6.5 Dart语言升级</h4><p>没错，语言升级也会导致学习的困扰，外面的资料新旧都有，比如有些是 new Text() ,有些直接是Text() ，新手上路会很晕菜。 其实这都是Dart语言升级导致的，记住Dart升级2.X以后，都不使用new了。感兴趣的可以自己去看下Dart的升级变更说明。</p><h4 id="6-6-不能热更新"><a href="#6-6-不能热更新" class="headerlink" title="6.6 不能热更新"></a>6.6 不能热更新</h4><p>年中的时候，Google官方宣布flutter暂不官方支持热更新，但是闲鱼团队已经有了自己的热更新方案。 关于热更新，只能静观其变了。 性能、开发效率、热更新，总是要有取舍的。即使是闲鱼团队，热更新也是付出了一点点性能下降的代价的，这是你选择flutter的初衷吗？还是那句话：权衡得失</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter开发环境搭建</title>
    <link href="/blog/2023/12/08/flutter-configuration/"/>
    <url>/blog/2023/12/08/flutter-configuration/</url>
    
    <content type="html"><![CDATA[<h1 id="Flutter入门教程-开发环境搭建"><a href="#Flutter入门教程-开发环境搭建" class="headerlink" title="Flutter入门教程-开发环境搭建"></a>Flutter入门教程-开发环境搭建</h1><p>学习Flutter，首先需要搭建好Flutter的开发环境，下面我将一步步带领大家搭建开发环境并且成功运行flutter项目。<br>Flutter环境配置主要有这几点：<br><code>系统配置要求</code><br><code>Java环境</code><br><code>Flutter SDK</code><br><code>Android 开发环境</code></p><h3 id="一、系统配置要求"><a href="#一、系统配置要求" class="headerlink" title="一、系统配置要求"></a>一、系统配置要求</h3><p>操作系统：Windows 7 SP1 或更高的版本（基于 x86-64 的 64 位操作系统）</p><p>磁盘空间：除安装 IDE 和一些工具之外还应有至少 1.64 GB 的空间</p><p>Git环境：要让 Flutter在开环境中正常使用，就要有git环境</p><h3 id="二、Java-环境配置"><a href="#二、Java-环境配置" class="headerlink" title="二、Java 环境配置"></a>二、Java 环境配置</h3><p>这里需要安装 Java 环境，因为Flutter是基于Android的，这里就不多细说<br>Java环境下载地址：Java Downloads | Oracle</p><p>这里直接下载64位安装包，解压一直点下一步下一步就搞定了.</p><p>怎么检测java是否安装成功呢？</p><p>1、快捷键： win+R ，输入cmd，按下回车</p><p>2、可以选择输入 java  javac  java -version 三个doc命令进行检查</p><p>输入java + 回车，出现结果证明安装成功.</p><h3 id="三、Flutter-SDK"><a href="#三、Flutter-SDK" class="headerlink" title="三、Flutter SDK"></a>三、Flutter SDK</h3><p> Flutter SDK下载地址：<a href="https://flutter.cn/docs/development/tools/sdk/releases">https://flutter.cn/docs/development/tools/sdk/releases</a></p><p>选择最新版本下载即可，下载成功后将压缩包解压，解压存放路径放在你想放置 Flutter SDK 的路径中（我的是D:\Android\flutter）</p><p>注意：请勿将 Flutter 安装在需要高权限的文件夹内，例如 C:\Program Files\</p><p>我们可以在控制台输入 flutter 命令看是否安装成功，如果输出如下界面就表示flutter安装成功啦：</p><p>将 Flutter 的运行文件路径加入到 PATH 环境变量：</p><p>右击【此电脑】选择【属性】&#x3D;&#x3D;&gt;选择【高级系统设置】&#x3D;&#x3D;&gt;选择【环境变量】，在【用户变量】一栏中，选择【Path】</p><p>双击进入Path条目，点击【新建】将你安装的flutter坐在完整路径作为新变量的值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">path<br>E:\flutter_windows_3.16.3-stable\flutter\bin<br><br>FLUTTER_STORAGE_BASE_URL<br>https://storage.flutter-io.cn<br><br>PUB_HOSTED_URL<br>https://pub.flutter-io.cn<br></code></pre></td></tr></table></figure><p>FLUTTER_STORAGE_BASE_URL、PUB_HOSTED_URL 用来配置国内的flutter环境</p><p>然后一直点击确定就OK啦</p><p>在将 Path 变量更新后，打开一个新的控制台窗口：输入 flutter doctor 命令，如果它提示有任何的平台相关依赖，那么你就需要按照指示完成这些配置。</p><p>简单来看，doctor是医生的意思，顾名思义就是对flutter环境进行检查，并将检测结果以报告形式呈现出来，然后根据检查报告依次解决现有环境缺陷问题</p><p>这里如果是刚安装flutter，有些检查项带有红色的[×]，我这里有显示[√]和[!]</p><p>[×]表示还不能正常运行<br>[!]表示还存在一些问题<br>只有全部为[√]，系统环境才是完全安装好，你的检查报告才是没毛病的</p><p>有叉的选项的一些常见问题</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">1.cmdline-tools component is missing 没有安装cmdline-tools命令工具<br>2.Android license status unknown 缺少android证书<br>3.Visual Studio - develop Windows apps 没有安装Visual Studio<br></code></pre></td></tr></table></figure><p>现在就来看看上述这个警告，根据它的提示，我们只需要执行： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutter doctor --android-licenses <br></code></pre></td></tr></table></figure><p>，执行这条命令后，会有一系列选择，全部选择y就好（我也不知道它是个啥，感兴趣的小伙伴可以自行研究）</p><p>然后我们再来执行： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutter doctor <br></code></pre></td></tr></table></figure><p>全部为√的选项则你的环境就完全安装好了</p><h3 id="四、设置Android开发环境"><a href="#四、设置Android开发环境" class="headerlink" title="四、设置Android开发环境"></a>四、设置Android开发环境</h3><p>已经正确安装flutter开发环境，但是还需要配置下Android的开发环境，因为Flutter 依赖 Android Studio 的全量安装来为其提供 Android 平台的支持</p><h4 id="1-安装-Android-Studio"><a href="#1-安装-Android-Studio" class="headerlink" title="1.安装 Android Studio"></a>1.安装 Android Studio</h4><p>Android Studio下载地址：<a href="https://developer.android.google.cn/studio">https://developer.android.google.cn/studio</a></p><h4 id="2-安装Android-SDK"><a href="#2-安装Android-SDK" class="headerlink" title="2.安装Android SDK"></a>2.安装Android SDK</h4><p>Android SDK下载地址：<a href="https://www.androiddevtools.cn/">https://www.androiddevtools.cn</a></p><p>进入官网我们首先找到 SDK Tools 选项：</p><p>点击下载Android SDK压缩包：</p><p>下载成功并解压安装到自定义目录，解压后文件目录如下：</p><p>运行 flutter doctor 确保 Flutter 已经定位到了你的 Android Studio 的安装位置。<br>如果 Flutter 并未定位到，运行 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">flutter config --android-studio-dir &lt;directory&gt; <br></code></pre></td></tr></table></figure><p>设置你的 Android Studio 的安装目录</p><h4 id="3-创建虚拟机"><a href="#3-创建虚拟机" class="headerlink" title="3.创建虚拟机"></a>3.创建虚拟机</h4><p>首先打开我们的Android Studio开发工具，第一次安装打开界面的左侧选择【Plugin】选项，然后搜索并安装【Flutter】插件，安装【flutter】插件的同时一并安装了【Dart】插件。</p><p>安装好插件后，我们创建一个Flutter项目：</p><p>这里需要选择你的Flutter SDK安装目录，点击【Next】，输入项目名称：</p><p>注意：项目命名规范一般是单词小写，多个单词之间用_连接，如：hello_world</p><p>填写完毕后点击【Finish】完成，打开项目进去界面，选择工具栏的【Tools】，选择【SDK Manager】</p><p>正确填写Android SDK所在目录：</p><p>安装所需工具包（这个可以在后期视情况而定选择下载，这里只是做一个演示）：</p><p>然后同样在Tools选项下选择【Device Manager】，点击【Create device】按钮创建虚拟机：</p><p>这里自行选择机型，然后点击【Next】：</p><p>选择一个系统映像并下载（这个过程可能需要几分钟）：</p><p>下载完成后点击【Next】，继续点击【Finish】完成，然后点击启动按钮，等待虚拟机开启即可：</p><h4 id="4-运行flutter项目"><a href="#4-运行flutter项目" class="headerlink" title="4.运行flutter项目"></a>4.运行flutter项目</h4><p>虚拟机启动后，我们只需要点击编辑器右上角debug就可运行查看flutter项目：</p><p>这一过程可能需要等待一会儿：</p><p>至此，我们的flutter项目就成功运行啦~~</p><p>当然，我们修改main.dart文件内容时，模拟器也是实时更新的：</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>至此，我们从搭建项目环境到运行flutter项目整个流程梳理完成，再进行一次总结：</p><h5 id="1-首先要本身电脑系统配置达到指定要求"><a href="#1-首先要本身电脑系统配置达到指定要求" class="headerlink" title="1.首先要本身电脑系统配置达到指定要求"></a>1.首先要本身电脑系统配置达到指定要求</h5><h5 id="2-Java-环境搭建"><a href="#2-Java-环境搭建" class="headerlink" title="2.Java 环境搭建"></a>2.Java 环境搭建</h5><h5 id="3-获取Flutter-SDK"><a href="#3-获取Flutter-SDK" class="headerlink" title="3.获取Flutter SDK"></a>3.获取Flutter SDK</h5><h5 id="4-设置Android-Studio开发环境"><a href="#4-设置Android-Studio开发环境" class="headerlink" title="4.设置Android Studio开发环境"></a>4.设置Android Studio开发环境</h5><h5 id="5-创建虚拟机"><a href="#5-创建虚拟机" class="headerlink" title="5.创建虚拟机"></a>5.创建虚拟机</h5><h3 id="六、相关配置"><a href="#六、相关配置" class="headerlink" title="六、相关配置"></a>六、相关配置</h3><h5 id="1-配置android-studio"><a href="#1-配置android-studio" class="headerlink" title="1.配置android studio :"></a>1.配置android studio :</h5><pre><code class="hljs">https://blog.51cto.com/u_13446/6527477</code></pre><h5 id="2-flutter-环境配置，教程："><a href="#2-flutter-环境配置，教程：" class="headerlink" title="2.flutter 环境配置，教程："></a>2.flutter 环境配置，教程：</h5><pre><code class="hljs">https://www.cnblogs.com/libo-web/p/16060590.html</code></pre>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题（综合）</title>
    <link href="/blog/2023/10/19/interview-web/"/>
    <url>/blog/2023/10/19/interview-web/</url>
    
    <content type="html"><![CDATA[<h1 id="前端面试题（综合）1-0！"><a href="#前端面试题（综合）1-0！" class="headerlink" title="前端面试题（综合）1.0！"></a>前端面试题（综合）1.0！</h1><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h5 id="1-请解释CSS的盒模型是什么，并描述其组成部分。"><a href="#1-请解释CSS的盒模型是什么，并描述其组成部分。" class="headerlink" title="1. 请解释CSS的盒模型是什么，并描述其组成部分。"></a>1. 请解释CSS的盒模型是什么，并描述其组成部分。</h5><p>​CSS的盒模型是用于布局和定位元素的概念。它由内容区域、内边距、边框和外边距组成，这些部分依次包裹在元素周围。</p><h5 id="2-解释CSS中的选择器及其优先级。"><a href="#2-解释CSS中的选择器及其优先级。" class="headerlink" title="2. 解释CSS中的选择器及其优先级。"></a>2. 解释CSS中的选择器及其优先级。</h5><p>​CSS选择器用于选择要应用样式的HTML元素。选择器的优先级规则是：内联样式 &gt; ID选择器 &gt; 类选择器、属性选择器、伪类选择器 &gt; 元素选择器 &gt; 通用选择器。同时，使用!important可以提升样式的优先级。</p><h5 id="3-解释CSS中的浮动（float）是如何工作的，并提供一个示例。"><a href="#3-解释CSS中的浮动（float）是如何工作的，并提供一个示例。" class="headerlink" title="3. 解释CSS中的浮动（float）是如何工作的，并提供一个示例。"></a>3. 解释CSS中的浮动（float）是如何工作的，并提供一个示例。</h5><p>​浮动（float）是CSS中用于实现元素的左浮动或右浮动，使其脱离文档流并环绕在其周围的元素。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.float-example</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-解释CSS中的定位（position）属性及其不同的取值。"><a href="#4-解释CSS中的定位（position）属性及其不同的取值。" class="headerlink" title="4. 解释CSS中的定位（position）属性及其不同的取值。"></a>4. 解释CSS中的定位（position）属性及其不同的取值。</h5><p>​      定位（position）属性用于控制元素的定位方式。常见的取值有：static（默认，按照文档流定位）、relative（相对定位）、absolute（绝对定位）、fixed（固定定位）和sticky（粘性定位）。</p><h5 id="5-解释CSS中的层叠顺序（z-index）是如何工作的。"><a href="#5-解释CSS中的层叠顺序（z-index）是如何工作的。" class="headerlink" title="5. 解释CSS中的层叠顺序（z-index）是如何工作的。"></a>5. 解释CSS中的层叠顺序（z-index）是如何工作的。</h5><p>​      层叠顺序（z-index）用于控制元素在垂直方向上的堆叠顺序。具有较高层叠顺序值的元素将显示在较低层叠顺序值的元素之上。默认情况下，层叠顺序值为auto。</p><h5 id="6-解释CSS中的伪类和伪元素的区别，并给出一个示例。"><a href="#6-解释CSS中的伪类和伪元素的区别，并给出一个示例。" class="headerlink" title="6. 解释CSS中的伪类和伪元素的区别，并给出一个示例。"></a>6. 解释CSS中的伪类和伪元素的区别，并给出一个示例。</h5><p>​      伪类用于向选择器添加特殊的状态，如:hover、:active等。伪元素用于向选择器添加特殊的元素，如::before、::after等。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 伪类示例 */</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-comment">/* 伪元素示例 */</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;前缀&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7-解释CSS中的盒子模型的两种模式：标准模式和怪异模式。"><a href="#7-解释CSS中的盒子模型的两种模式：标准模式和怪异模式。" class="headerlink" title="7. 解释CSS中的盒子模型的两种模式：标准模式和怪异模式。"></a>7. 解释CSS中的盒子模型的两种模式：标准模式和怪异模式。</h5><p>​      标准模式是按照W3C标准解析渲染页面的模式。怪异模式是兼容旧版本浏览器的解析渲染页面的模式。可以通过声明来指定使用哪种模式。</p><h5 id="8-解释CSS中的BFC是什么，它的作用是什么？"><a href="#8-解释CSS中的BFC是什么，它的作用是什么？" class="headerlink" title="8. 解释CSS中的BFC是什么，它的作用是什么？"></a>8. 解释CSS中的BFC是什么，它的作用是什么？</h5><p>​      BFC（块级格式化上下文）是CSS中的一种渲染模式，它创建了一个独立的渲染环境，其中的元素按照一定的规则进行布局和定位。BFC的作用包括：清除浮动、防止外边距重叠等。</p><h5 id="9-解释CSS中的flexbox布局是什么，它的优势是什么？"><a href="#9-解释CSS中的flexbox布局是什么，它的优势是什么？" class="headerlink" title="9. 解释CSS中的flexbox布局是什么，它的优势是什么？"></a>9. 解释CSS中的flexbox布局是什么，它的优势是什么？</h5><p>​      flexbox布局是一种用于创建灵活的、响应式的布局的CSS模块。它通过flex容器和flex项目的组合来实现强大的布局能力。其优势包括简单易用、自适应性强、对齐和分布控制灵活等。</p><h5 id="10-解释CSS中的媒体查询是什么，它的作用是什么？"><a href="#10-解释CSS中的媒体查询是什么，它的作用是什么？" class="headerlink" title="10.解释CSS中的媒体查询是什么，它的作用是什么？"></a>10.解释CSS中的媒体查询是什么，它的作用是什么？</h5><p>​      媒体查询是CSS中的一种技术，用于根据设备的特性和属性来应用不同的样式。通过媒体查询，可以根据屏幕尺寸、设备类型、分辨率等条件来优化页面的布局和样式。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h5 id="1-解释JavaScript的数据类型，并举例说明每种类型。"><a href="#1-解释JavaScript的数据类型，并举例说明每种类型。" class="headerlink" title="1. 解释JavaScript的数据类型，并举例说明每种类型。"></a>1. 解释JavaScript的数据类型，并举例说明每种类型。</h5><p>​      JavaScript有七种数据类型：字符串（String）、数字（Number）、布尔值（Boolean）、对象（Object）、数组（Array）、空值（Null）和未定义（Undefined）。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> bool = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> n = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> undef;<br></code></pre></td></tr></table></figure><h5 id="2-解释JavaScript中的变量提升（Hoisting）是什么。"><a href="#2-解释JavaScript中的变量提升（Hoisting）是什么。" class="headerlink" title="2. 解释JavaScript中的变量提升（Hoisting）是什么。"></a>2. 解释JavaScript中的变量提升（Hoisting）是什么。</h5><p>​      变量提升是指在JavaScript中，变量和函数声明会在代码执行之前被提升到作用域的顶部。这意味着可以在声明之前使用变量和函数。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 输出 undefined</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h5 id="3-解释JavaScript中的闭包（Closure）是什么，并举例说明。"><a href="#3-解释JavaScript中的闭包（Closure）是什么，并举例说明。" class="headerlink" title="3. 解释JavaScript中的闭包（Closure）是什么，并举例说明。"></a>3. 解释JavaScript中的闭包（Closure）是什么，并举例说明。</h5><p>​      闭包是指函数可以访问并操作其词法作用域之外的变量。它通过在函数内部创建一个内部函数，并返回该内部函数来实现。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>  &#125;<br>  <span class="hljs-keyword">return</span> inner;<br>&#125;<br><br><span class="hljs-keyword">let</span> closure = <span class="hljs-title function_">outer</span>();<br><span class="hljs-title function_">closure</span>(); <span class="hljs-comment">// 输出 10</span><br></code></pre></td></tr></table></figure><h5 id="4-解释JavaScript中的事件冒泡（Event-Bubbling）和事件捕获（Event-Capturing）。"><a href="#4-解释JavaScript中的事件冒泡（Event-Bubbling）和事件捕获（Event-Capturing）。" class="headerlink" title="4. 解释JavaScript中的事件冒泡（Event Bubbling）和事件捕获（Event Capturing）。"></a>4. 解释JavaScript中的事件冒泡（Event Bubbling）和事件捕获（Event Capturing）。</h5><p>​      事件冒泡是指事件从最具体的元素开始向父元素逐级触发，直到触发到根元素。事件捕获是指事件从根元素开始，逐级向最具体的元素触发。可以使用addEventListener方法的第三个参数来控制是使用事件冒泡还是事件捕获。</p><h5 id="5-解释JavaScript中的原型继承（Prototype-Inheritance）是什么。"><a href="#5-解释JavaScript中的原型继承（Prototype-Inheritance）是什么。" class="headerlink" title="5. 解释JavaScript中的原型继承（Prototype Inheritance）是什么。"></a>5. 解释JavaScript中的原型继承（Prototype Inheritance）是什么。</h5><p>​      原型继承是JavaScript中实现对象之间继承关系的一种机制。每个对象都有一个原型对象，它包含了共享的属性和方法。当访问对象的属性或方法时，如果对象本身没有，则会沿着原型链向上查找。可以使用Object.create()方法或设置对象的__proto__属性来实现原型继承。</p><h5 id="6-解释JavaScript中的异步编程，并提供一个异步操作的示例。"><a href="#6-解释JavaScript中的异步编程，并提供一个异步操作的示例。" class="headerlink" title="6. 解释JavaScript中的异步编程，并提供一个异步操作的示例。"></a>6. 解释JavaScript中的异步编程，并提供一个异步操作的示例。</h5><p>​      异步编程是指在代码执行过程中，不会阻塞后续代码执行的一种编程方式。常见的异步操作包括网络请求、定时器等。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始&quot;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异步操作&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;结束&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="7-解释JavaScript中的闭包（Closure）是什么，并举例说明。"><a href="#7-解释JavaScript中的闭包（Closure）是什么，并举例说明。" class="headerlink" title="7. 解释JavaScript中的闭包（Closure）是什么，并举例说明。"></a>7. 解释JavaScript中的闭包（Closure）是什么，并举例说明。</h5><p>​      闭包是指函数可以访问并操作其词法作用域之外的变量。它通过在函数内部创建一个内部函数，并返回该内部函数来实现。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>  &#125;<br>  <span class="hljs-keyword">return</span> inner;<br>&#125;<br><br><span class="hljs-keyword">let</span> closure = <span class="hljs-title function_">outer</span>();<br><span class="hljs-title function_">closure</span>(); <span class="hljs-comment">// 输出 10</span><br></code></pre></td></tr></table></figure><h5 id="8-解释JavaScript中的this关键字的作用和使用场景。"><a href="#8-解释JavaScript中的this关键字的作用和使用场景。" class="headerlink" title="8. 解释JavaScript中的this关键字的作用和使用场景。"></a>8. 解释JavaScript中的this关键字的作用和使用场景。</h5><p>​      this关键字在JavaScript中表示当前执行上下文的对象。它的具体取值根据函数的调用方式而定。在全局作用域中，this指向全局对象（浏览器环境中为window对象）。在函数中，this的指向取决于函数的调用方式，可以通过call、apply、bind等方法来显式地指定this的值。</p><h5 id="9-解释JavaScript中的事件委托（Event-Delegation）是什么，并提供一个使用事件委托的示例。"><a href="#9-解释JavaScript中的事件委托（Event-Delegation）是什么，并提供一个使用事件委托的示例。" class="headerlink" title="9. 解释JavaScript中的事件委托（Event Delegation）是什么，并提供一个使用事件委托的示例。"></a>9. 解释JavaScript中的事件委托（Event Delegation）是什么，并提供一个使用事件委托的示例。</h5><p>​      事件委托是指将事件处理程序绑定到父元素上，而不是直接绑定到每个子元素上。当事件触发时，事件会冒泡到父元素，然后通过判断事件的目标来执行相应的处理逻辑。这样可以减少事件处理程序的数量，提高性能。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> &lt;ul id=<span class="hljs-string">&quot;list&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;list&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&quot;LI&quot;</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">textContent</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="10-解释JavaScript中的模块化编程，并提供一个使用模块的示例。"><a href="#10-解释JavaScript中的模块化编程，并提供一个使用模块的示例。" class="headerlink" title="10. 解释JavaScript中的模块化编程，并提供一个使用模块的示例。"></a>10. 解释JavaScript中的模块化编程，并提供一个使用模块的示例。</h5><p>​      模块化编程是指将代码划分为独立的模块，每个模块负责特定的功能，并通过导入和导出来实现模块之间的依赖关系。ES6引入了模块化的语法，可以使用import和export关键字来导入和导出模块。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; sayHello &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module.js&quot;</span>;<br><span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure><h5 id="11-解释JavaScript中的事件冒泡（Event-Bubbling）和事件捕获（Event-Capturing）。"><a href="#11-解释JavaScript中的事件冒泡（Event-Bubbling）和事件捕获（Event-Capturing）。" class="headerlink" title="11. 解释JavaScript中的事件冒泡（Event Bubbling）和事件捕获（Event Capturing）。"></a>11. 解释JavaScript中的事件冒泡（Event Bubbling）和事件捕获（Event Capturing）。</h5><p>​      事件冒泡是指当一个事件在DOM树中触发时，它会从最内层的元素开始向外传播至最外层的元素。事件捕获是指当一个事件在DOM树中触发时，它会从最外层的元素开始向内传播至最内层的元素。</p><h5 id="12-什么是原型链（Prototype-Chain）？如何利用原型链实现继承？"><a href="#12-什么是原型链（Prototype-Chain）？如何利用原型链实现继承？" class="headerlink" title="12. 什么是原型链（Prototype Chain）？如何利用原型链实现继承？"></a>12. 什么是原型链（Prototype Chain）？如何利用原型链实现继承？</h5><p>​      原型链是JavaScript中对象之间的连接关系，每个对象都有一个指向其原型（prototype）的引用。通过原型链，对象可以继承其原型对象的属性和方法。可以使用原型链实现继承，通过将一个对象的原型指向另一个对象，从而使得该对象可以访问另一个对象的属性和方法。</p><h5 id="13-解释JavaScript中的防抖（Debounce）和节流（Throttle）。"><a href="#13-解释JavaScript中的防抖（Debounce）和节流（Throttle）。" class="headerlink" title="13. 解释JavaScript中的防抖（Debounce）和节流（Throttle）。"></a>13. 解释JavaScript中的防抖（Debounce）和节流（Throttle）。</h5><p>​      防抖和节流都是用于控制函数执行频率的技术。防抖指的是在某个时间段内，只执行最后一次触发的函数调用。节流指的是在某个时间段内，按照固定的时间间隔执行函数调用。</p><h5 id="14-什么是事件循环（Event-Loop）？请解释JavaScript中的事件循环机制。"><a href="#14-什么是事件循环（Event-Loop）？请解释JavaScript中的事件循环机制。" class="headerlink" title="14. 什么是事件循环（Event Loop）？请解释JavaScript中的事件循环机制。"></a>14. 什么是事件循环（Event Loop）？请解释JavaScript中的事件循环机制。</h5><p>​      事件循环是JavaScript中处理异步操作的机制。事件循环不断地从任务队列中取出任务并执行，直到任务队列为空。事件循环由主线程和任务队列组成，主线程负责执行同步任务，异步任务会被放入任务队列中，等待主线程空闲时被执行。</p><h5 id="15-解释JavaScript中的深拷贝和浅拷贝。"><a href="#15-解释JavaScript中的深拷贝和浅拷贝。" class="headerlink" title="15. 解释JavaScript中的深拷贝和浅拷贝。"></a>15. 解释JavaScript中的深拷贝和浅拷贝。</h5><p>​      深拷贝是指创建一个新对象，将原始对象的所有属性和嵌套对象的属性都复制到新对象中。浅拷贝是指创建一个新对象，将原始对象的属性复制到新对象中，但嵌套对象的引用仍然是共享的。</p><h5 id="16-什么是异步编程？请列举几种处理异步操作的方法。"><a href="#16-什么是异步编程？请列举几种处理异步操作的方法。" class="headerlink" title="16. 什么是异步编程？请列举几种处理异步操作的方法。"></a>16. 什么是异步编程？请列举几种处理异步操作的方法。</h5><p>​      异步编程是一种处理可能耗时的操作而不阻塞主线程的编程方式。常见的处理异步操作的方法有回调函数、Promise、async&#x2F;await和事件监听等。</p><h5 id="17-解释JavaScript中的Hoisting（变量提升）。"><a href="#17-解释JavaScript中的Hoisting（变量提升）。" class="headerlink" title="17. 解释JavaScript中的Hoisting（变量提升）。"></a>17. 解释JavaScript中的Hoisting（变量提升）。</h5><p>​      变量提升是指在JavaScript中，变量和函数的声明会被提升到当前作用域的顶部。这意味着可以在声明之前使用变量和函数，但它们的赋值或定义仍然在原来的位置。</p><h5 id="18-什么是柯里化（Currying）？请给出一个柯里化的示例。"><a href="#18-什么是柯里化（Currying）？请给出一个柯里化的示例。" class="headerlink" title="18. 什么是柯里化（Currying）？请给出一个柯里化的示例。"></a>18. 什么是柯里化（Currying）？请给出一个柯里化的示例。</h5><p>​      柯里化是一种将接受多个参数的函数转换为接受一个参数并返回一个新函数的过程。示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> add5 = <span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add5</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出：8</span><br></code></pre></td></tr></table></figure><h5 id="19-解释JavaScript中的严格模式（Strict-Mode）。"><a href="#19-解释JavaScript中的严格模式（Strict-Mode）。" class="headerlink" title="19. 解释JavaScript中的严格模式（Strict Mode）。"></a>19. 解释JavaScript中的严格模式（Strict Mode）。</h5><p>​      严格模式是一种JavaScript的执行模式，它提供了更严格的语法和错误检查。在严格模式下，一些不安全或不推荐的语法会被禁用，同时会引入一些新的特性，如变量必须先声明才能使用、禁止使用this指向全局对象等。</p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h5 id="1-解释TypeScript和JavaScript之间的关系。"><a href="#1-解释TypeScript和JavaScript之间的关系。" class="headerlink" title="1. 解释TypeScript和JavaScript之间的关系。"></a>1. 解释TypeScript和JavaScript之间的关系。</h5><p>​      TypeScript是JavaScript的超集，它添加了静态类型和其他一些特性。TypeScript代码可以编译成JavaScript代码，因此可以在任何支持JavaScript的环境中运行。</p><h5 id="2-TypeScript中的类型注解是什么？如何使用类型注解？"><a href="#2-TypeScript中的类型注解是什么？如何使用类型注解？" class="headerlink" title="2. TypeScript中的类型注解是什么？如何使用类型注解？"></a>2. TypeScript中的类型注解是什么？如何使用类型注解？</h5><p>​      类型注解是指在变量、函数参数、函数返回值等地方显式地声明类型信息。可以使用冒号（:）后跟类型来添加类型注解。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">num</span>: number = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: number, b: number</span>): number &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-TypeScript中的接口是什么？如何定义和使用接口？"><a href="#3-TypeScript中的接口是什么？如何定义和使用接口？" class="headerlink" title="3. TypeScript中的接口是什么？如何定义和使用接口？"></a>3. TypeScript中的接口是什么？如何定义和使用接口？</h5><p>​      接口是一种用于定义对象的结构和类型的语法。可以使用interface关键字来定义接口。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">interface <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">person: Person</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;person.name&#125;</span>!`</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">john</span>: <span class="hljs-title class_">Person</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-title function_">greet</span>(john); <span class="hljs-comment">// 输出 &quot;Hello, John!&quot;</span><br></code></pre></td></tr></table></figure><h5 id="4-TypeScript中的类是什么？如何定义和使用类？"><a href="#4-TypeScript中的类是什么？如何定义和使用类？" class="headerlink" title="4. TypeScript中的类是什么？如何定义和使用类？"></a>4. TypeScript中的类是什么？如何定义和使用类？</h5><p>​      类是一种用于创建对象的蓝图，它包含属性和方法。可以使用class关键字来定义类。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: string, age: number</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>!`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">25</span>);<br>john.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;Hello, John!&quot;</span><br></code></pre></td></tr></table></figure><h5 id="5-TypeScript中的泛型是什么？如何使用泛型？"><a href="#5-TypeScript中的泛型是什么？如何使用泛型？" class="headerlink" title="5. TypeScript中的泛型是什么？如何使用泛型？"></a>5. TypeScript中的泛型是什么？如何使用泛型？</h5><p>​      泛型是一种用于创建可重用代码的工具，它允许在定义函数、类或接口时使用占位符类型。可以使用尖括号（&lt;&gt;）来指定泛型类型。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">value</span>: T): T &#123;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-keyword">let</span> result = identity&lt;string&gt;(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><h5 id="6-TypeScript中的枚举是什么？如何定义和使用枚举？"><a href="#6-TypeScript中的枚举是什么？如何定义和使用枚举？" class="headerlink" title="6. TypeScript中的枚举是什么？如何定义和使用枚举？"></a>6. TypeScript中的枚举是什么？如何定义和使用枚举？</h5><p>​      枚举是一种用于定义命名常量集合的语法。可以使用enum关键字来定义枚举。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">enum <span class="hljs-title class_">Color</span> &#123;<br>  <span class="hljs-title class_">Red</span>,<br>  <span class="hljs-title class_">Green</span>,<br>  <span class="hljs-title class_">Blue</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(color); <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure><h5 id="7-TypeScript中的模块是什么？如何导出和导入模块？"><a href="#7-TypeScript中的模块是什么？如何导出和导入模块？" class="headerlink" title="7. TypeScript中的模块是什么？如何导出和导入模块？"></a>7. TypeScript中的模块是什么？如何导出和导入模块？</h5><p>​      模块是用于组织和封装代码的单元。可以使用export关键字将模块中的变量、函数、类等导出，以便其他模块可以使用。可以使用import关键字来导入其他模块的导出。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// module.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name: string</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br><br><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">import</span> &#123; greet &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module&quot;</span>;<br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// 输出 &quot;Hello, John!&quot;</span><br></code></pre></td></tr></table></figure><h5 id="8-TypeScript中的类型推断是什么？如何使用类型推断？"><a href="#8-TypeScript中的类型推断是什么？如何使用类型推断？" class="headerlink" title="8. TypeScript中的类型推断是什么？如何使用类型推断？"></a>8. TypeScript中的类型推断是什么？如何使用类型推断？</h5><p>​      类型推断是指TypeScript根据上下文自动推断变量的类型，而无需显式地添加类型注解。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>; <span class="hljs-comment">// 推断为 number 类型</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 推断为 string 类型</span><br></code></pre></td></tr></table></figure><h5 id="9-TypeScript中的命名空间是什么？如何定义和使用命名空间？"><a href="#9-TypeScript中的命名空间是什么？如何定义和使用命名空间？" class="headerlink" title="9. TypeScript中的命名空间是什么？如何定义和使用命名空间？"></a>9. TypeScript中的命名空间是什么？如何定义和使用命名空间？</h5><p>​      命名空间是一种用于组织和封装代码的机制，它避免了全局命名冲突。可以使用namespace关键字来定义命名空间。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">namespace <span class="hljs-title class_">MyNamespace</span> &#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name: string</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">MyNamespace</span>.<span class="hljs-title function_">greet</span>(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// 输出 &quot;Hello, John!&quot;</span><br></code></pre></td></tr></table></figure><h5 id="10-TypeScript中的类型别名是什么？如何定义和使用类型别名？"><a href="#10-TypeScript中的类型别名是什么？如何定义和使用类型别名？" class="headerlink" title="10. TypeScript中的类型别名是什么？如何定义和使用类型别名？"></a>10. TypeScript中的类型别名是什么？如何定义和使用类型别名？</h5><p>​      类型别名是给类型起一个别名，以便在代码中更方便地引用。可以使用type关键字来定义类型别名。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">type <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: number; <span class="hljs-attr">y</span>: number &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printPoint</span>(<span class="hljs-params">point: Point</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`(<span class="hljs-subst">$&#123;point.x&#125;</span>, <span class="hljs-subst">$&#123;point.y&#125;</span>)`</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-title function_">printPoint</span>(p); <span class="hljs-comment">// 输出 &quot;(1, 2)&quot;</span><br></code></pre></td></tr></table></figure><h2 id="VUE2"><a href="#VUE2" class="headerlink" title="VUE2"></a>VUE2</h2><h5 id="1-Vue-js是什么？它有哪些特点？"><a href="#1-Vue-js是什么？它有哪些特点？" class="headerlink" title="1. Vue.js是什么？它有哪些特点？"></a>1. Vue.js是什么？它有哪些特点？</h5><p>​      Vue.js是一个用于构建用户界面的JavaScript框架。它具有以下特点：</p><p>响应式数据绑定：通过使用Vue的数据绑定语法，可以实现数据的自动更新。 组件化开发：Vue允许将页面划分为独立的组件，提高了代码的可维护性和复用性。 虚拟DOM：Vue使用虚拟DOM来跟踪页面上的变化，并高效地更新实际的DOM。 指令系统：Vue提供了丰富的内置指令，用于处理常见的DOM操作和逻辑控制。 生态系统：Vue拥有庞大的生态系统，包括插件、工具和第三方库，可以满足各种开发需求。</p><h5 id="2-Vue中的双向数据绑定是如何实现的？"><a href="#2-Vue中的双向数据绑定是如何实现的？" class="headerlink" title="2. Vue中的双向数据绑定是如何实现的？"></a>2. Vue中的双向数据绑定是如何实现的？</h5><p>​      Vue中的双向数据绑定是通过v-model指令实现的。v-model可以在表单元素（如、、）上创建双向数据绑定。当用户输入改变表单元素的值时，数据模型会自动更新；反之，当数据模型的值改变时，表单元素也会自动更新。</p><h5 id="3-Vue中的生命周期钩子有哪些？它们的执行顺序是怎样的？"><a href="#3-Vue中的生命周期钩子有哪些？它们的执行顺序是怎样的？" class="headerlink" title="3. Vue中的生命周期钩子有哪些？它们的执行顺序是怎样的？"></a>3. Vue中的生命周期钩子有哪些？它们的执行顺序是怎样的？</h5><p>​      Vue中的生命周期钩子包括beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy和destroyed。它们的执行顺序如下：</p><p>beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed</p><h5 id="4-Vue中的计算属性和监听器有什么区别？"><a href="#4-Vue中的计算属性和监听器有什么区别？" class="headerlink" title="4. Vue中的计算属性和监听器有什么区别？"></a>4. Vue中的计算属性和监听器有什么区别？</h5><p>​      计算属性是基于依赖的属性，它根据其依赖的数据动态计算得出值。计算属性具有缓存机制，只有在依赖的数据发生变化时才会重新计算。监听器是用于监听数据的变化并执行相应的操作。当数据发生变化时，监听器会立即执行指定的回调函数。</p><h5 id="5-Vue中的组件通信有哪些方式？"><a href="#5-Vue中的组件通信有哪些方式？" class="headerlink" title="5. Vue中的组件通信有哪些方式？"></a>5. Vue中的组件通信有哪些方式？</h5><p>​      Vue中的组件通信方式包括：</p><p>父子组件通信：通过props向子组件传递数据，子组件通过事件向父组件发送消息。 子父组件通信：子组件通过$emit触发事件，父组件通过监听事件并响应。 兄弟组件通信：通过共享的父组件来传递数据或通过事件总线（Event Bus）进行通信。 跨级组件通信：通过provide和inject来在祖先组件中提供数据，然后在后代组件中使用。</p><h5 id="6-Vue中的路由是如何实现的？"><a href="#6-Vue中的路由是如何实现的？" class="headerlink" title="6. Vue中的路由是如何实现的？"></a>6. Vue中的路由是如何实现的？</h5><p>​      Vue中的路由是通过Vue Router实现的。Vue Router是Vue.js官方提供的路由管理器，它允许开发者在Vue应用中实现单页面应用（SPA）。Vue Router通过配置路由映射关系，将URL路径与组件进行关联，并提供导航功能，使用户可以在不刷新页面的情况下切换视图。</p><h5 id="7-Vue中的指令有哪些？举例说明它们的用法。"><a href="#7-Vue中的指令有哪些？举例说明它们的用法。" class="headerlink" title="7. Vue中的指令有哪些？举例说明它们的用法。"></a>7. Vue中的指令有哪些？举例说明它们的用法。</h5><p>​      Vue中常用的指令包括：</p><p>v-if：根据表达式的值条件性地渲染元素。 v-for：根据数组或对象的数据进行循环渲染。 v-bind：用于动态绑定属性或响应式地更新属性。 v-on：用于监听DOM事件并执行相应的方法。 v-model：用于在表单元素上实现双向数据绑定。 例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> &lt;div v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;显示内容&lt;/div&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><br>&lt;img v-bind:src=&quot;imageUrl&quot;&gt;<br><br>&lt;button v-on:click=&quot;handleClick&quot;&gt;点击按钮&lt;/button&gt;<br><br>&lt;input v-model=&quot;message&quot;&gt;<br></code></pre></td></tr></table></figure><h5 id="8-Vue中的watch和computed有什么区别？"><a href="#8-Vue中的watch和computed有什么区别？" class="headerlink" title="8. Vue中的watch和computed有什么区别？"></a>8. Vue中的watch和computed有什么区别？</h5><p>​      watch和computed都可以用于监听数据的变化，但它们的用法和实现方式略有不同。watch用于监听指定的数据变化，并在数据变化时执行相应的操作。computed用于根据依赖的数据动态计算得出一个新的值，并将该值缓存起来，只有在依赖的数据发生变化时才会重新计算。</p><h5 id="9-Vue中的mixin是什么？它有什么作用？"><a href="#9-Vue中的mixin是什么？它有什么作用？" class="headerlink" title="9. Vue中的mixin是什么？它有什么作用？"></a>9. Vue中的mixin是什么？它有什么作用？</h5><p>​      Mixin是一种用于在多个组件之间共享代码的方式。Mixin可以包含组件选项（如数据、方法、生命周期钩子等），并将其合并到使用Mixin的组件中。这样可以实现代码的复用和组件的扩展，减少重复编写相似代码的工作。</p><h5 id="10-Vue中的keep-alive是什么？它有什么作用？"><a href="#10-Vue中的keep-alive是什么？它有什么作用？" class="headerlink" title="10. Vue中的keep-alive是什么？它有什么作用？"></a>10. Vue中的keep-alive是什么？它有什么作用？</h5><p>​      是Vue中的一个内置组件，用于缓存动态组件。当组件包裹在中时，组件的状态将被保留，包括它的实例、状态和DOM结构。这样可以避免在组件切换时重复创建和销毁组件，提高性能和用户体验。</p><h5 id="11-请解释Vue-js中的依赖注入（Dependency-Injection）是什么？它在Vue中的应用场景是什么？"><a href="#11-请解释Vue-js中的依赖注入（Dependency-Injection）是什么？它在Vue中的应用场景是什么？" class="headerlink" title="11. 请解释Vue.js中的依赖注入（Dependency Injection）是什么？它在Vue中的应用场景是什么？"></a>11. 请解释Vue.js中的依赖注入（Dependency Injection）是什么？它在Vue中的应用场景是什么？</h5><p>​      依赖注入是一种设计模式，用于将依赖关系从一个组件传递到另一个组件。在Vue中，依赖注入通过provide和inject选项实现。父组件通过provide提供数据，然后子组件通过inject注入这些数据。它在跨多个层级的组件通信中非常有用。</p><h5 id="12-Vue-js中的渲染函数（Render-Function）是什么？它与模板（Template）有什么区别？"><a href="#12-Vue-js中的渲染函数（Render-Function）是什么？它与模板（Template）有什么区别？" class="headerlink" title="12. Vue.js中的渲染函数（Render Function）是什么？它与模板（Template）有什么区别？"></a>12. Vue.js中的渲染函数（Render Function）是什么？它与模板（Template）有什么区别？</h5><p>​      渲染函数是一种用JavaScript代码编写组件的方式，它可以动态地生成虚拟DOM。与模板相比，渲染函数提供了更大的灵活性和控制力，可以处理更复杂的逻辑和动态渲染需求。</p><h5 id="13-Vue-js中的插槽（Slot）是什么？请提供一个具有命名插槽和作用域插槽的示例。"><a href="#13-Vue-js中的插槽（Slot）是什么？请提供一个具有命名插槽和作用域插槽的示例。" class="headerlink" title="13. Vue.js中的插槽（Slot）是什么？请提供一个具有命名插槽和作用域插槽的示例。"></a>13. Vue.js中的插槽（Slot）是什么？请提供一个具有命名插槽和作用域插槽的示例。</h5><p>​      插槽是一种用于在组件中扩展内容的机制。命名插槽允许父组件向子组件插入具有特定名称的内容，而作用域插槽允许子组件将数据传递给父组件。示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- 父组件 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>&lt;!-- 子组件 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span>默认标题<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;computedData&quot;</span>&gt;</span>&#123;&#123; computedData &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="14-Vue-js中的动画系统是如何工作的？请提供一个简单的动画示例。"><a href="#14-Vue-js中的动画系统是如何工作的？请提供一个简单的动画示例。" class="headerlink" title="14. Vue.js中的动画系统是如何工作的？请提供一个简单的动画示例。"></a>14. Vue.js中的动画系统是如何工作的？请提供一个简单的动画示例。</h5><p>​      Vue.js的动画系统通过CSS过渡和动画类实现。通过在元素上添加过渡类或动画类，可以触发相应的过渡效果或动画效果。示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> &lt;transition name=<span class="hljs-string">&quot;fade&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>显示内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/transition&gt;<br><br>&lt;!-- <span class="hljs-variable constant_">CSS</span>样式 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.fade-enter-active</span>, <span class="hljs-selector-class">.fade-leave-active</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.5s</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.fade-enter</span>, <span class="hljs-selector-class">.fade-leave-to</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="15-Vue-js中的错误处理机制是什么？如何捕获和处理Vue组件中的错误？"><a href="#15-Vue-js中的错误处理机制是什么？如何捕获和处理Vue组件中的错误？" class="headerlink" title="15. Vue.js中的错误处理机制是什么？如何捕获和处理Vue组件中的错误？"></a>15. Vue.js中的错误处理机制是什么？如何捕获和处理Vue组件中的错误？</h5><p>​      Vue.js提供了全局的错误处理机制和组件级别的错误处理机制。全局错误处理可以通过errorCaptured钩子函数捕获和处理错误。组件级别的错误处理可以通过errorCaptured钩子函数或errorHandler选项捕获和处理错误。</p><h5 id="16-Vue-js中的服务端渲染（SSR）是什么？它有哪些优势和限制？"><a href="#16-Vue-js中的服务端渲染（SSR）是什么？它有哪些优势和限制？" class="headerlink" title="16. Vue.js中的服务端渲染（SSR）是什么？它有哪些优势和限制？"></a>16. Vue.js中的服务端渲染（SSR）是什么？它有哪些优势和限制？</h5><p>​      服务端渲染是指在服务器上生成HTML内容并将其发送到浏览器进行渲染的过程。Vue.js可以进行服务端渲染，提供更好的首次加载性能和SEO优化。然而，服务端渲染也带来了一些限制，如增加了服务器负载和开发复杂性。</p><h5 id="17-Vue-js中的响应式数组有哪些限制？如何解决这些限制？"><a href="#17-Vue-js中的响应式数组有哪些限制？如何解决这些限制？" class="headerlink" title="17. Vue.js中的响应式数组有哪些限制？如何解决这些限制？"></a>17. Vue.js中的响应式数组有哪些限制？如何解决这些限制？</h5><p>​      Vue.js的响应式系统对于数组的变异方法（如push、pop、splice等）是无法追踪的。为了解决这个限制，Vue提供了一些特殊的方法，如Vue.set、vm.$set和Array.prototype.splice。这些方法可以用于更新数组并保持响应式。</p><h5 id="18-Vue-js中的性能优化有哪些常见的技巧？"><a href="#18-Vue-js中的性能优化有哪些常见的技巧？" class="headerlink" title="18. Vue.js中的性能优化有哪些常见的技巧？"></a>18. Vue.js中的性能优化有哪些常见的技巧？</h5><p>​      常见的Vue.js性能优化技巧包括：</p><p>使用v-if和v-for时注意避免不必要的渲染。 合理使用computed属性和watch监听器。 使用keep-alive组件缓存组件状态。 使用异步组件进行按需加载。 避免在模板中使用复杂的表达式。 使用key属性管理组件和元素的复用。 合理使用懒加载和分割代码。</p><h5 id="19-Vue-js中的路由导航守卫有哪些？它们的执行顺序是怎样的？"><a href="#19-Vue-js中的路由导航守卫有哪些？它们的执行顺序是怎样的？" class="headerlink" title="19. Vue.js中的路由导航守卫有哪些？它们的执行顺序是怎样的？"></a>19. Vue.js中的路由导航守卫有哪些？它们的执行顺序是怎样的？</h5><p>​      Vue.js中的路由导航守卫包括全局前置守卫、全局解析守卫、全局后置守卫、路由独享守卫和组件内守卫。它们的执行顺序如下：</p><p>全局前置守卫（beforeEach） 路由独享守卫（beforeEnter） 解析守卫（beforeResolve） 组件内守卫（beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave） 全局后置守卫（afterEach）</p><h5 id="20-Vue-js中的单元测试是如何进行的？请提供一个简单的单元测试示例。"><a href="#20-Vue-js中的单元测试是如何进行的？请提供一个简单的单元测试示例。" class="headerlink" title="20. Vue.js中的单元测试是如何进行的？请提供一个简单的单元测试示例。"></a>20. Vue.js中的单元测试是如何进行的？请提供一个简单的单元测试示例。</h5><p>​      Vue.js的单元测试可以使用工具如Jest或Mocha进行。示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 组件代码</span><br><span class="hljs-comment">// MyComponent.vue</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my-component&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>增加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">// 单元测试代码</span><br><span class="hljs-comment">// MyComponent.spec.js</span><br><span class="hljs-keyword">import</span> &#123; shallowMount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vue/test-utils&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyComponent.vue&#x27;</span><br><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;MyComponent&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;renders message correctly&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallowMount</span>(<span class="hljs-title class_">MyComponent</span>)<br>    <span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;span&#x27;</span>).<span class="hljs-title function_">text</span>()).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>  &#125;)<br><br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;increments count when button is clicked&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallowMount</span>(<span class="hljs-title class_">MyComponent</span>)<br>    wrapper.<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;button&#x27;</span>).<span class="hljs-title function_">trigger</span>(<span class="hljs-string">&#x27;click&#x27;</span>)<br>    <span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-property">vm</span>.<span class="hljs-property">count</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">1</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="VUE3"><a href="#VUE3" class="headerlink" title="VUE3"></a>VUE3</h2><h5 id="1-Vue-js-3中的Composition-API是什么？它与Options-API有什么区别？"><a href="#1-Vue-js-3中的Composition-API是什么？它与Options-API有什么区别？" class="headerlink" title="1. Vue.js 3中的Composition API是什么？它与Options API有什么区别？"></a>1. Vue.js 3中的Composition API是什么？它与Options API有什么区别？</h5><p>​      Composition API是Vue.js 3中引入的一种新的组织组件逻辑的方式。它允许开发者通过函数的方式组织和重用逻辑，而不是通过选项对象。相比之下，Options API是Vue.js 2中常用的组织组件逻辑的方式，通过选项对象中的属性来定义组件的数据、方法等。</p><h5 id="2-Vue-js-3中的Teleport是什么？请给出一个Teleport的示例。"><a href="#2-Vue-js-3中的Teleport是什么？请给出一个Teleport的示例。" class="headerlink" title="2. Vue.js 3中的Teleport是什么？请给出一个Teleport的示例。"></a>2. Vue.js 3中的Teleport是什么？请给出一个Teleport的示例。</h5><p>​      Teleport是Vue.js 3中引入的一种机制，用于将组件的内容渲染到DOM树中的任意位置。示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> &lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showModal = true&quot;</span>&gt;</span>打开模态框<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">modal</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showModal&quot;</span> @<span class="hljs-attr">close</span>=<span class="hljs-string">&quot;showModal = false&quot;</span>&gt;</span>模态框内容<span class="hljs-tag">&lt;/<span class="hljs-name">modal</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h5 id="3-Vue-js-3中的响应式系统是如何工作的？它与Vue-js-2中的响应式系统有什么区别？"><a href="#3-Vue-js-3中的响应式系统是如何工作的？它与Vue-js-2中的响应式系统有什么区别？" class="headerlink" title="3. Vue.js 3中的响应式系统是如何工作的？它与Vue.js 2中的响应式系统有什么区别？"></a>3. Vue.js 3中的响应式系统是如何工作的？它与Vue.js 2中的响应式系统有什么区别？</h5><p>​      Vue.js 3中的响应式系统使用了Proxy对象来实现。与Vue.js 2中的响应式系统相比，Vue.js 3的响应式系统具有更好的性能和更细粒度的追踪，能够更准确地检测到数据的变化，并且支持嵌套的响应式数据。</p><h5 id="4-Vue-js-3中的Suspense是什么？它的作用是什么？"><a href="#4-Vue-js-3中的Suspense是什么？它的作用是什么？" class="headerlink" title="4. Vue.js 3中的Suspense是什么？它的作用是什么？"></a>4. Vue.js 3中的Suspense是什么？它的作用是什么？</h5><p>​      Suspense是Vue.js 3中引入的一种机制，用于处理异步组件的加载状态。它可以在异步组件加载完成之前显示一个占位符，并在加载完成后渲染异步组件的内容。这样可以更好地处理异步组件的加载过程，提供更好的用户体验。</p><h5 id="5-Vue-js-3中的provide和inject有什么作用？请给出一个provide和inject的示例。"><a href="#5-Vue-js-3中的provide和inject有什么作用？请给出一个provide和inject的示例。" class="headerlink" title="5. Vue.js 3中的provide和inject有什么作用？请给出一个provide和inject的示例。"></a>5. Vue.js 3中的provide和inject有什么作用？请给出一个provide和inject的示例。</h5><p>​      provide和inject用于实现组件之间的依赖注入。通过在父组件中使用provide提供数据，然后在子组件中使用inject注入这些数据。示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">      <span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Parent</span> = &#123;<br>  <span class="hljs-attr">provide</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>  &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 子组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = &#123;<br>  <span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;message&#x27;</span>],<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>); <span class="hljs-comment">// 输出：Hello</span><br>  &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-Vue-js-3中的动画系统有哪些改进？请列举几个改进之处。"><a href="#6-Vue-js-3中的动画系统有哪些改进？请列举几个改进之处。" class="headerlink" title="6. Vue.js 3中的动画系统有哪些改进？请列举几个改进之处。"></a>6. Vue.js 3中的动画系统有哪些改进？请列举几个改进之处。</h5><p>​      Vue.js 3中的动画系统相比Vue.js 2有以下改进之处：</p><p>更好的性能：Vue.js 3的动画系统使用了更高效的动画引擎，提供了更好的性能。 更简洁的语法：Vue.js 3的动画系统使用了更简洁的语法，使得动画的定义和使用更加直观和方便。 支持更多的动画特性：Vue.js 3的动画系统支持更多的动画特性，如交互式动画和更复杂的动画效果。</p><p> Vue.js 3中的静态提升（Static Tree Hoisting）是什么？它有什么优势？ 答案：静态提升是Vue.js 3中的一项优化技术，通过在编译阶段将静态节点提升为常量，从而减少了运行时的开销。这项优化技术可以提高组件的渲染性能，并减少生成的代码体积。</p><h5 id="7-Vue-js-3中的Fragment是什么？它的作用是什么？"><a href="#7-Vue-js-3中的Fragment是什么？它的作用是什么？" class="headerlink" title="7. Vue.js 3中的Fragment是什么？它的作用是什么？"></a>7. Vue.js 3中的Fragment是什么？它的作用是什么？</h5><p>​      Fragment是Vue.js 3中引入的一种机制，用于在组件中返回多个根节点。在Vue.js 2中，组件的模板只能有一个 Vue.js 3中的Composition API中的ref和reactive有什么区别？什么时候使用哪个？       ref用于创建一个响应式的基本数据类型，而reactive用于创建一个响应式的对象。当需要创建一个简单的响应式数据时，可以使用ref，当需要创建一个包含多个属性的响应式对象时，可以使用reactive。</p><h5 id="8-Vue-js-3中的watchEffect和watch有什么区别？什么时候使用哪个？"><a href="#8-Vue-js-3中的watchEffect和watch有什么区别？什么时候使用哪个？" class="headerlink" title="8. Vue.js 3中的watchEffect和watch有什么区别？什么时候使用哪个？"></a>8. Vue.js 3中的watchEffect和watch有什么区别？什么时候使用哪个？</h5><p>​      watchEffect用于监听响应式数据的变化，并在回调函数中执行相应的操作。它会自动追踪依赖，并在依赖变化时重新运行回调函数。watch用于监听指定的响应式数据，并在其变化时执行相应的操作。它可以精确地指定要监听的数据，并提供更多的配置选项。一般来说，如果只需要监听一个响应式数据的变化并执行相应操作，可以使用watchEffect；如果需要更细粒度的控制，可以使用watch。</p><h5 id="9-Vue-js-3中的v-model指令在使用时有哪些注意事项？"><a href="#9-Vue-js-3中的v-model指令在使用时有哪些注意事项？" class="headerlink" title="9. Vue.js 3中的v-model指令在使用时有哪些注意事项？"></a>9. Vue.js 3中的v-model指令在使用时有哪些注意事项？</h5><p>​      在使用v-model指令时，有以下注意事项：</p><p>v-model指令必须与一个表单元素一起使用，如、、等。 当使用自定义组件时，组件内部必须实现modelValue属性和update:modelValue事件，以支持v-model的双向绑定。 可以使用.lazy修饰符实现在输入框失去焦点时更新数据。 可以使用.trim修饰符自动去除输入框内容的首尾空格。 可以使用.number修饰符将输入框的值转换为数字类型。</p><h5 id="10-Vue-js-3中的provide和inject是否支持响应式数据？"><a href="#10-Vue-js-3中的provide和inject是否支持响应式数据？" class="headerlink" title="10. Vue.js 3中的provide和inject是否支持响应式数据？"></a>10. Vue.js 3中的provide和inject是否支持响应式数据？</h5><p>​      默认情况下，provide和inject不支持响应式数据。如果需要在provide中提供一个响应式数据，可以使用ref或reactive将数据包装起来。然后在inject中使用toRefs或toRef将数据解构出来，以获取响应式的引用。</p><h5 id="11-Vue-js-3中的nextTick方法有什么作用？在什么情况下使用它？"><a href="#11-Vue-js-3中的nextTick方法有什么作用？在什么情况下使用它？" class="headerlink" title="11. Vue.js 3中的nextTick方法有什么作用？在什么情况下使用它？"></a>11. Vue.js 3中的nextTick方法有什么作用？在什么情况下使用它？</h5><p>​      nextTick方法用于在下次DOM更新循环结束之后执行回调函数。它可以用来确保在更新DOM后执行某些操作，如操作更新后的DOM元素或获取更新后的计算属性的值。通常在需要等待DOM更新完成后进行操作的情况下使用nextTick。</p><h5 id="12-Vue-js-3中的和组件有什么区别？"><a href="#12-Vue-js-3中的和组件有什么区别？" class="headerlink" title="12. Vue.js 3中的和组件有什么区别？"></a>12. Vue.js 3中的和组件有什么区别？</h5><p>​      组件用于将组件的内容渲染到DOM树中的任意位置，而组件用于在组件进入或离开DOM树时应用过渡效果。主要用于组件的位置移动，而主要用于组件的显示和隐藏过渡。</p><h5 id="13-Vue-js-3中的v-for指令中的key属性有什么作用？为什么要使用它？"><a href="#13-Vue-js-3中的v-for指令中的key属性有什么作用？为什么要使用它？" class="headerlink" title="13. Vue.js 3中的v-for指令中的key属性有什么作用？为什么要使用它？"></a>13. Vue.js 3中的v-for指令中的key属性有什么作用？为什么要使用它？</h5><p>​      v-for指令中的key属性用于给每个迭代项设置一个唯一的标识符。它的作用是帮助Vue.js跟踪每个节点的身份，以便在数据发生变化时高效地更新DOM。使用key属性可以避免出现错误的节点更新或重新排序的问题。</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h5 id="1-什么是React？它的核心概念是什么？"><a href="#1-什么是React？它的核心概念是什么？" class="headerlink" title="1. 什么是React？它的核心概念是什么？"></a>1. 什么是React？它的核心概念是什么？</h5><p>​      React是一个用于构建用户界面的JavaScript库。它的核心概念是组件化和声明式编程。React将用户界面拆分为独立的可重用组件，并使用声明式语法描述组件的状态和UI的关系，使得构建复杂的UI变得简单和可维护。</p><h5 id="2-什么是JSX？它与HTML有什么区别？"><a href="#2-什么是JSX？它与HTML有什么区别？" class="headerlink" title="2. 什么是JSX？它与HTML有什么区别？"></a>2. 什么是JSX？它与HTML有什么区别？</h5><p>​      JSX是一种JavaScript的语法扩展，用于在React中描述UI的结构。它类似于HTML，但有一些区别：</p><h5 id="3-什么是React组件？它们有哪两种类型？"><a href="#3-什么是React组件？它们有哪两种类型？" class="headerlink" title="3. 什么是React组件？它们有哪两种类型？"></a>3. 什么是React组件？它们有哪两种类型？</h5><p>​      React组件是构建用户界面的独立单元。React组件有两种类型：</p><p>函数组件：使用函数来定义组件，接收props作为参数，并返回一个React元素。 类组件：使用ES6类来定义组件，继承自React.Component类，通过render方法返回一个React元素。</p><h5 id="4-什么是状态（state）和属性（props）？它们之间有什么区别？"><a href="#4-什么是状态（state）和属性（props）？它们之间有什么区别？" class="headerlink" title="4. 什么是状态（state）和属性（props）？它们之间有什么区别？"></a>4. 什么是状态（state）和属性（props）？它们之间有什么区别？</h5><p>​      状态（state）是组件自身管理的数据，可以通过setState方法来更新。属性（props）是从父组件传递给子组件的数据，子组件无法直接修改props，只能通过父组件的更新来改变props。</p><p>区别：</p><p>状态（state）是组件内部的数据，可以在组件中自由修改和管理。 属性（props）是从父组件传递给子组件的数据，子组件无法直接修改，只能接收和使用。</p><h5 id="5-什么是React生命周期方法？列举一些常用的生命周期方法。"><a href="#5-什么是React生命周期方法？列举一些常用的生命周期方法。" class="headerlink" title="5. 什么是React生命周期方法？列举一些常用的生命周期方法。"></a>5. 什么是React生命周期方法？列举一些常用的生命周期方法。</h5><p>​      React生命周期方法是在组件不同阶段执行的特定方法。以下是一些常用的React生命周期方法：</p><p>componentDidMount：组件挂载后立即调用。 componentDidUpdate：组件更新后调用。 componentWillUnmount：组件卸载前调用。 shouldComponentUpdate：决定组件是否需要重新渲染。 getDerivedStateFromProps：根据props的变化来更新状态。</p><h5 id="6-什么是React-Hooks？它们的作用是什么？"><a href="#6-什么是React-Hooks？它们的作用是什么？" class="headerlink" title="6. 什么是React Hooks？它们的作用是什么？"></a>6. 什么是React Hooks？它们的作用是什么？</h5><p>​      React Hooks是React 16.8版本引入的一种特性，用于在函数组件中使用状态和其他React特性。Hooks提供了一种无需编写类组件的方式来管理状态和处理副作用，使得函数组件具有类组件的能力。</p><h5 id="7-什么是React-Router？它的作用是什么？"><a href="#7-什么是React-Router？它的作用是什么？" class="headerlink" title="7. 什么是React Router？它的作用是什么？"></a>7. 什么是React Router？它的作用是什么？</h5><p>​      React Router是React中用于处理路由的库。它提供了一种在单页面应用中实现导航和路由功能的方式。React Router可以帮助开发者实现页面之间的切换、URL参数的传递、嵌套路由等功能。</p><h5 id="8-什么是React-Context？它的作用是什么？"><a href="#8-什么是React-Context？它的作用是什么？" class="headerlink" title="8. 什么是React Context？它的作用是什么？"></a>8. 什么是React Context？它的作用是什么？</h5><p>​      React Context是一种用于在组件树中共享数据的机制。它可以避免通过props一层层传递数据，使得跨组件的数据共享变得更加简单和高效。React Context提供了一个Provider和Consumer组件，用于提供和消费共享的数据。</p><h5 id="9-什么是React的协调（Reconciliation）过程？它是如何工作的？"><a href="#9-什么是React的协调（Reconciliation）过程？它是如何工作的？" class="headerlink" title="9. 什么是React的协调（Reconciliation）过程？它是如何工作的？"></a>9. 什么是React的协调（Reconciliation）过程？它是如何工作的？</h5><p>​      React的协调过程是指React在进行组件更新时，通过比较新旧虚拟DOM树的差异，仅对需要更新的部分进行实际的DOM操作。协调过程的工作方式如下：</p><p>React会逐层比较新旧虚拟DOM树的节点，并找出差异。 对于每个差异，React会生成相应的DOM操作指令，如插入、更新或删除节点。 React会将所有的DOM操作指令批量执行，以减少对真实DOM的操作次数。</p><h5 id="10-什么是React的事件合成（SyntheticEvent）？它的作用是什么？"><a href="#10-什么是React的事件合成（SyntheticEvent）？它的作用是什么？" class="headerlink" title="10. 什么是React的事件合成（SyntheticEvent）？它的作用是什么？"></a>10. 什么是React的事件合成（SyntheticEvent）？它的作用是什么？</h5><p>​      React的事件合成是一种在React中处理事件的机制。它是React为了提高性能和跨浏览器兼容性而实现的一种事件系统。事件合成的作用包括：</p><p>提供了一种统一的方式来处理事件，无需考虑浏览器兼容性。 可以通过事件委托的方式将事件处理程序绑定到父组件，提高性能。 可以访问原生事件对象的属性和方法。</p><h5 id="11-什么是React的Fiber架构？它解决了什么问题？"><a href="#11-什么是React的Fiber架构？它解决了什么问题？" class="headerlink" title="11. 什么是React的Fiber架构？它解决了什么问题？"></a>11. 什么是React的Fiber架构？它解决了什么问题？</h5><p>​      React的Fiber架构是React 16版本引入的一种新的协调算法和架构。它旨在解决长时间渲染阻塞主线程的问题，提高应用的性能和用户体验。Fiber架构通过将渲染过程分解为多个小任务，并使用优先级调度算法来动态分配时间片，使得React可以在每个帧中执行一部分任务，从而实现平滑的用户界面和更好的响应性能。</p><h5 id="12-什么是React的错误边界（Error-Boundary）？它的作用是什么？"><a href="#12-什么是React的错误边界（Error-Boundary）？它的作用是什么？" class="headerlink" title="12. 什么是React的错误边界（Error Boundary）？它的作用是什么？"></a>12. 什么是React的错误边界（Error Boundary）？它的作用是什么？</h5><p>​      React的错误边界是一种用于处理组件错误的机制。它允许组件捕获并处理其子组件中发生的JavaScript错误，以避免整个应用崩溃。错误边界的作用包括：</p><p>捕获并处理组件树中的错误，防止错误导致整个应用崩溃。 提供一种优雅的方式来显示错误信息或备用UI。 可以用于记录错误和发送错误报告。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h5 id="1-什么是HTTP？它是如何工作的？"><a href="#1-什么是HTTP？它是如何工作的？" class="headerlink" title="1. 什么是HTTP？它是如何工作的？"></a>1. 什么是HTTP？它是如何工作的？</h5><p>​      HTTP（Hypertext Transfer Protocol）是一种用于在Web上传输数据的协议。它使用客户端-服务器模型，客户端发送HTTP请求到服务器，服务器返回HTTP响应。HTTP的工作流程如下：</p><p>客户端发送HTTP请求到指定的URL。 服务器接收请求并处理，然后返回HTTP响应。 客户端接收响应并解析，从中获取所需的数据。</p><h5 id="2-什么是HTTPS？与HTTP有什么区别？"><a href="#2-什么是HTTPS？与HTTP有什么区别？" class="headerlink" title="2. 什么是HTTPS？与HTTP有什么区别？"></a>2. 什么是HTTPS？与HTTP有什么区别？</h5><p>​      HTTPS（Hypertext Transfer Protocol Secure）是HTTP的安全版本，通过使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对通信进行加密和身份验证。与HTTP相比，HTTPS具有以下区别：</p><p>数据在传输过程中通过加密进行保护，提供更高的安全性。 使用数字证书对服务器进行身份验证，防止中间人攻击。 使用默认端口443。</p><h5 id="3-什么是跨域请求？它是如何解决的？"><a href="#3-什么是跨域请求？它是如何解决的？" class="headerlink" title="3. 什么是跨域请求？它是如何解决的？"></a>3. 什么是跨域请求？它是如何解决的？</h5><p>​      跨域请求是指在浏览器中向不同域名、端口或协议发送的请求。由于浏览器的同源策略（Same-Origin Policy）限制，跨域请求会受到限制。为了解决跨域问题，可以使用以下方法：</p><p>JSONP（JSON with Padding）：通过动态创建</p><h5 id="4-什么是缓存？在前端中如何使用缓存来提高性能？"><a href="#4-什么是缓存？在前端中如何使用缓存来提高性能？" class="headerlink" title="4. 什么是缓存？在前端中如何使用缓存来提高性能？"></a>4. 什么是缓存？在前端中如何使用缓存来提高性能？</h5><p>​      缓存是将数据或资源存储在临时存储中，以便在后续请求中重复使用，从而提高性能和减少网络流量。在前端中，可以使用以下方式来利用缓存：</p><p>HTTP缓存：通过设置适当的缓存头（如Cache-Control和Expires）来指示浏览器缓存响应。 资源缓存：使用文件指纹或版本号来重命名静态资源文件，以便在文件内容变化时使浏览器重新下载。 数据缓存：使用内存缓存、浏览器本地存储（如localStorage）或服务端缓存（如Redis）来存储数据，避免重复请求。</p><h5 id="5-什么是CDN？它的作用是什么？"><a href="#5-什么是CDN？它的作用是什么？" class="headerlink" title="5. 什么是CDN？它的作用是什么？"></a>5. 什么是CDN？它的作用是什么？</h5><p>​      CDN（Content Delivery Network）是一种分布式网络架构，用于在全球各地提供高性能、低延迟的内容传输服务。CDN的作用包括：</p><p>将静态资源（如图片、样式表、脚本等）缓存到离用户更近的服务器上，提供更快的加载速度。 分发网络流量，减轻源服务器的负载压力。 提供内容压缩、数据压缩和缓存等优化技术，提高用户体验。</p><h5 id="6-什么是网页加载性能优化？可以采取哪些措施来改善网页加载性能？"><a href="#6-什么是网页加载性能优化？可以采取哪些措施来改善网页加载性能？" class="headerlink" title="6. 什么是网页加载性能优化？可以采取哪些措施来改善网页加载性能？"></a>6. 什么是网页加载性能优化？可以采取哪些措施来改善网页加载性能？</h5><p>​      网页加载性能优化是指通过各种技术手段来减少网页加载时间并提高用户体验。可以采取以下措施来改善网页加载性能：</p><p>压缩和合并资源文件（如CSS和JavaScript），减少文件大小和请求数量。 使用图像压缩和适当的格式选择来减小图像文件大小。 使用浏览器缓存和HTTP缓存头来缓存静态资源。 使用懒加载延迟加载非关键资源，提高初始加载速度。 使用CDN（内容分发网络）来分发静态资源，减少网络延迟。 优化关键渲染路径，尽早呈现页面内容。</p><h5 id="7-什么是网页性能监测和分析？可以使用哪些工具来监测和分析网页性能？"><a href="#7-什么是网页性能监测和分析？可以使用哪些工具来监测和分析网页性能？" class="headerlink" title="7. 什么是网页性能监测和分析？可以使用哪些工具来监测和分析网页性能？"></a>7. 什么是网页性能监测和分析？可以使用哪些工具来监测和分析网页性能？</h5><p>​      网页性能监测和分析是指通过测量和收集有关网页加载和交互性能的数据，以便识别性能瓶颈并进行优化。可以使用以下工具来监测和分析网页性能：</p><p>Web性能API：浏览器提供的JavaScript API，可通过performance对象来收集性能数据。 Lighthouse：一种开源工具，可提供关于网页性能、可访问性和最佳实践的综合报告。 WebPagetest：在线工具，可测量网页加载时间并提供详细的性能分析报告。 Chrome开发者工具：浏览器内置的开发者工具，提供了性能分析、网络监控和页面审查等功能。</p><h5 id="8-什么是渐进式图像加载（Progressive-Image-Loading）？它如何改善网页加载性能？"><a href="#8-什么是渐进式图像加载（Progressive-Image-Loading）？它如何改善网页加载性能？" class="headerlink" title="8. 什么是渐进式图像加载（Progressive Image Loading）？它如何改善网页加载性能？"></a>8. 什么是渐进式图像加载（Progressive Image Loading）？它如何改善网页加载性能？</h5><p>​      渐进式图像加载是一种技术，通过逐步加载图像的模糊或低分辨率版本，然后逐渐提高图像的清晰度，以改善网页加载性能和用户体验。渐进式图像加载的好处包括：</p><p>用户可以更快地看到页面内容，提高感知速度。 逐步加载图像可以减少网页整体的加载时间。 渐进式图像加载可以提供平滑的过渡效果，避免页面内容突然闪烁或变化。</p><h5 id="9-什么是前端资源优先级（Resource-Prioritization）？如何设置资源的优先级？"><a href="#9-什么是前端资源优先级（Resource-Prioritization）？如何设置资源的优先级？" class="headerlink" title="9. 什么是前端资源优先级（Resource Prioritization）？如何设置资源的优先级？"></a>9. 什么是前端资源优先级（Resource Prioritization）？如何设置资源的优先级？</h5><p>​      前端资源优先级是指为不同类型的资源分配加载优先级，以优化网页加载性能。可以使用以下方法设置资源的优先级：</p><p>使用标签来指定资源的预加载，以确保关键资源尽早加载。 使用标签来指定可能在未来页面中使用的资源，以提前加载。 使用标签来指定要预解析的域名，以减少DNS查找时间。 使用标签来指定要预连接的域名，以减少建立连接的时间。</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h5 id="1-解释一下浏览器的工作原理。"><a href="#1-解释一下浏览器的工作原理。" class="headerlink" title="1.解释一下浏览器的工作原理。"></a>1.解释一下浏览器的工作原理。</h5><p>​      浏览器的工作原理包括以下几个关键步骤：</p><p>解析：浏览器将接收到的HTML、CSS和JavaScript代码解析成DOM树、CSSOM树和JavaScript引擎可执行的代码。 渲染：浏览器使用DOM树和CSSOM树构建渲染树，然后根据渲染树进行布局（计算元素的位置和大小）和绘制（将元素绘制到屏幕上）。 布局和绘制：浏览器根据渲染树的变化进行布局和绘制，然后将最终的页面呈现给用户。 JavaScript引擎执行：浏览器的JavaScript引擎解释和执行JavaScript代码，并根据需要更新渲染树和重新渲染页面。</p><h5 id="2-什么是重绘（Repaint）和重排（Reflow）？它们之间有什么区别？"><a href="#2-什么是重绘（Repaint）和重排（Reflow）？它们之间有什么区别？" class="headerlink" title="2. 什么是重绘（Repaint）和重排（Reflow）？它们之间有什么区别？"></a>2. 什么是重绘（Repaint）和重排（Reflow）？它们之间有什么区别？</h5><p>​      重绘是指当元素的外观（如颜色、背景等）发生改变，但布局不受影响时的更新过程。重绘不会导致元素的位置或大小发生变化。</p><p>重排是指当元素的布局属性（如宽度、高度、位置等）发生改变时的更新过程。重排会导致浏览器重新计算渲染树和重新绘制页面的一部分或全部。</p><p>区别在于重绘只涉及外观的更改，而重排涉及布局的更改。重排比重绘更消耗性能，因为它需要重新计算布局和绘制整个页面。</p><h5 id="3-什么是事件冒泡和事件捕获？它们之间有什么区别？"><a href="#3-什么是事件冒泡和事件捕获？它们之间有什么区别？" class="headerlink" title="3. 什么是事件冒泡和事件捕获？它们之间有什么区别？"></a>3. 什么是事件冒泡和事件捕获？它们之间有什么区别？</h5><p>​      事件冒泡和事件捕获是指浏览器处理事件时的两种不同的传播方式。</p><p>事件冒泡是指事件从最内层的元素开始触发，然后逐级向上传播到父元素，直到传播到最外层的元素。</p><p>事件捕获是指事件从最外层的元素开始触发，然后逐级向下传播到最内层的元素。</p><p>区别在于传播方向的不同。事件冒泡是从内向外传播，而事件捕获是从外向内传播。</p><h5 id="4-解释一下同步和异步的JavaScript代码执行方式。"><a href="#4-解释一下同步和异步的JavaScript代码执行方式。" class="headerlink" title="4. 解释一下同步和异步的JavaScript代码执行方式。"></a>4. 解释一下同步和异步的JavaScript代码执行方式。</h5><p>​      同步代码是按照顺序执行的代码，每个任务必须等待前一个任务完成后才能执行。同步代码会阻塞后续代码的执行，直到当前任务完成。</p><p>异步代码是不按照顺序执行的代码，它会在后台执行，不会阻塞后续代码的执行。异步代码通常使用回调函数、Promise、async&#x2F;await等方式来处理异步操作的结果。</p><p>通过异步执行，可以避免阻塞主线程，提高页面的响应性能。</p><h5 id="5-什么是事件循环（Event-Loop）？它在JavaScript中的作用是什么？"><a href="#5-什么是事件循环（Event-Loop）？它在JavaScript中的作用是什么？" class="headerlink" title="5. 什么是事件循环（Event Loop）？它在JavaScript中的作用是什么？"></a>5. 什么是事件循环（Event Loop）？它在JavaScript中的作用是什么？</h5><p>​      事件循环是JavaScript中处理异步代码执行的机制。它负责管理调度和执行异步任务，并将它们添加到执行队列中。</p><p>在JavaScript中，事件循环的作用是确保异步任务按照正确的顺序执行，并且不会阻塞主线程。它通过不断地从执行队列中取出任务并执行，以实现非阻塞的异步操作。</p><h5 id="6-解释一下浏览器的垃圾回收机制是如何工作的。"><a href="#6-解释一下浏览器的垃圾回收机制是如何工作的。" class="headerlink" title="6. 解释一下浏览器的垃圾回收机制是如何工作的。"></a>6. 解释一下浏览器的垃圾回收机制是如何工作的。</h5><p>​      浏览器的垃圾回收机制是一种自动管理内存的机制，用于检测和回收不再使用的对象，以释放内存资源。</p><p>垃圾回收机制通过标记-清除算法实现。它的工作原理如下：</p><p>标记阶段：垃圾回收器会从根对象（如全局对象）开始，递归遍历所有对象，并标记仍然可访问的对象。 清除阶段：垃圾回收器会扫描堆内存，清除未被标记的对象，并回收它们所占用的内存空间。 垃圾回收机制的目标是识别和回收不再使用的对象，以避免内存泄漏和提高内存利用率。</p><h5 id="7-解释一下浏览器的同源策略（Same-Origin-Policy）及其限制。"><a href="#7-解释一下浏览器的同源策略（Same-Origin-Policy）及其限制。" class="headerlink" title="7. 解释一下浏览器的同源策略（Same-Origin Policy）及其限制。"></a>7. 解释一下浏览器的同源策略（Same-Origin Policy）及其限制。</h5><p>​      同源策略是浏览器的一项安全机制，用于限制来自不同源的网页之间的交互。同源是指协议、域名和端口号完全相同。</p><p>同源策略的限制包括：</p><p>脚本访问限制：不同源的脚本无法直接访问彼此的数据和操作。 DOM访问限制：不同源的网页无法通过JavaScript访问彼此的DOM元素。 Cookie限制：不同源的网页无法读取或修改彼此的Cookie。 AJAX请求限制：不同源的网页无法通过AJAX请求访问彼此的数据。 同源策略的存在可以防止恶意网站获取用户的敏感信息或进行恶意操作。</p><h5 id="8-什么是Web-Workers？它们在浏览器中的作用是什么？"><a href="#8-什么是Web-Workers？它们在浏览器中的作用是什么？" class="headerlink" title="8. 什么是Web Workers？它们在浏览器中的作用是什么？"></a>8. 什么是Web Workers？它们在浏览器中的作用是什么？</h5><p>​      Web Workers是一种浏览器提供的JavaScript API，用于在后台线程中执行耗时的计算任务，以避免阻塞主线程。</p><p>Web Workers的作用是提高浏览器的响应性能，使得在执行复杂计算或处理大量数据时，不会影响用户界面的流畅性。</p><p>Web Workers通过将任务委托给后台线程来实现并行处理，从而充分利用多核处理器的能力。它们可以与主线程进行通信，但不能直接访问DOM或执行UI相关的操作。</p><h5 id="9-解释一下浏览器缓存（Browser-Cache）是什么，以及它的作用是什么？"><a href="#9-解释一下浏览器缓存（Browser-Cache）是什么，以及它的作用是什么？" class="headerlink" title="9. 解释一下浏览器缓存（Browser Cache）是什么，以及它的作用是什么？"></a>9. 解释一下浏览器缓存（Browser Cache）是什么，以及它的作用是什么？</h5><p>​      浏览器缓存是浏览器在本地存储Web页面和资源的副本，以便在后续访问时可以快速加载。它的作用是减少对服务器的请求次数和网络传输量，提高页面加载速度和用户体验。</p><p>浏览器缓存通过在首次请求时将资源保存到本地，并在后续请求时检查资源是否已经存在并且没有过期来工作。如果资源已经存在且未过期，浏览器会直接从缓存中加载资源，而不是从服务器重新下载。</p><h5 id="10-什么是重定向（Redirect）？它在浏览器中的作用是什么？"><a href="#10-什么是重定向（Redirect）？它在浏览器中的作用是什么？" class="headerlink" title="10. 什么是重定向（Redirect）？它在浏览器中的作用是什么？"></a>10. 什么是重定向（Redirect）？它在浏览器中的作用是什么？</h5><p>​      重定向是指当浏览器请求一个URL时，服务器返回一个不同的URL，从而将浏览器的请求重定向到新的URL上。</p><p>重定向在浏览器中的作用是实现页面的跳转、URL的修改或资源的重定向。它可以用于多种情况，例如处理旧链接的跳转、实现URL的规范化、处理用户认证等。</p><p>重定向通过在HTTP响应中设置特定的状态码（如301永久重定向、302临时重定向）和Location头部字段来实现。</p><h5 id="11-什么是浏览器存储（Browser-Storage）？它有哪些不同的存储机制？"><a href="#11-什么是浏览器存储（Browser-Storage）？它有哪些不同的存储机制？" class="headerlink" title="11. 什么是浏览器存储（Browser Storage）？它有哪些不同的存储机制？"></a>11. 什么是浏览器存储（Browser Storage）？它有哪些不同的存储机制？</h5><p>​      浏览器存储是浏览器提供的一种在客户端存储数据的机制，用于在不同的网页间共享数据或持久保存数据。</p><p>浏览器存储有以下不同的存储机制：</p><p>Cookie：小型文本文件，可以存储少量数据，并在每次HTTP请求中自动发送到服务器。 Web Storage（localStorage和sessionStorage）：可以存储较大量的数据，以键值对的形式存储在浏览器中。 IndexedDB：一种高级的客户端数据库，可以存储大量结构化数据，并支持索引和事务操作。 Cache API：用于缓存网络请求的响应，以便离线访问或提高页面加载速度。 不同的存储机制适用于不同的需求，开发者可以根据具体情况选择合适的存储方式。</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript前端面试题</title>
    <link href="/blog/2023/10/18/interview-js/"/>
    <url>/blog/2023/10/18/interview-js/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript面试题"><a href="#JavaScript面试题" class="headerlink" title="JavaScript面试题"></a>JavaScript面试题</h1><h4 id="1-简述同步和异步的区别"><a href="#1-简述同步和异步的区别" class="headerlink" title="1.简述同步和异步的区别"></a>1.简述同步和异步的区别</h4><p>​同步：按照一定的顺序去执行，执行完一个才能执行下一个<br>​异步：执行顺序是不确定的，由触发条件决定，什么时间执行也是不确定的，即使是定时器，异步处理可以同时执行多个。</p><h4 id="2-怎么添加、移除、复制、创建、和查找节点"><a href="#2-怎么添加、移除、复制、创建、和查找节点" class="headerlink" title="2.怎么添加、移除、复制、创建、和查找节点"></a>2.怎么添加、移除、复制、创建、和查找节点</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">document<span class="hljs-selector-class">.createElement</span><br>appendChild<br>removeChild<br>replaceChild<br>insertBefore<br>insertAfter<br>cloneNode<br>document<span class="hljs-selector-class">.getElementById</span><br></code></pre></td></tr></table></figure><h4 id="3-实现一个函数clone-可以对Javascript中的五种主要数据类型（Number、string、Object、Array、Boolean）进行复制"><a href="#3-实现一个函数clone-可以对Javascript中的五种主要数据类型（Number、string、Object、Array、Boolean）进行复制" class="headerlink" title="3.实现一个函数clone() 可以对Javascript中的五种主要数据类型（Number、string、Object、Array、Boolean）进行复制"></a>3.实现一个函数clone() 可以对Javascript中的五种主要数据类型（Number、string、Object、Array、Boolean）进行复制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">clone</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> o = <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span> ? [] : &#123;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> e <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>)&#123;<br>        o[e] = <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span>[e] === <span class="hljs-string">&quot;object&quot;</span> ? <span class="hljs-variable language_">this</span>[e].<span class="hljs-title function_">clone</span>() : <span class="hljs-variable language_">this</span>[e];<br>    &#125;<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-js如何消除一个数组里面重复的元素"><a href="#4-js如何消除一个数组里面重复的元素" class="headerlink" title="4.js如何消除一个数组里面重复的元素"></a>4.js如何消除一个数组里面重复的元素</h4><p>​方法一： 两层for循环遍历<br>​方法二： 准备一个新空数组，将需要去重的数组进行遍历，判断新数组中是否有当前元素，若没有，这push到新数组中<br>​方法三：利用ES标准中的新类型Set</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-js写一个返回闭包的函数"><a href="#5-js写一个返回闭包的函数" class="headerlink" title="5.js写一个返回闭包的函数"></a>5.js写一个返回闭包的函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>         sum++;<br>         <span class="hljs-keyword">return</span> sum;<br>     &#125;<br>     <span class="hljs-keyword">return</span> fun2;<br>&#125;<br><span class="hljs-keyword">var</span> s= <span class="hljs-title function_">fun1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">s</span>());<br></code></pre></td></tr></table></figure><h4 id="6-js使用递归完成1到100的累加"><a href="#6-js使用递归完成1到100的累加" class="headerlink" title="6.js使用递归完成1到100的累加"></a>6.js使用递归完成1到100的累加</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num</span>) &#123;<br>    <span class="hljs-keyword">if</span>(num==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num+<span class="hljs-title function_">sum</span>(num-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-Javascript有哪几种数据类型"><a href="#7-Javascript有哪几种数据类型" class="headerlink" title="7.Javascript有哪几种数据类型"></a>7.Javascript有哪几种数据类型</h4><p>​String、Number、Boolean、空（Null）、未定义（Undefined）、Object、Symbol、bigInt</p><h4 id="8-js如何判断数据类型"><a href="#8-js如何判断数据类型" class="headerlink" title="8.js如何判断数据类型"></a>8.js如何判断数据类型</h4><p>​typeof：原始类型，undfined和 function 数据类型<br>​instanceof：区分自定义对象类型<br>​Object.prototype.toString.call()：无法区分自定义对象类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">obj</span>) &#123;  <br>  <span class="hljs-keyword">const</span> type = <span class="hljs-keyword">typeof</span> obj;  <br>  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;  <br>    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;null&#x27;</span>;  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj)) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;array&#x27;</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> type;  <br>&#125; <br></code></pre></td></tr></table></figure><h4 id="9-console-log-1-’2’-和console-log-1-‘2’-的打印结果"><a href="#9-console-log-1-’2’-和console-log-1-‘2’-的打印结果" class="headerlink" title="9.console.log(1+’2’)和console.log(1-‘2’)的打印结果"></a>9.console.log(1+’2’)和console.log(1-‘2’)的打印结果</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">12</span>  -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="10-Js的事件委托是什么，原理是什么"><a href="#10-Js的事件委托是什么，原理是什么" class="headerlink" title="10.Js的事件委托是什么，原理是什么"></a>10.Js的事件委托是什么，原理是什么</h4><p>​事件委托也称为事件代理。就是利用事件冒泡，把子元素的事件都绑定到父元素上。<br>何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件</p><h4 id="11-如何改变函数内部的this指针的指向"><a href="#11-如何改变函数内部的this指针的指向" class="headerlink" title="11.如何改变函数内部的this指针的指向"></a>11.如何改变函数内部的this指针的指向</h4><p>​call和apply会调用函数，并且改变函数内部this指向<br>​call和apply传递的参数不一样，call传递参数arg1，arg2…形式，apply必须数组形式[arg]<br>​bind不会调用函数，可以改变函数内部this指向</p><h4 id="12-列举几种解决跨域问题的方式，且说明原理"><a href="#12-列举几种解决跨域问题的方式，且说明原理" class="headerlink" title="12.列举几种解决跨域问题的方式，且说明原理"></a>12.列举几种解决跨域问题的方式，且说明原理</h4><p>​nginx反向代理<br>​Node中间件代理<br>​window.name + iframe<br>​WebSocket协议跨域、PostMessage<br>​jsonp</p><h4 id="13-谈谈垃圾回收机制的方式及内存管理"><a href="#13-谈谈垃圾回收机制的方式及内存管理" class="headerlink" title="13.谈谈垃圾回收机制的方式及内存管理"></a>13.谈谈垃圾回收机制的方式及内存管理</h4><p>​垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存<br>​2）标记清除算法：最常用的垃圾回收方式就是标记清除<br>​3）引用计数算法：跟踪记录每个值被引用的次数</p><h4 id="14-写一个function-，清除字符串前后的空格"><a href="#14-写一个function-，清除字符串前后的空格" class="headerlink" title="14.写一个function ，清除字符串前后的空格"></a>14.写一个function ，清除字符串前后的空格</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trim1</span>(<span class="hljs-params">str</span>)&#123;<br>    <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(^\s*)|(\s*$)/g</span>,<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="15-js实现继承的方法有哪些"><a href="#15-js实现继承的方法有哪些" class="headerlink" title="15.js实现继承的方法有哪些"></a>15.js实现继承的方法有哪些</h4><p>​原型链继承<br>​借用构造函数继承<br>​组合继承（经典继承）<br>​原型式继承<br>​寄生式继承<br>​寄生组合式继承<br>​ES6、Class实现继承</p><h4 id="16-判断一个变量是否是数组，有哪些办法"><a href="#16-判断一个变量是否是数组，有哪些办法" class="headerlink" title="16.判断一个变量是否是数组，有哪些办法"></a>16.判断一个变量是否是数组，有哪些办法</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">Array<span class="hljs-selector-class">.isArray</span>(arr)<br>instanceof 运算符<br><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.toString</span><span class="hljs-selector-class">.call</span>()<br></code></pre></td></tr></table></figure><h4 id="17-let-，const-，var-有什么区别"><a href="#17-let-，const-，var-有什么区别" class="headerlink" title="17.let ，const ，var 有什么区别"></a>17.let ，const ，var 有什么区别</h4><p>​1.变量声明和提升：var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined。然而，let和const声明的变量在其声明之前是不可用的，否则会报ReferenceError错误。这一点在ES6（ES2015）中是严格遵守的。<br>​2.重复声明：var允许重复声明变量，后一个变量会覆盖前一个变量。然而，let和const在同一作用域内不允许重复声明变量，否则会报错。<br>​3.块级作用域：var不存在块级作用域。然而，let和const存在块级作用域。ES5中作用域有全局作用域和函数作用域，但没有块作用域的概念。<br>​4.赋值限制：const声明的是常量，必须赋值，且声明后不能再修改。var声明的变量没有这个限制，可以声明后不赋值，也可以声明后再赋值。但是var声明的变量如果不使用则会被浏览器优化而导致无法达到预期效果。</p><h4 id="18-箭头函数与普通函数有什么区别"><a href="#18-箭头函数与普通函数有什么区别" class="headerlink" title="18.箭头函数与普通函数有什么区别"></a>18.箭头函数与普通函数有什么区别</h4><p>​1.外形不同：箭头函数使用箭头定义，普通函数中没有。<br>​2.箭头函数全都是匿名函数：普通函数可以有匿名函数，也可以有具名函数<br>​3.箭头函数不能用于构造函数：普通函数可以用于构造函数，以此创建对象实例。<br>​4.箭头函数中 this 的指向不同：在普通函数中，this 总是指向调用它的对象，如果用作构造函数，它指向创建的对象实例。<br>​5.箭头函数不具有 arguments 对象：每一个普通函数调用后都具有一个arguments 对象，用来存储实际传递的参数。但是箭头函数并没有此对象。<br>​6.箭头函数不具有 prototype 原型对象。<br>​7.箭头函数不具有 super</p><h4 id="19-随机取1-10之间的整数"><a href="#19-随机取1-10之间的整数" class="headerlink" title="19.随机取1-10之间的整数"></a>19.随机取1-10之间的整数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> randNum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(randNum)<br></code></pre></td></tr></table></figure><h4 id="20-new操作符具体干了什么"><a href="#20-new操作符具体干了什么" class="headerlink" title="20.new操作符具体干了什么"></a>20.new操作符具体干了什么</h4><p>​new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作：<br>​    1.创建一个新的空对象。<br>​    2.将这个新对象的prototype属性链接到构造函数的prototype对象。<br>​    3.将构造函数的this关键字绑定到新创建的对象，并执行构造函数的代码（添加属性和方法到新对象）。<br>​    4.如果构造函数返回一个对象，那么这个对象将会替代构造函数中的this。如果构造函数没有返回一个对象，那么new操作符将返回this，即新创建的对象</p><h4 id="21-Ajax原理"><a href="#21-Ajax原理" class="headerlink" title="21.Ajax原理"></a>21.Ajax原理</h4><p>​通过javascript的方式，将前台数据通过xmlhttp对象传递到后台，后台在接收到请求后，将需要的结果，再传回到前台，这样就可以实现不需要页面的回发，页是数据实现来回传递，从页实现无刷新<br>​通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面</p><h4 id="22-模块化开发怎么做"><a href="#22-模块化开发怎么做" class="headerlink" title="22.模块化开发怎么做"></a>22.模块化开发怎么做</h4><p>​1.代码可读可维护<br>​2.功能模块分离<br>​3.使用模块化开发工具<br>​4.ES6模块化规范(模块的导出和导入)<br>​5.组件化开发:将UI组件进行封装和复用，采用组件化的方式进行开发，可以减少代码的冗余和提高开发效率。<br>​6.前端工程化：通过前端工程化的思想，将前端项目拆分为多个子项目，每个子项目都有自己的作用域和功能，按需加载和执行，能够提高开发效率和用户体验。</p><h4 id="23-异步加载Js的方式有哪些"><a href="#23-异步加载Js的方式有哪些" class="headerlink" title="23.异步加载Js的方式有哪些"></a>23.异步加载Js的方式有哪些</h4><p>​1.使用async属性：当脚本的async属性被设置为true时，浏览器会异步加载和执行脚本。这种方式不会阻塞页面的其他渲染，但可能会在脚本执行前或后加载页面内容。<br>​2.使用defer属性：当脚本的defer属性被设置为true时，浏览器会延迟加载和执行脚本。这种方式会阻塞页面的渲染，直到脚本加载和执行完毕，但它通常在DOMContentLoaded事件触发前不会加载脚本。<br>​3.使用onload事件：当文档加载完成后，可以通过监听window.onload或document.addEventListener(“load”, callback)等事件来异步加载JS。<br>​4.使用DOMContentLoaded事件：当文档解析完成，DOMContentLoaded事件触发时，可以使用该事件来异步加载JS。<br>​5.使用异步API：JavaScript还提供了许多异步API，如XMLHttpRequest和Fetch API等，可以使用这些API来异步加载JS。</p><h4 id="24-xml和-json的区别"><a href="#24-xml和-json的区别" class="headerlink" title="24.xml和 json的区别"></a>24.xml和 json的区别</h4><p>​JSON是JavaScript Object Notation；XML是可扩展标记语言。<br>​JSON是基于JavaScript语言；XML源自SGML。<br>​JSON是一种表示对象的方式；XML是一种标记语言，使用标记结构来表示数据项。<br>​JSON不提供对命名空间的任何支持；XML支持名称空间。<br>​JSON支持数组；XML不支持数组。<br>​XML的文件相对难以阅读和解释；与XML相比，JSON的文件非常易于阅读。<br>​JSON不使用结束标记；XML有开始和结束标签。<br>​JSON的安全性较低；XML比JSON更安全。<br>​JSON不支持注释；XML支持注释。<br>​JSON仅支持UTF-8编码；XML支持各种编码</p><h4 id="25-webpack如何实现打包的"><a href="#25-webpack如何实现打包的" class="headerlink" title="25.webpack如何实现打包的"></a>25.webpack如何实现打包的</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>.读取配置文件：Webpack首先会读取项目中的webpack<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>配置文件。这个文件包含了打包所需要的所有信息，包括入口文件、输出路径、加载器（loaders）、插件（plugins）等等。<br><span class="hljs-number">2</span>.处理入口文件：Webpack会从配置文件中指定的入口文件开始，解析文件并记录其依赖。它会递归地解析这些依赖，并构建一个依赖图（dependency graph）。<br><span class="hljs-number">3</span>.确定输出路径：在配置文件中，你需要指定输出路径，Webpack会将最终打包后的文件保存到这个路径下。<br><span class="hljs-number">4</span>.加载器和插件：加载器可以将非JavaScript文件（如CSS、图片等）转换为Webpack可以处理的模块。插件则可以进行更广泛的任务，包括优化打包的输出、处理环境变量等等。<br><span class="hljs-number">5</span>.打包输出：最后，Webpack会将所有的模块打包成一个或多个文件，通常是一个JavaScript文件和一个CSS文件。它还会将这个文件名和路径写入到配置文件中的output字段。<br></code></pre></td></tr></table></figure><h4 id="26-常见web安全及防护原理"><a href="#26-常见web安全及防护原理" class="headerlink" title="26.常见web安全及防护原理"></a>26.常见web安全及防护原理</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">SQL注入：具体就是通过把sql命令插入到web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意sql命令<br>xss跨站脚本（Cross-site Scripting）：是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了<span class="hljs-selector-tag">HTML</span>以及用户端脚本语言。<br>CSRF/跨站请求伪造（Cross-site request forgery）：CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式<br>DDos攻击/分布式拒绝服务(Distributed Denial of service Attack)：攻击者想办法让目标服务器的磁盘空间、内存、进程、网络带宽等资源被占满，从而导致正常用户无法访问<br>上传漏洞：文件上传漏洞是指网络攻击者上传了一个可执行的文件到服务器，服务器未经任何检验或过滤，从而造成文件的执行。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等<br>目录遍历漏洞：由于Web服务器或者Web应用程序对用户输入的文件名称的安全性验证不足而导致的一种安全漏洞，使得攻击者通过利用一些特殊字符就可以绕过服务器的安全限制，访问任意的文件，甚至执行系统命令<br></code></pre></td></tr></table></figure><h4 id="27-用过哪些设计模式"><a href="#27-用过哪些设计模式" class="headerlink" title="27.用过哪些设计模式"></a>27.用过哪些设计模式</h4><p>​工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式<br>​适配器模式、装饰器模式、代理模式、外观模式<br>​观察者模式、访问者模式、中介者模式、策略模式</p><h4 id="28-为什么要同源限制"><a href="#28-为什么要同源限制" class="headerlink" title="28.为什么要同源限制"></a>28.为什么要同源限制</h4><p>​限制不同源的document或脚本之间的相互访问，以免造成干扰和混乱</p><h4 id="29-offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别"><a href="#29-offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别" class="headerlink" title="29.offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight与scrollWidth&#x2F;scrollHeight的区别"></a>29.offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight与scrollWidth&#x2F;scrollHeight的区别</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">offsetWidth / offsetHeight（内容可视区域的高度 + 滚动条 + 边框+外边距）返回值包含<span class="hljs-attribute">content</span> + <span class="hljs-attribute">padding</span> + <span class="hljs-attribute">border</span>，效果与 e<span class="hljs-selector-class">.getBoundingClientRect</span>()相同<br>clientWidth / clientHeight（内容可视区域的高度） 返回值只包含<span class="hljs-attribute">content</span> + <span class="hljs-attribute">padding</span>，如果有滚动条，也不包含滚动条<br>scrollWidth / scrollHeight（元素的<span class="hljs-attribute">padding</span>+元素内容的高度） 返回值包含<span class="hljs-attribute">content</span> + <span class="hljs-attribute">padding</span> + 溢出内容的尺⼨<br></code></pre></td></tr></table></figure><h4 id="30-js有哪些方法定义对象"><a href="#30-js有哪些方法定义对象" class="headerlink" title="30.js有哪些方法定义对象"></a>30.js有哪些方法定义对象</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">通过构造函数来创建对象<br>通过<span class="hljs-selector-tag">var</span> obj = new <span class="hljs-selector-tag">Object</span>() 创建对象<br>通过<span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">object</span> = &#123;&#125;  对象字面量<br></code></pre></td></tr></table></figure><h4 id="31-说说你对promise的了解"><a href="#31-说说你对promise的了解" class="headerlink" title="31.说说你对promise的了解"></a>31.说说你对promise的了解</h4><p>​Promise 是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了回调地狱的问题。<br>​Promise 是一个构造函数，我们可以通过该构造函数来生成Promise的实例。<br>​Promise对象有以下两个特点：</p><p>　　　　（1）对象的状态不受外界影响。Promise 即承诺，后续必要兑现，一旦兑现则不可更改！其有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。<br>　　　　（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象只有两种状态改变：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就不会再变了。<br>　　Promise也有一些缺点：<br>　　　　首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。<br>　　　　其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>　　　　第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。<br>　　Promise 的实例可以看做是一个状态展示器，我们可以将拥有状态及改变状态的业务通过Promise来实现，然后再结合async function进一步提升程序的可读性及易维护性。</p><h4 id="32-谈谈你对AMD、CMD的理解"><a href="#32-谈谈你对AMD、CMD的理解" class="headerlink" title="32.谈谈你对AMD、CMD的理解"></a>32.谈谈你对AMD、CMD的理解</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">AMD（Asynchronous Module Definition）：异步模块定义，AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块<br>CMD（Common Module Definition）：通用模块定义，CMD推崇就近依赖，只有在用到某个模块的时候再去移入。<br>CMD是sea<span class="hljs-selector-class">.js</span>推广过程中对模块定义的规范化产出；AMD是require<span class="hljs-selector-class">.js</span>推广过程中对模块定义的规范化产出<br>AMD和CMD都是异步加载模块，都是为了JavaScript模块化开发的规范<br></code></pre></td></tr></table></figure><h4 id="33-web开发中会话跟踪的方法有哪些"><a href="#33-web开发中会话跟踪的方法有哪些" class="headerlink" title="33.web开发中会话跟踪的方法有哪些"></a>33.web开发中会话跟踪的方法有哪些</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">URL重写：<br>隐藏表单域：<br>Cookie：<br>session：<br></code></pre></td></tr></table></figure><h4 id="34-介绍js有哪些内置对象？"><a href="#34-介绍js有哪些内置对象？" class="headerlink" title="34.介绍js有哪些内置对象？"></a>34.介绍js有哪些内置对象？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">Math对象、<span class="hljs-selector-tag">Object</span>对象、RegExp对象、 Global对象、Function对象、arguments、String对象、Number对象<br>Boolean对象、Date对象、Array对象<br></code></pre></td></tr></table></figure><h4 id="35-说几条写JavaScript的基本规范？"><a href="#35-说几条写JavaScript的基本规范？" class="headerlink" title="35.说几条写JavaScript的基本规范？"></a>35.说几条写JavaScript的基本规范？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">在函数中，应该将变量声明提升到最上方，并且避免对应该变量使用多次<span class="hljs-selector-tag">var</span>声明，在定义变量时，应该给变量提供一个初始化的值，以便于代码具有更好的阅读性。<br>代码中出现地址，时间等字符串应该使用常量代替。<br>在代码中比较时，应该使用 ===, !== 来代替 == 和 !=。<br>尽量不要在内置对象Array,data的原型对象上添加属性。<br><span class="hljs-selector-tag">switch</span>必须带有default分支。<br>for循环必须带有大括号，即使只有一行代码。<br>if语句必须使用大括号括起来<br>命名规范：驼峰命名法，常量必须全部大写<br></code></pre></td></tr></table></figure><h4 id="36-javascript创建对象的几种方式？"><a href="#36-javascript创建对象的几种方式？" class="headerlink" title="36.javascript创建对象的几种方式？"></a>36.javascript创建对象的几种方式？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">使用&#123;&#125;创建对象，等同于 new <span class="hljs-selector-tag">Object</span>()<br>通过new <span class="hljs-selector-tag">Object</span>()创建对象<br>使用字面量创建对象<br>使用工厂模式创建对象<br>通过构造函数创建对象<br>通过原型模式创建对象<br></code></pre></td></tr></table></figure><h4 id="37-eval是做什么的？"><a href="#37-eval是做什么的？" class="headerlink" title="37.eval是做什么的？"></a>37.eval是做什么的？</h4><pre><code class="hljs">在字符串里面写代码的函数</code></pre><h4 id="38-null，undefined-的区别？"><a href="#38-null，undefined-的区别？" class="headerlink" title="38.null，undefined 的区别？"></a>38.null，undefined 的区别？</h4><pre><code class="hljs">一个是空，一个是未定义</code></pre><h4 id="39-“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#39-“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="39.[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>39.[“1”, “2”, “3”].map(parseInt) 答案是多少？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//[1,NaN,NaN]</span><br></code></pre></td></tr></table></figure><h4 id="40-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><a href="#40-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="40.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>40.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">严格模式<br>禁止使用 with 语句，禁止 this 关键字指向全局对象，对象不能有重名的属性<br></code></pre></td></tr></table></figure><h4 id="41-js延迟加载的方式有哪些？"><a href="#41-js延迟加载的方式有哪些？" class="headerlink" title="41.js延迟加载的方式有哪些？"></a>41.js延迟加载的方式有哪些？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">defer属性<br>async属性<br>动态创建DOM<br>使用jq的getScript方法<br>使用setTimeout延迟加载脚本<br>将script引入放在最后（底部）加载<br></code></pre></td></tr></table></figure><h4 id="42-defer和async"><a href="#42-defer和async" class="headerlink" title="42.defer和async"></a>42.defer和async</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">&lt;script async <span class="hljs-attribute">src</span>=&quot;xx<span class="hljs-selector-class">.js</span>&quot;&gt;&lt;/script&gt;<br>async：加载和渲染后续文档元素的过程将和 xx<span class="hljs-selector-class">.js</span> 的加载与执行并行进行（异步）<br>&lt;script defer <span class="hljs-attribute">src</span>=&quot;xx<span class="hljs-selector-class">.js</span>&quot;&gt;&lt;/script&gt;<br>defer，加载后续文档元素的过程将和xx<span class="hljs-selector-class">.js</span>的加载并行进行（异步），但是 xx<span class="hljs-selector-class">.js</span>的执行要在所有元素解析完成之后，<br></code></pre></td></tr></table></figure><h4 id="43-说说严格模式的限制"><a href="#43-说说严格模式的限制" class="headerlink" title="43.说说严格模式的限制"></a>43.说说严格模式的限制</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">变量必须声明后再使用<br>函数的参数不能有同名属性，否则报错<br>不能使用with语句<br>禁止this指向全局对象<br>不能对只读属性赋值，否则报错<br></code></pre></td></tr></table></figure><h4 id="44-attribute和property的区别是什么？"><a href="#44-attribute和property的区别是什么？" class="headerlink" title="44.attribute和property的区别是什么？"></a>44.attribute和property的区别是什么？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">Attribute是DOM节点自带属性<br>roperty是这个DOM元素作为对象<br>Attribute和roperty取值和赋值不同<br></code></pre></td></tr></table></figure><h4 id="45-ECMAScript6-怎么写class么，为什么会出现class这种东西"><a href="#45-ECMAScript6-怎么写class么，为什么会出现class这种东西" class="headerlink" title="45.ECMAScript6 怎么写class么，为什么会出现class这种东西?"></a>45.ECMAScript6 怎么写class么，为什么会出现class这种东西?</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">ES6的class可以看作只是一个语法糖<br>新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法<br></code></pre></td></tr></table></figure><h4 id="46-常见兼容性问题"><a href="#46-常见兼容性问题" class="headerlink" title="46.常见兼容性问题"></a>46.常见兼容性问题</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">阻止浏览器的默认行为的兼容写法 e<span class="hljs-selector-class">.returnValue</span> = false;<span class="hljs-comment">//IE浏览器</span><br>阻止事件冒泡的兼容写法 e<span class="hljs-selector-class">.cancelBubble</span> = true;      <span class="hljs-comment">//IE</span><br>事件监听绑定事件的兼容写法 ele<span class="hljs-selector-class">.attachEvent</span>(&quot;on&quot;+myevent,cb)<span class="hljs-comment">//IE</span><br>获取样式的兼容写法 ele<span class="hljs-selector-class">.currentStyle</span><span class="hljs-selector-attr">[attr]</span><br></code></pre></td></tr></table></figure><h4 id="47-函数防抖节流的原理"><a href="#47-函数防抖节流的原理" class="headerlink" title="47.函数防抖节流的原理"></a>47.函数防抖节流的原理</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">节流是第一个说了算，后续都会被节流阀屏蔽掉，防抖是最后一个说了算，前面启用的都会被清除<br><br>节流函数会在第一次触发事件时立即执行<br>防抖就是指触发事件后在 n 秒内函数只能执行一次<br></code></pre></td></tr></table></figure><h4 id="48-原始类型有哪几种？null是对象吗？"><a href="#48-原始类型有哪几种？null是对象吗？" class="headerlink" title="48.原始类型有哪几种？null是对象吗？"></a>48.原始类型有哪几种？null是对象吗？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">undefined、null、string、number、boolean、<span class="hljs-selector-tag">symbol</span>、<br>null其实并不是一个对象，尽管typeof null输出的是<span class="hljs-selector-tag">object</span>,但是这其实是一个bug。在js最初的版本中使用的是<span class="hljs-number">32</span>位系统，为了性能考虑地位存储变量的类型信息，<span class="hljs-number">000</span>开头表示为对象类型，然而null为全<span class="hljs-number">0</span>，故而null被判断为对象类型<br></code></pre></td></tr></table></figure><h4 id="49-为什么console-log-0-2-0-1-0-3-false"><a href="#49-为什么console-log-0-2-0-1-0-3-false" class="headerlink" title="49.为什么console.log(0.2 + 0.1 &#x3D;&#x3D; 0.3) &#x2F;&#x2F;false"></a>49.为什么console.log(0.2 + 0.1 &#x3D;&#x3D; 0.3) &#x2F;&#x2F;false</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">是由于浮点数精度问题造成的<br>IEEE754的<span class="hljs-number">64</span>位双精度的语言都是如此<br></code></pre></td></tr></table></figure><h4 id="50-说一下JS中类型转换的规则？"><a href="#50-说一下JS中类型转换的规则？" class="headerlink" title="50.说一下JS中类型转换的规则？"></a>50.说一下JS中类型转换的规则？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">自动类型转换：JavaScript会自动转换值到需要的类型，例如，当一个值被赋值给一个不同类型的变量，或者当一个操作符需要一个特定类型的操作数时。<br>隐式类型转换：这种类型转换在计算表达式或者赋值操作时自动发生。例如，当一个字符串和一个数字相加时，字符串会被转换为数字然后进行加法运算。<br>显式类型转换：这涉及到使用一些函数或者方法来转换值的类型。例如，使用<span class="hljs-built_in">parseFloat</span>()或者<span class="hljs-built_in">parseInt</span>()函数将字符串转换为数字。<br></code></pre></td></tr></table></figure><h4 id="51-深拷贝和浅拷贝的区别？如何实现"><a href="#51-深拷贝和浅拷贝的区别？如何实现" class="headerlink" title="51.深拷贝和浅拷贝的区别？如何实现"></a>51.深拷贝和浅拷贝的区别？如何实现</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">浅拷贝：是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一 个地址<br>直接变量赋值<br>    <span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.assign</span>()；但目标对象只有一层的时候，是深拷贝；<br>    扩展运算符(…)；目标对象只有一层的时候，是深拷贝；<br>深拷贝：是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址<br>结合使用JSON<span class="hljs-selector-class">.parse</span>()和JSON<span class="hljs-selector-class">.stringify</span>()方法。<br>手写遍历递归赋值；<br></code></pre></td></tr></table></figure><h4 id="52-如何判断this？箭头函数的this是什么"><a href="#52-如何判断this？箭头函数的this是什么" class="headerlink" title="52.如何判断this？箭头函数的this是什么"></a>52.如何判断this？箭头函数的this是什么</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">函数直接调用中的this <span class="hljs-comment">// 指向window</span><br>在对象里调用的情况：<span class="hljs-comment">//this会指向调用的对象</span><br>在构造函数及类中this会指向实例化的对象 <br>箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this<br></code></pre></td></tr></table></figure><h4 id="53-和-的区别"><a href="#53-和-的区别" class="headerlink" title="53.&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;的区别"></a>53.&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;的区别</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">&quot;==“叫做相等运算符，”===&quot;叫做严格运算符。<br>&quot;==&quot;，等同的意思，两边值类型不同的时候，要先进行类型转换为同一类型后，再比较值是否相等。<br>  &quot;===&quot;，恒等的意思，不做类型转换，类型不同的结果一定不等。<br>&quot;==“表示只要值相等即可为真，而”===&quot;则要求不仅值相等，而且也要求类型相同。<br></code></pre></td></tr></table></figure><h4 id="54-什么是闭包"><a href="#54-什么是闭包" class="headerlink" title="54.什么是闭包"></a>54.什么是闭包</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">闭包(closure)就是能够读取其他函数内部变量的函数<br></code></pre></td></tr></table></figure><h4 id="55-JavaScript原型，原型链-有什么特点？"><a href="#55-JavaScript原型，原型链-有什么特点？" class="headerlink" title="55.JavaScript原型，原型链 ? 有什么特点？"></a>55.JavaScript原型，原型链 ? 有什么特点？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">每个对象都有原型（null和undefined除外），你可以把它理解为对象的默认属性和方法<br>在JS 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止，组成这条链的最后一环。这种一级一级的链结构就称为原型链<br></code></pre></td></tr></table></figure><h4 id="56-typeof-和instanceof-的用法区别"><a href="#56-typeof-和instanceof-的用法区别" class="headerlink" title="56.typeof()和instanceof()的用法区别"></a>56.typeof()和instanceof()的用法区别</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">typeof判断所有变量的类型，返回值有number、string、boolean、function、<span class="hljs-selector-tag">object</span>、undefined<br>instanceof用来判断对象<br></code></pre></td></tr></table></figure><h4 id="57-什么是变量提升"><a href="#57-什么是变量提升" class="headerlink" title="57.什么是变量提升"></a>57.什么是变量提升</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">通常发生在<span class="hljs-selector-tag">var</span>声明的变量里，就是说当使用<span class="hljs-selector-tag">var</span>声明一个变量的时候，该变量会被提升到作用域的顶端，但是赋值的部分并不会被提升<br></code></pre></td></tr></table></figure><h4 id="58-call、apply以及bind函数内部实现是怎么样的"><a href="#58-call、apply以及bind函数内部实现是怎么样的" class="headerlink" title="58.call、apply以及bind函数内部实现是怎么样的"></a>58.call、apply以及bind函数内部实现是怎么样的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>    <span class="hljs-comment">// 判断this的类型，如果不是function 则返回</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// 判断有没有传入上下文，如果没有传入则指向window</span><br>    context = context || <span class="hljs-title class_">Window</span>;<br>    <span class="hljs-comment">// 在上下文中注入一个属性指向this</span><br>    context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span> <span class="hljs-comment">// 改变指向</span><br>    <span class="hljs-comment">// 从第二个参数开始才是要传入的实参列表，截取传入的参数（第一个是传入的要改变的this）</span><br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 指行函数</span><br>    <span class="hljs-keyword">let</span> res = context.<span class="hljs-title function_">fn</span>(...args)<br>    <span class="hljs-comment">// 删除属性，不然污染传入的上下文</span><br>    <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>    <span class="hljs-comment">// 不是函数类型，返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 记录一下this,因为需要返回一个函数，this会被篡改</span><br>    <span class="hljs-keyword">let</span> _self = <span class="hljs-variable language_">this</span><br>    <span class="hljs-comment">// 截取实参列表</span><br>    <span class="hljs-keyword">let</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 处理柯里化传入的参数，拼接到bind绑定的后面</span><br>        <span class="hljs-keyword">return</span> _self.<span class="hljs-title function_">apply</span>(context, args.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>)))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="59-为什么会出现setTimeout倒计时误差？如何减少"><a href="#59-为什么会出现setTimeout倒计时误差？如何减少" class="headerlink" title="59.为什么会出现setTimeout倒计时误差？如何减少"></a>59.为什么会出现setTimeout倒计时误差？如何减少</h4><pre><code class="hljs">setTimeout作为异步任务，在实现倒计时功能的时候，除了执行我们功能的实现代码，还会有主线程对任务队列的读取及执行等过程，这些过程也需要耗费一些时间，所以会因为event loop的机制出现些许误差计算误差值、动态调整执行setTimeout的间隔</code></pre><h4 id="60-谈谈你对JS执行上下文栈和作用域链的理解"><a href="#60-谈谈你对JS执行上下文栈和作用域链的理解" class="headerlink" title="60.谈谈你对JS执行上下文栈和作用域链的理解"></a>60.谈谈你对JS执行上下文栈和作用域链的理解</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">执行上下文：就是当前 JavaScript 代码被解析和执行时所在环境, JS执行上下文栈可以认为是一个存储函数调用的栈结构。<br>作用域链：函数执行所需要的变量在当前作用域中找不到的时候，它就会一层一层向上查找，一直找到全局作用域。这种一层一层的关系，就是作用域链<br></code></pre></td></tr></table></figure><h4 id="61-new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？"><a href="#61-new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？" class="headerlink" title="61.new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？"></a>61.new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">new的工作原理：<br>    <span class="hljs-number">1</span>.创建一个空对象，构造函数中的this会指向这个对象<br>    <span class="hljs-number">2</span>.这个新对象会被链接到原型<br>    <span class="hljs-number">3</span>.执行构造函数方法，其属性和方法都会被添加到this引用的对象中<br>    <span class="hljs-number">4</span>.如果构造函数中没有返回新对象，那么返回this，即创建新对象；否则，返回构造函数中返回的对象。<br>new和字面量创建对象的区别：<br>    <span class="hljs-number">1</span>.字面量创建对象，不会调用<span class="hljs-selector-tag">Object</span>构造函数，简洁且性能更好；<br>    <span class="hljs-number">2</span><span class="hljs-selector-class">.new</span> <span class="hljs-selector-tag">Object</span>() 方式创建对象本质上是方法调用，涉及到在proto链中遍历该方法，当找到该方法后，又会生产方法调用必须的 堆栈信息，方法调用结束后，还要释放该堆栈，性能不如字面量的方式。<br></code></pre></td></tr></table></figure><h4 id="62-prototype-和-proto-区别是什么？"><a href="#62-prototype-和-proto-区别是什么？" class="headerlink" title="62.prototype 和 proto 区别是什么？"></a>62.prototype 和 proto 区别是什么？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">prototype是每个函数都会具备的一个属性，它是一个指针，指向一个对象，只有函数才有。<br>proto是主流浏览器上在除null以外的每个对象上都支持的一个属性，它能够指向该对象的原型<br></code></pre></td></tr></table></figure><h4 id="63-使用ES5实现一个继承？"><a href="#63-使用ES5实现一个继承？" class="headerlink" title="63.使用ES5实现一个继承？"></a>63.使用ES5实现一个继承？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES5构造函数</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Parent</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-comment">//1.创建一个新对象，赋予this，这一步是隐性的，</span><br>    <span class="hljs-comment">// let this = &#123;&#125;;</span><br>    <span class="hljs-comment">//2.给this指向的对象赋予构造属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-comment">//3.如果没有手动返回对象，则默认返回this指向的这个对象，也是隐性的</span><br>    <span class="hljs-comment">// return this;</span><br>&#125;;<br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br></code></pre></td></tr></table></figure><h4 id="64-取数组的最大值（ES5、ES6）"><a href="#64-取数组的最大值（ES5、ES6）" class="headerlink" title="64.取数组的最大值（ES5、ES6）"></a>64.取数组的最大值（ES5、ES6）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES5 的写法</span><br>    <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">14</span>, <span class="hljs-number">3</span>, <span class="hljs-number">77</span>, <span class="hljs-number">30</span>]);<br>    <span class="hljs-comment">// ES6 的写法</span><br>    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...[<span class="hljs-number">14</span>, <span class="hljs-number">3</span>, <span class="hljs-number">77</span>, <span class="hljs-number">30</span>]);<br></code></pre></td></tr></table></figure><h4 id="65-ES6新的特性有哪些？"><a href="#65-ES6新的特性有哪些？" class="headerlink" title="65.ES6新的特性有哪些？"></a>65.ES6新的特性有哪些？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">新的原始类型和变量声明：<span class="hljs-selector-tag">symbol</span>、let和const、解构赋值 <br>新的对象和方法 ：Map和Set、对象新特性（拓展运算符(...)三点、<span class="hljs-built_in">assign</span>()和<span class="hljs-built_in">is</span>()）<br>字符串新方法：<span class="hljs-built_in">includes</span>()：判断字符串是否包含参数字符串，返回boolean值<br><span class="hljs-built_in">startsWith</span>()/<span class="hljs-built_in">endsWith</span>()：判断字符串是否以参数字符串开头或结尾<br><span class="hljs-built_in">padStart</span>()/<span class="hljs-built_in">padEnd</span>()：用参数字符串按给定长度从前面或后面补全字符串，返回新字符串<br>repeat()：按指定次数返回一个新的字符串<br>函数：箭头函数、参数默认值<br>class（类）：class 作为对象的模板被引入ES6，你可以通过 class 关键字定义类。class 的本质依然是一个函数。<br>模块导入和导出：import 、export <br>异步机制：Promise和Generator<br></code></pre></td></tr></table></figure><h4 id="66-promise-有几种状态-Promise-有什么优缺点"><a href="#66-promise-有几种状态-Promise-有什么优缺点" class="headerlink" title="66.promise 有几种状态, Promise 有什么优缺点 ?"></a>66.promise 有几种状态, Promise 有什么优缺点 ?</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">pending</span>(进行中)、<span class="hljs-built_in">fulfilled</span>(已成功)、<span class="hljs-built_in">rejected</span>(已失败)<br>Promise优点：<br>   统一异步 API：Promise 的一个重要优点是它将逐渐被用作浏览器的异步API，统一现在各种各样的 API，以及不兼容的模式和手法。<br>   Promise 与事件对比：和事件相比较，Promise 更适合处理一次性的结果。在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。<br>   Promise 与回调对比：解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。<br>   Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松。<br>Promise缺点<br>    无法取消Promise，一旦新建它就会立即执行，无法中途取消。<br>    如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>    当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。<br>    Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise的报错堆栈上下文不太友好。<br></code></pre></td></tr></table></figure><h4 id="67-Promise构造函数是同步还是异步执行，then呢-promise如何实现then处理"><a href="#67-Promise构造函数是同步还是异步执行，then呢-promise如何实现then处理" class="headerlink" title="67.Promise构造函数是同步还是异步执行，then呢 ?promise如何实现then处理 ?"></a>67.Promise构造函数是同步还是异步执行，then呢 ?promise如何实现then处理 ?</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">promise构造函数是同步执行的，then方法是异步执行的<br></code></pre></td></tr></table></figure><h4 id="68-Promise和setTimeout的区别"><a href="#68-Promise和setTimeout的区别" class="headerlink" title="68.Promise和setTimeout的区别 ?"></a>68.Promise和setTimeout的区别 ?</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">Promise：微任务<br>setTimeout：宏任务<br>Promise会优先于setTimeout执行<br></code></pre></td></tr></table></figure><h4 id="69-如何实现-Promise-all"><a href="#69-如何实现-Promise-all" class="headerlink" title="69.如何实现 Promise.all ?"></a>69.如何实现 Promise.all ?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">array</span>) &#123;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;  <br>    <span class="hljs-comment">// 如果数组为空，直接返回  </span><br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;  <br>      <span class="hljs-title function_">resolve</span>([]);  <br>    &#125;  <br>    <span class="hljs-comment">// 如果有Promise失败，就立即reject  </span><br>    <span class="hljs-keyword">var</span> remaining = array.<span class="hljs-property">length</span>;  <br>    <span class="hljs-keyword">var</span> values = [];  <br>    array.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">promise, index</span>) &#123;  <br>      promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;  <br>        remaining--;  <br>        values[index] = value;  <br>        <span class="hljs-comment">// 如果有Promise成功，就减少计数  </span><br>        <span class="hljs-keyword">if</span> (remaining === <span class="hljs-number">0</span>) &#123;  <br>          <span class="hljs-title function_">resolve</span>(values);  <br>        &#125;  <br>      &#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) &#123;  <br>        remaining = -<span class="hljs-number">1</span>;  <br>        <span class="hljs-title function_">reject</span>(reason);  <br>      &#125;);  <br>    &#125;);  <br>  &#125;);  <br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="70-如何实现-Promise-finally"><a href="#70-如何实现-Promise-finally" class="headerlink" title="70.如何实现 Promise.finally ?"></a>70.如何实现 Promise.finally ?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PromiseLike</span> &#123;  <br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;pending&#x27;</span>;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;  <br>  <br>    <span class="hljs-title function_">executor</span>(  <br>      <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;  <br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;  <br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = result;  <br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">finallyFulfilled</span>();  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>          <span class="hljs-comment">// Promise has already been resolved. This should only happen with .then() or .catch()  </span><br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Promise has already been resolved&#x27;</span>);  <br>        &#125;  <br>      &#125;,  <br>      <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;  <br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;rejected&#x27;</span>;  <br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;  <br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">finallyRejected</span>();  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>          <span class="hljs-comment">// Promise has already been resolved. This should only happen with .then() or .catch()  </span><br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Promise has already been resolved&#x27;</span>);  <br>        &#125;  <br>      &#125;  <br>    );  <br>  &#125;  <br>  <br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;  <br>      <span class="hljs-keyword">const</span> next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PromiseLike</span>(executor);  <br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = next;  <br>      <span class="hljs-title function_">executor</span>(onFulfilled, onRejected);  <br>      <span class="hljs-keyword">return</span> next;  <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;fulfilled&#x27;</span>) &#123;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;  <br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>));  <br>      &#125;);  <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>));  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>      <span class="hljs-comment">// Should never happen  </span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Promise is in an invalid state&#x27;</span>);  <br>    &#125;  <br>  &#125;  <br>  <br>  <span class="hljs-keyword">catch</span>(onRejected) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, onRejected);  <br>  &#125;  <br>  <br>  <span class="hljs-title function_">finally</span>(<span class="hljs-params">onFinally</span>) &#123;  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;  <br>      <span class="hljs-keyword">const</span> status = <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span>;  <br>      <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;  <br>      <span class="hljs-keyword">const</span> reason = <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>;  <br>      <span class="hljs-title function_">onFinally</span>();  <br>      <span class="hljs-keyword">return</span> status === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(value) : <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(reason);  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>      <span class="hljs-keyword">const</span> next = <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span>;  <br>      <span class="hljs-keyword">if</span> (next) &#123;  <br>        <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">finally</span>(onFinally);  <br>      &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// The promise doesn&#x27;t have any .then() or .catch() handlers, so the finally() should run after the original promise settles.  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(onFinally).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>);  <br>      &#125;  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="71-如何判断img加载完成"><a href="#71-如何判断img加载完成" class="headerlink" title="71.如何判断img加载完成"></a>71.如何判断img加载完成</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">img</span>的complete属性<br>Load事件<br>readystatechange事件<br></code></pre></td></tr></table></figure><h4 id="72-如何阻止冒泡？"><a href="#72-如何阻止冒泡？" class="headerlink" title="72.如何阻止冒泡？"></a>72.如何阻止冒泡？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">event.<span class="hljs-title function_">stopPropagation</span>()<br>event.<span class="hljs-title function_">preventDefault</span>()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h4 id="73-如何阻止默认事件？"><a href="#73-如何阻止默认事件？" class="headerlink" title="73.如何阻止默认事件？"></a>73.如何阻止默认事件？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">preventDefault<br>stopPropagation<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h4 id="74-ajax请求时，如何解释json数据"><a href="#74-ajax请求时，如何解释json数据" class="headerlink" title="74.ajax请求时，如何解释json数据"></a>74.ajax请求时，如何解释json数据</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">方法<span class="hljs-number">1</span>： 设置 ajax 方法的 dataType 属性为 ‘json’。<br>方法<span class="hljs-number">2</span>： 使用 JSON 对象的 <span class="hljs-built_in">parse</span>() 方法解析。<br>方法<span class="hljs-number">3</span>： 使用 <span class="hljs-built_in">eval</span>() 方法，<span class="hljs-selector-tag">var</span> dataObj = <span class="hljs-built_in">eval</span>(&quot;(&quot;+data+&quot;)&quot;)<br></code></pre></td></tr></table></figure><h4 id="75-json和jsonp的区别"><a href="#75-json和jsonp的区别" class="headerlink" title="75.json和jsonp的区别?"></a>75.json和jsonp的区别?</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">JSON是一种数据交换格式，而JSONP是一种非官方跨域数据交互协<br></code></pre></td></tr></table></figure><h4 id="76-如何用原生js给一个按钮绑定两个onclick事件？"><a href="#76-如何用原生js给一个按钮绑定两个onclick事件？" class="headerlink" title="76.如何用原生js给一个按钮绑定两个onclick事件？"></a>76.如何用原生js给一个按钮绑定两个onclick事件？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">addEventListener 事件监听 绑定多个事件<br></code></pre></td></tr></table></figure><h4 id="77-拖拽会用到哪些事件？"><a href="#77-拖拽会用到哪些事件？" class="headerlink" title="77.拖拽会用到哪些事件？"></a>77.拖拽会用到哪些事件？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">dragstart：按下鼠标键并开始移动时触发<br>dragend：元素拖拽停止时触发<br>drag：在元素拖拽过程中持续触发----相似与mousemove<br>dragenter：当拖拽对象进入投放区时触发<br>dragover ：拖拽对象在投放区内移动时持续触发<br>dragleave：元素被拖出了投放区时触发<br>drop：拖拽对象投放在投放区时触发<br></code></pre></td></tr></table></figure><h4 id="78-document-write和innerHTML的区别"><a href="#78-document-write和innerHTML的区别" class="headerlink" title="78.document.write和innerHTML的区别"></a>78.document.write和innerHTML的区别</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">document<span class="hljs-selector-class">.write</span>会重绘整个页面，而innerHTML是可以重绘页面的某一部分<br>write是DOM方法,向文档写入<span class="hljs-selector-tag">HTML</span>表达式或JavaScript代码，可列出多个参数，参数被顺序添加到文档中 ；<br>innerHTML是DOM属性,设置或返回调用元素开始结束标签之间的<span class="hljs-selector-tag">HTML</span>元素<br>两者都可向页面输出内容<br></code></pre></td></tr></table></figure><h4 id="79-jQuery的事件委托方法bind-、live、delegate、on之间有什么区别？"><a href="#79-jQuery的事件委托方法bind-、live、delegate、on之间有什么区别？" class="headerlink" title="79.jQuery的事件委托方法bind 、live、delegate、on之间有什么区别？"></a>79.jQuery的事件委托方法bind 、live、delegate、on之间有什么区别？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">bind定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；<br>live定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；<br>delegate定义和用法：将监听事件绑定在就近的父级元素上<br>on定义和用法：将监听事件绑定到指定元素上<br></code></pre></td></tr></table></figure><h4 id="80-浏览器是如何渲染页面的？"><a href="#80-浏览器是如何渲染页面的？" class="headerlink" title="80.浏览器是如何渲染页面的？"></a>80.浏览器是如何渲染页面的？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">解析<span class="hljs-selector-tag">html</span>代码，生成DOM tree<br>解析css代码，生成CSSOM tree<br>通过DOM tree 和 CSSOM tree 生成 Render tree<br>Layout（布局），计算Render tree中各个节点的位置及精确大小<br>Painting（绘制），将render tree渲染到页面上<br></code></pre></td></tr></table></figure><h4 id="81-document-ready-方法和window-onload有什么区别？"><a href="#81-document-ready-方法和window-onload有什么区别？" class="headerlink" title="81.$(document).ready()方法和window.onload有什么区别？"></a>81.$(document).ready()方法和window.onload有什么区别？</h4><p>window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。<br>$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。<br>window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个<br>$(document).ready()可以同时编写多个，并且都可以得到执行<br>window.onload没有简化写法 ;$(document).ready(function(){})可以简写成$(function(){});</p><h4 id="82-jquery中-get-提交和-post-提交有区别吗？"><a href="#82-jquery中-get-提交和-post-提交有区别吗？" class="headerlink" title="82. jquery中$.get()提交和$.post()提交有区别吗？"></a>82. jquery中$.get()提交和$.post()提交有区别吗？</h4><p>相同点：<br>都是异步请求的方式来获取服务端的数据。<br>不同点：<br>    请求方式不同：$.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。<br>    参数传递方式不同：GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。<br>    数据传输大小不同：GET方式传输的数据大小不能超过2KB，而POST要大的多。<br>    安全问题：GET方式请求的数据会被浏览器缓存起来，因此有安全问题。</p><h4 id="83-对前端路由的理解？前后端路由的区别？"><a href="#83-对前端路由的理解？前后端路由的区别？" class="headerlink" title="83.对前端路由的理解？前后端路由的区别？"></a>83.对前端路由的理解？前后端路由的区别？</h4><p>​很重要的一点是页面不刷新，前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，每跳转到不同的URL都是使用前端的锚点路由.随着（SPA）单页应用的不断普及，前后端开发分离，目前项目基本都使用前端路由，在项目使用期间页面不会重新加载。</p><h4 id="84-手写一个类的继承"><a href="#84-手写一个类的继承" class="headerlink" title="84.手写一个类的继承"></a>84.手写一个类的继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fa</span> &#123;<br>       <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>       &#125;<br>       <span class="hljs-title function_">set</span>(<span class="hljs-params"></span>) &#123;<br>           <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>]<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sa</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Fa</span> &#123;<br>       <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>           <span class="hljs-variable language_">super</span>(name)<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">var</span> dd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sa</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>   dd.<span class="hljs-title function_">set</span>()                <span class="hljs-comment">//[1,2,3]</span><br></code></pre></td></tr></table></figure><h4 id="85-XMLHttpRequest：XMLHttpRequest-readyState-状态码的意思"><a href="#85-XMLHttpRequest：XMLHttpRequest-readyState-状态码的意思" class="headerlink" title="85.XMLHttpRequest：XMLHttpRequest.readyState;状态码的意思"></a>85.XMLHttpRequest：XMLHttpRequest.readyState;状态码的意思</h4><p>0：请求未初始化，还没有调用 open() 。<br>1：请求已经建立，但是还没有发送，还没有调用 send() 。<br>2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。<br>3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。<br>4：响应已完成；您可以获取并使用服务器的响应了。</p><h4 id="86-JavaScript如何实现异步编程，有哪几种方式？"><a href="#86-JavaScript如何实现异步编程，有哪几种方式？" class="headerlink" title="86.JavaScript如何实现异步编程，有哪几种方式？"></a>86.JavaScript如何实现异步编程，有哪几种方式？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>.回调函数（Callback Functions）：这是最基础的异步编程方式，但它的缺点是在某些情况下可能导致“回调地狱”（回调函数嵌套回调函数，使代码变得难以理解和维护）。<br><span class="hljs-number">2</span><span class="hljs-selector-class">.Promises</span>：Promises是一种更优雅的异步编程方式，它返回一个表示异步操作结果的对象。Promises有三种状态：pending（待定），fulfilled（已实现），rejected（已拒绝）。使用Promises可以使代码更加整洁，并且可以避免回调地狱。<br><span class="hljs-number">3</span><span class="hljs-selector-class">.Async</span>/Await：这是基于Promises的一种更简洁的异步编程方式。async关键字表示一个函数是异步的，await关键字在一个async函数中，用于等待Promise的结果。<br><span class="hljs-number">4</span>.观察者模式或发布-订阅模式：在这种模式中，有一些对象（观察者）订阅一个对象（主题）的某种状态。当这个状态改变时，所有订阅了该状态的对象都会收到通知。这也是一种异步编程的模式。<br><span class="hljs-number">5</span>.生成器：生成器是ES6的一个新特性，它可以暂停和恢复执行上下文，这使得我们可以用它来编写类似于同步的异步代码。不过，生成器并不直接处理异步操作，而是通过暂停和恢复执行上下文来模拟异步操作。<br></code></pre></td></tr></table></figure><h4 id="87-解释JavaScript中的“this”关键字是如何工作的？"><a href="#87-解释JavaScript中的“this”关键字是如何工作的？" class="headerlink" title="87.解释JavaScript中的“this”关键字是如何工作的？"></a>87.解释JavaScript中的“this”关键字是如何工作的？</h4><p>​    “this”是一个关键字，它在函数被调用时被自动设定。其值取决于函数如何被调用，这取决于调用的上下文。</p><p>在函数被直接调用时，“this”通常指的是全局对象（在浏览器中是window，在Node.js中是global）。但是，当一个函数作为对象的方法被调用时，“this”指向的是调用它的对象，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;  <br>  <span class="hljs-attr">value</span>: <span class="hljs-number">10</span>,  <br>  <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++; <span class="hljs-comment">// &quot;this&quot; here refers to obj  </span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);  <br>  &#125;  <br>&#125;;  <br>obj.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 输出：11</span><br></code></pre></td></tr></table></figure><p>在上述代码中，<code>increment</code>函数是 <code>obj</code>对象的一个方法，所以当它被调用时，“this”指向的是 <code>obj</code>。</p><p>然而，在函数作为普通函数（不是对象的方法）被调用时，“this”的值是全局对象（在浏览器中是window，在Node.js中是global），除非在严格模式下（’use strict’），此时“this”是undefined。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) &#123;  <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <br>&#125;  <br>  <br><span class="hljs-title function_">func</span>(); <span class="hljs-comment">// 输出：window或global</span><br></code></pre></td></tr></table></figure><p>此外，可以使用call、apply或bind等方法显式设置函数的“this”。这些方法允许你手动指定函数内部的“this”应该指向哪个对象。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;  <br>  <span class="hljs-attr">value</span>: <span class="hljs-number">10</span>,  <br>  <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">amount</span>) &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> += amount;   <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);  <br>  &#125;  <br>&#125;;  <br>  <br><span class="hljs-keyword">let</span> anotherObj = &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">5</span>&#125;;  <br>obj.<span class="hljs-property">increment</span>.<span class="hljs-title function_">call</span>(anotherObj, <span class="hljs-number">2</span>); <span class="hljs-comment">// 输出：7，因为在这个上下文中，“this”指向的是anotherObj</span><br></code></pre></td></tr></table></figure><h4 id="88-解释JavaScript中的构造函数是什么，并给出一个例子？"><a href="#88-解释JavaScript中的构造函数是什么，并给出一个例子？" class="headerlink" title="88.解释JavaScript中的构造函数是什么，并给出一个例子？"></a>88.解释JavaScript中的构造函数是什么，并给出一个例子？</h4><p>​        构造函数是用来创建对象的函数。它们被设计用于初始化新创建的对象，并给这些对象设置属性和方法。</p><p>构造函数通常以大写字母开头，以区别于其他非构造函数。这是一种约定，虽然不是强制的，但为了保持一致性，大多数开发者都会遵循这个规则。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model, year</span>) &#123;  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make;  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;  <br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> = year;  <br>&#125;  <br><span class="hljs-comment">// 使用构造函数创建对象  </span><br><span class="hljs-keyword">let</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Toyota&#x27;</span>, <span class="hljs-string">&#x27;Corolla&#x27;</span>, <span class="hljs-number">2020</span>);  <br><span class="hljs-comment">// 输出结果：Toyota Corolla 2020  </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCar.<span class="hljs-property">make</span> + <span class="hljs-string">&#x27; &#x27;</span> + myCar.<span class="hljs-property">model</span> + <span class="hljs-string">&#x27; &#x27;</span> + myCar.<span class="hljs-property">year</span>);<br></code></pre></td></tr></table></figure><h4 id="89-JavaScript中的“undefined”和“null”有什么区别"><a href="#89-JavaScript中的“undefined”和“null”有什么区别" class="headerlink" title="89.JavaScript中的“undefined”和“null”有什么区别"></a>89.JavaScript中的“undefined”和“null”有什么区别</h4><p>​      “undefined”和“null”都表示缺乏值或没有值的情况。</p><ol><li>语义不同：<code>null</code>通常表示我们知道这个变量应该持有某个值，但现在它没有值。<code>undefined</code>则表示我们不知道这个变量应该持有什么样的值。也就是说，<code>null</code>是“有意识的空”，而 <code>undefined</code>是“无意识的空”。</li><li>在JavaScript中的表现：在JavaScript中，<code>undefined</code>和 <code>null</code>在某些情况下会被视为相等（即，<code>null == undefined</code>会返回 <code>true</code>），但实际上它们是不同的。使用 <code>===</code> 运算符可以区分它们，因为 <code>undefined</code> 是 <code>undefined</code>，而 <code>null</code> 是 <code>null</code>。</li><li>类型检查：使用 <code>typeof</code> 运算符可以检查一个变量的类型。如果变量是 <code>undefined</code>，<code>typeof</code> 会返回 “undefined”，如果变量是 <code>null</code>，<code>typeof</code> 会返回 “object”，这表明 <code>null</code> 被视为一种特殊的对象类型。</li><li>在JavaScript引擎内部：在JavaScript引擎的实现中，<code>null</code>通常用于表示对象引用的“终止”，或者表示某种“无”或“不存在”的情况。而 <code>undefined</code>则常常表示变量未被初始化。</li></ol><h4 id="90-请解释JavaScript中的事件循环机制"><a href="#90-请解释JavaScript中的事件循环机制" class="headerlink" title="90.请解释JavaScript中的事件循环机制"></a>90.请解释JavaScript中的事件循环机制</h4><p>1.检查调用栈是否为空。如果为空，继续等待事件队列中的新事件。<br>2.检查到事件队列中有新的事件（如用户交互、网络请求等）。<br>3.将新事件添加到调用栈的顶部。<br>4.执行调用栈中的任务，直到栈为空或遇到同步任务（如await、yield等）。<br>5.如果在执行过程中遇到了同步任务，将同步任务直接添加到调用栈中。<br>6.继续从事件队列中取出新事件，重复上述过程。</p><h4 id="91-JavaScript中的提升-Hoisting-是什么？请举例说明。"><a href="#91-JavaScript中的提升-Hoisting-是什么？请举例说明。" class="headerlink" title="91.JavaScript中的提升(Hoisting)是什么？请举例说明。"></a>91.JavaScript中的提升(Hoisting)是什么？请举例说明。</h4><p>​提升（Hoisting）是指变量和函数声明在代码被解析时被移动到它们所在作用域的顶部。</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VUE前端面试题</title>
    <link href="/blog/2022/11/24/interview-vue/"/>
    <url>/blog/2022/11/24/interview-vue/</url>
    
    <content type="html"><![CDATA[<h1 id="三十七个常见Vue面试题"><a href="#三十七个常见Vue面试题" class="headerlink" title="三十七个常见Vue面试题"></a>三十七个常见Vue面试题</h1><h2 id="一、谈谈你对MVVM的理解？"><a href="#一、谈谈你对MVVM的理解？" class="headerlink" title="一、谈谈你对MVVM的理解？"></a>一、谈谈你对MVVM的理解？</h2><p>映射关系简化，隐藏controller MVVM在MVC的基础上，把控制层隐藏掉了。</p><p><img src="https://s3.uuu.ovh/imgs/2022/11/24/ce6512d090a56abe.png"></p><p>Vue不是一个MVVM框架，它是一个视图层框架。</p><p>ViewModal是一个桥梁，将数据和视图进行关联。</p><h2 id="二、谈谈你对Vue中响应式数据的理解？"><a href="#二、谈谈你对Vue中响应式数据的理解？" class="headerlink" title="二、谈谈你对Vue中响应式数据的理解？"></a>二、谈谈你对Vue中响应式数据的理解？</h2><p>数组和对象类型的值变化的时候，通过 <code>defineReactive</code>方法，借助了 <code>defineProperty</code>，将所有的属性添加了 <code>getter</code>和 <code>setter</code>。用户在取值和设置的时候，可以进行一些操作。</p><p>缺陷：只能监控最外层的属性，如果是多层的，就要进行全量递归。</p><p>get里面会做依赖搜集（dep[watcher, watcher]） set里面会做数据更新（notify，通知watcher更新）</p><h2 id="三、Vue中如何检测数组的变化？"><a href="#三、Vue中如何检测数组的变化？" class="headerlink" title="三、Vue中如何检测数组的变化？"></a>三、Vue中如何检测数组的变化？</h2><p>vue中对数组没有进行defineProperty，而是重写了数组的7个方法。 分别是：</p><ul><li>push</li><li>shift</li><li>pop</li><li>splice</li><li>unshift</li><li>sort</li><li>reverse</li></ul><p>因为这些方法都会改变数组本身。</p><p>数组里的索引和长度是无法被监控的。</p><h2 id="四、Vue中如何进行依赖收集的？"><a href="#四、Vue中如何进行依赖收集的？" class="headerlink" title="四、Vue中如何进行依赖收集的？"></a>四、Vue中如何进行依赖收集的？</h2><p><img src="https://s3.uuu.ovh/imgs/2022/11/24/1702b130260c3529.png"></p><p>Vue初始化的时候，挂载之后会进行编译。生成renderFunction。</p><p>当取值的时候，就会搜集watcher，放到dep里面。</p><p>当用户更改值的时候，就会通知watcher，去更新视图。</p><h2 id="五、如何理解Vue中的模板编译原理？"><a href="#五、如何理解Vue中的模板编译原理？" class="headerlink" title="五、如何理解Vue中的模板编译原理？"></a>五、如何理解Vue中的模板编译原理？</h2><p>这个问题的核心是如何将template转换成render函数。</p><ol><li>将template模块转换成ast语法书 - parserHTML</li><li>对静态语法做标记（某些节点不改变）</li><li>重新生成代码 - codeGen,使用with语法包裹字符串</li></ol><h2 id="六、Vue生命周期钩子是如何实现的"><a href="#六、Vue生命周期钩子是如何实现的" class="headerlink" title="六、Vue生命周期钩子是如何实现的?"></a>六、Vue生命周期钩子是如何实现的?</h2><p>Vue的生命周期钩子是回调函数，当创建组件实例的过程中会调用相应的钩子方法。 内部会对钩子进行处理，将钩子函数维护成数组的形式。</p><h2 id="七、Vue组件生命周期有哪些？"><a href="#七、Vue组件生命周期有哪些？" class="headerlink" title="七、Vue组件生命周期有哪些？"></a>七、Vue组件生命周期有哪些？</h2><ul><li><p>beforeCreate 在实例初始化之后，数据观测observer 和event、watcher事件配置之前被调用</p></li><li><p>created 实例已经创建完成，在这一步，以下配置被完成</p><ul><li>数据观测</li><li>属性和方法的运算</li><li>watch&#x2F;event时间回调</li><li>$el尚未生成</li></ul></li><li><p>beforeMount 在挂载之前被调用，render尚未被调用</p></li><li><p>mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用</p></li><li><p>beforeUpdate 数据更新时，被调用，发生在虚拟Dom重新渲染和打补丁之前</p></li><li><p>update 由于数据更改导致的虚拟Dom重新渲染和打补丁，在这之后调用</p></li><li><p>beforeDestroy 实例销毁之前调用</p></li><li><p>destroyed 实例销毁之后调用，调用后Vue实例的所有东西都会被解绑，所有的事件监听会被移除，子实例被销毁，该钩子在服务端渲染期间不被调用</p></li><li><p>keep-alive（activated &amp; deactivated）</p></li></ul><h2 id="八、vue-mixin的使用场景和原理"><a href="#八、vue-mixin的使用场景和原理" class="headerlink" title="八、vue.mixin的使用场景和原理?"></a>八、vue.mixin的使用场景和原理?</h2><p>Vue的mixin的作用就是抽离公共的业务逻辑，原理类似对象的继承，当组件初始化的时候，会调用mergeOptions方法进行合并，采用策略模式针对不同的属性进行合并。 如果混入的数据和本身组件的数据有冲突，采用本身的数据为准。</p><p>缺点：命名冲突、数据来源不清晰</p><h2 id="九、Vue的组件data为什么必须是一个函数"><a href="#九、Vue的组件data为什么必须是一个函数" class="headerlink" title="九、Vue的组件data为什么必须是一个函数?"></a>九、Vue的组件data为什么必须是一个函数?</h2><p><code>new Vue</code>是一个单例模式，不会有任何的合并操作，所以根实例不必校验data一定是一个函数。 组件的data必须是一个函数，是为了防止两个组件的数据产生污染。 如果都是对象的话，会在合并的时候，指向同一个地址。 而如果是函数的时候，合并的时候调用，会产生两个空间。</p><h2 id="十、请说明nextTick的原理。"><a href="#十、请说明nextTick的原理。" class="headerlink" title="十、请说明nextTick的原理。"></a>十、请说明nextTick的原理。</h2><p>nextTick是一个微任务。</p><ul><li>nextTick中的回调是在下次Dom更新循环结束之后执行的延迟回调</li><li>可以用于获取更新后的Dom</li><li>Vue中的数据更新是异步的，使用nextTick可以保证用户定义的逻辑在更新之后执行</li></ul><h2 id="十一、computed和watch的区别是什么？"><a href="#十一、computed和watch的区别是什么？" class="headerlink" title="十一、computed和watch的区别是什么？"></a>十一、computed和watch的区别是什么？</h2><ul><li>computed和watch都基于watcher来实现的。</li><li>computed的属性是具备缓存的，依赖的值不发生变化，对其取值时计算属性方法不会重复执行</li><li>watch是监控值的变化，当值发生改变的时候，会调用回调函数</li></ul><h2 id="十二、Vue-set方法是如何实现的？"><a href="#十二、Vue-set方法是如何实现的？" class="headerlink" title="十二、Vue.set方法是如何实现的？"></a>十二、Vue.set方法是如何实现的？</h2><ul><li>vue给对象和数组本身都增加了dep属性</li><li>当给对象新增不存在的属性的时候，就会触发对象依赖的watcher去更新</li><li>当修改数组索引的时候，就调用数组本身的splice方法去更新数组</li></ul><h2 id="十三、Vue为什么要用虚拟Dom"><a href="#十三、Vue为什么要用虚拟Dom" class="headerlink" title="十三、Vue为什么要用虚拟Dom"></a>十三、Vue为什么要用虚拟Dom</h2><ul><li>虚拟dom就是用js对象来描述真实Dom，是对真实Dom的抽象</li><li>由于直接操作Dom性能低，但是js层的操作效率高，可以将Dom操作转化成对象操作。最终通过diff算法比对差异进行更新Dom</li><li>虚拟Dom不依赖真实平台环境，可以实现跨平台</li></ul><h2 id="十四、Vue的diff算法原理是什么？"><a href="#十四、Vue的diff算法原理是什么？" class="headerlink" title="十四、Vue的diff算法原理是什么？"></a>十四、Vue的diff算法原理是什么？</h2><p>Vue的diff算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式+双指针方式比较</p><ul><li>先比较两个节点是不是相同节点</li><li>相同节点比较属性，复用老节点</li><li>先比较儿子节点，考虑老节点和新节点儿子的情况</li><li>优化比较：头头、尾尾、头尾、尾头</li><li>比对查找，进行复用</li></ul><h2 id="十五、既然vue通过数据劫持可以精准的探测数据变化，为什么还要进行diff检测差异？"><a href="#十五、既然vue通过数据劫持可以精准的探测数据变化，为什么还要进行diff检测差异？" class="headerlink" title="十五、既然vue通过数据劫持可以精准的探测数据变化，为什么还要进行diff检测差异？"></a>十五、既然vue通过数据劫持可以精准的探测数据变化，为什么还要进行diff检测差异？</h2><ul><li>响应式数据变化，Vue确实可以在数据变化的时候，响应式系统可以立刻得知。但是如何每个属性都添加watcher的话，性能会非常的差。</li><li>粒度过细，会导致更新不精准</li></ul><p>所以采用watcher + Diff算法来检测差异。</p><h2 id="十六、请说明key的作用和原理"><a href="#十六、请说明key的作用和原理" class="headerlink" title="十六、请说明key的作用和原理"></a>十六、请说明key的作用和原理</h2><ul><li>Vue在patch过程中，通过key可以判断两个虚拟节点是否是相同节点。</li><li>没有key会导致更新的时候出问题</li><li>尽量不要采用索引作为key</li></ul><p><img src="https://s3.uuu.ovh/imgs/2022/11/24/3fc0c4b383b9ccd0.png"></p><h2 id="十七、谈谈对组件的理解"><a href="#十七、谈谈对组件的理解" class="headerlink" title="十七、谈谈对组件的理解"></a>十七、谈谈对组件的理解</h2><ul><li>组件化开发能大幅提高应用开发效率、测试性、复用性</li><li>常用的组件化技术：属性、自定义事件、插槽</li><li>降低更新范围，值重新渲染变化的组件</li><li>高内聚、低耦合、单向数据流</li></ul><h2 id="十八、请描述组件的渲染流程"><a href="#十八、请描述组件的渲染流程" class="headerlink" title="十八、请描述组件的渲染流程"></a>十八、请描述组件的渲染流程</h2><p>产生组件虚拟节点 -&gt; 创建组件的真实节点 -&gt; 插入到页面</p><p><img src="https://s3.uuu.ovh/imgs/2022/11/24/875fb72e04f47f43.png"></p><h2 id="十九、请描述组件的更新流程"><a href="#十九、请描述组件的更新流程" class="headerlink" title="十九、请描述组件的更新流程"></a>十九、请描述组件的更新流程</h2><p>属性更新会触发patchVnode方法，组件的虚拟节点会调用prepatch钩子，然后更新属性，更新组件。</p><p><img src="https://s3.uuu.ovh/imgs/2022/11/24/f81d83c811e12b4d.png"></p><h2 id="二十、异步组件原理"><a href="#二十、异步组件原理" class="headerlink" title="二十、异步组件原理"></a>二十、异步组件原理</h2><p>先渲染异步占位符节点 -&gt; 组件加载完毕后调用forceUpdate强制更新。</p><h2 id="二十一、函数组件的优势和原理"><a href="#二十一、函数组件的优势和原理" class="headerlink" title="二十一、函数组件的优势和原理"></a>二十一、函数组件的优势和原理</h2><ul><li>函数式组件的特性：无状态、无生命周期、无this。因此性能会高一点。</li></ul><p>正常的一个组件是一个类继承了Vue。</p><p>函数式组件，就是一个普通的函数。</p><h2 id="二十二、组件的传值方式有哪些？"><a href="#二十二、组件的传值方式有哪些？" class="headerlink" title="二十二、组件的传值方式有哪些？"></a>二十二、组件的传值方式有哪些？</h2><ol><li>props和emit: 父组件向子组件传递数据，通过prop传递。子组件传递数据给父组件是通过<em>e<strong>m</strong>i**t</em>:父组件向子组件传递数据，通过<em>p<strong>r</strong>o**p</em>传递。子组件传递数据给父组件是通过emit事件</li><li>parent,<em>p<strong>a</strong>r<strong>e</strong>n**t</em>,children获取当前组件的父组件和当前组件的子组件</li><li>attrs和<em>a<strong>t</strong>t<strong>r</strong>s</em>和listeners 。</li><li>父组件通过provide提供，子组件通过inject注入变量</li><li>$ref获取实例</li><li>eventBus平级组件数据传递</li><li>Vuex</li></ol><h2 id="二十三、-attrs是为了解决什么问题出现的？"><a href="#二十三、-attrs是为了解决什么问题出现的？" class="headerlink" title="二十三、$attrs是为了解决什么问题出现的？"></a>二十三、$attrs是为了解决什么问题出现的？</h2><p>主要作用是为了实现批量传递数据。</p><p>provide&#x2F;inject更适合应用在插件中，主要实现跨级数据传递。</p><h2 id="二十四、v-for和v-if哪个优先级更高？"><a href="#二十四、v-for和v-if哪个优先级更高？" class="headerlink" title="二十四、v-for和v-if哪个优先级更高？"></a>二十四、v-for和v-if哪个优先级更高？</h2><p>首先，v-for和v-if 不能在同一个标签中使用。</p><p>先处理v-for，再处理v-if。</p><p>如果同时遇到的时候，应该考虑先用计算属性处理数据，在进行v-for，可以减少循环次数。</p><h2 id="二十五、v-mode是如何实现的？"><a href="#二十五、v-mode是如何实现的？" class="headerlink" title="二十五、v-mode是如何实现的？"></a>二十五、v-mode是如何实现的？</h2><p>在组件上用的v-model，是model和callback</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">with</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">_c</span>(<span class="hljs-string">&#x27;my&#x27;</span>,&#123;<span class="hljs-attr">model</span>:&#123;<span class="hljs-attr">value</span>:(xxx),<span class="hljs-attr">callback</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params">$$v</span>) &#123;xxx=$$v&#125;,<span class="hljs-attr">expression</span>:<span class="hljs-string">&quot;xxx&quot;</span>&#125;&#125;)&#125;<br></code></pre></td></tr></table></figure><p>在普通元素上用v-model，会生成指令，还可能因为不同的元素：</p><ul><li>生成value和input</li><li>生成change和radio</li><li>生成change和checked</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">with</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">_c</span>(<span class="hljs-string">&#x27;input&#x27;</span>,&#123;<span class="hljs-attr">directives</span>:[&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;model&quot;</span>,<span class="hljs-attr">rawName</span>:<span class="hljs-string">&quot;v-model&quot;</span>,<span class="hljs-attr">value</span>:(xxx),<span class="hljs-attr">expression</span>:<span class="hljs-string">&quot;xxx&quot;</span>&#125;],<span class="hljs-attr">domProps</span>:&#123;<span class="hljs-string">&quot;value&quot;</span>:(xxx)&#125;,<span class="hljs-attr">on</span>:&#123;<span class="hljs-string">&quot;input&quot;</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">$event</span>)&#123;<span class="hljs-keyword">if</span>($event.<span class="hljs-property">target</span>.<span class="hljs-property">composing</span>)<span class="hljs-keyword">return</span>;xxx=$event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;&#125;&#125;)&#125;<br></code></pre></td></tr></table></figure><p>指令在什么时候会调用？</p><p><img src="https://s3.uuu.ovh/imgs/2022/11/24/c901f8b9cbbec7a6.png"></p><p>源码：</p><p><img src="https://s3.uuu.ovh/imgs/2022/11/25/b122004dd6c1dde3.png"></p><h2 id="二十六、Vue的普通Slot以及作用域Slot的区别"><a href="#二十六、Vue的普通Slot以及作用域Slot的区别" class="headerlink" title="二十六、Vue的普通Slot以及作用域Slot的区别"></a>二十六、Vue的普通Slot以及作用域Slot的区别</h2><h3 id="普通插槽"><a href="#普通插槽" class="headerlink" title="普通插槽"></a>普通插槽</h3><p>普通插槽是渲染后做替换的工作。父组件渲染完毕后，替换子组件的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">`&lt;div&gt;</span><br><span class="hljs-string">&lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;</span><br><span class="hljs-string">&lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;</span><br><span class="hljs-string">&lt;/div&gt;`</span>);<br><span class="hljs-comment">// with(this)&#123;return _c(&#x27;div&#x27;,[_t(&quot;title&quot;),_v(&quot; &quot;),_t(&quot;content&quot;)],2)&#125;</span><br></code></pre></td></tr></table></figure><p>在模板编译的时候，处理组件中的子节点和slot标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div id=&quot;app&quot;&gt;<br>    &lt;my&gt;<br>        &lt;h1 slot=&quot;tit1e&quot;&gt;标题&lt;/h1&gt;<br>        &lt;div slot=&quot;content&quot;&gt;内容&lt;/div&gt;<br>    &lt;/my&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    Vue.component(&#x27;my&#x27;,&#123;<br>        template: `&lt;div&gt;<br>        &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;<br>&lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;<br>        &lt;/div&gt;`<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在创建元素的时候，用_t()方法方法来替换_v()的内容。</p><p><img src="https://s3.uuu.ovh/imgs/2022/11/24/9978507b1f505a3d.png"></p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽可以拿到子组件里面的属性。在子组件中传入属性然后渲染。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div id=&quot;app&quot;&gt;<br>    &lt;my&gt;<br>        &lt;template slot-scope=&quot;&#123;article)&quot;&gt;<br>            &lt;h1 slot=&quot;article.tit1e&quot;&gt;标题&lt;/h1&gt;<br>            &lt;div slot=&quot;article.content&quot;&gt;内容&lt;/div&gt;<br>        &lt;/template&gt;<br>    &lt;/my&gt;<br>&lt;/div&gt;<br>&lt;script&gt;<br>    Vue.component(&#x27;my&#x27;,&#123;<br>        template: `&lt;div&gt;<br>        &lt;slot:article=&quot;&#123;title:&#x27;标题&#x27;,content:&#x27;内容&#x27;&#125;&quot;&gt;&lt;/slot&gt;<br>        &lt;/div&gt;`<br>    &#125;)<br>    const vm new Vue(&#123;<br>    el:&#x27;#app<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">`&lt;my&gt;</span><br><span class="hljs-string">    &lt;h1 slot=”title&quot;&gt;标题&lt;h1/&gt;</span><br><span class="hljs-string">    &lt;div slot=&quot;content&quot;&gt;内容&lt;/div&gt;</span><br><span class="hljs-string">&lt;/my&gt;`</span>)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">with(this)&#123;</span><br><span class="hljs-comment">    return _c(&#x27;my&#x27;,[</span><br><span class="hljs-comment">    _c(&#x27;h1&#x27;,&#123;attrs:&#123;&quot;slot&quot;:&quot;title&#x27;&quot;&#125;,slot:&quot;title&quot;&#125;,[_v(&quot;标题&quot;)]),_v(&quot; &quot;),</span><br><span class="hljs-comment">    _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;slot&quot;:&quot;content&quot;,slot:&quot;content&quot;&#125;,[_v(&quot;内容&quot;)])</span><br><span class="hljs-comment">    ])</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure><p>作用域插槽的编译结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> r3 = templateCompiler.<span class="hljs-title function_">compile</span>(<span class="hljs-string">`</span><br><span class="hljs-string">&lt;div&gt;</span><br><span class="hljs-string">&lt;slot :article=&quot;&#123;title:&#x27;标题&#x27;,content:&#x27;内容&#x27;&#125;&quot;&gt;&lt;/slot&gt;</span><br><span class="hljs-string">&lt;/div&gt;`</span>)<br><span class="hljs-comment">// with(this)&#123;return _c(&#x27;div&#x27;,[_t(&quot;default&quot;,null,&#123;&quot;article&quot;:&#123;title:&#x27;标题&#x27;,</span><br><span class="hljs-comment">// content:&#x27;内容&#x27;&#125;&#125;)],2)&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r3.<span class="hljs-property">render</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">`&lt;my&gt;</span><br><span class="hljs-string">    &lt;template slot-scope=&quot;&#123;article&#125;&quot;&gt;</span><br><span class="hljs-string">        &lt;h1 slot=&quot;article.tit1e&quot;&gt;标题&lt;/h1&gt;</span><br><span class="hljs-string">        &lt;div slot=&quot;article.content&quot;&gt;内容&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/template&gt;</span><br><span class="hljs-string">&lt;/my&gt;`</span>)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">with(this)&#123;return _c(&#x27;my&#x27;,</span><br><span class="hljs-comment">    &#123;scopedslofs:_u([</span><br><span class="hljs-comment">        &#123;key:&quot;default&quot;,fn:function(&#123;article&#125;)&#123;</span><br><span class="hljs-comment">            return [</span><br><span class="hljs-comment">                _c(&#x27;h1&#x27;,&#123;attrs:&#123;&quot;slot&quot;:&quot;article.title&quot;),slot:&quot;article.</span><br><span class="hljs-comment">                tit1e&quot;&#125;,[_v(&quot;标题&quot;)]),</span><br><span class="hljs-comment">                _v(&quot; &quot;),</span><br><span class="hljs-comment">                _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;slot&quot;:&quot;article.content&quot;&#125;,slot:&quot;article.</span><br><span class="hljs-comment">                content&quot;&#125;,[_v(&quot;内容&quot;)])</span><br><span class="hljs-comment">            ]</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">])</span><br></code></pre></td></tr></table></figure><h2 id="二十八、Vue-use是干什么的？"><a href="#二十八、Vue-use是干什么的？" class="headerlink" title="二十八、Vue.use是干什么的？"></a>二十八、Vue.use是干什么的？</h2><p><code>Vue.use</code>是用来使用插件的。我们可以在插件中扩展全局组件、指令、原型方法等。 会调用 <code>install</code>方法将Vue的构建函数默认传入，在插件中可以使用vue，无需依赖vue库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">use</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">plugin: <span class="hljs-built_in">Function</span> | <span class="hljs-built_in">Object</span></span>) &#123;<br>    <span class="hljs-comment">// 插件缓存</span><br>    <span class="hljs-keyword">const</span> installedPlugins = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_installedPlugins</span> || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_installedP1ugins</span> =<br>    []))<br>    <span class="hljs-keyword">if</span> (installedPlugins.<span class="hljs-title function_">indexof</span>(plugin) &gt; -<span class="hljs-number">1</span>) &#123; V<span class="hljs-comment">// 如果已经有插件 直接返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>    &#125;<br>  <br>    <span class="hljs-comment">// additional parameters</span><br>    <span class="hljs-keyword">const</span> args = <span class="hljs-title function_">toArray</span>(<span class="hljs-variable language_">arguments</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">// 除了第一项其他的参数整合成数组</span><br>    args.<span class="hljs-title function_">unshift</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 将Vue 放信到数组中</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin.<span class="hljs-property">install</span> ===“<span class="hljs-string">&#x27;function&#x27;</span>) &#123; <span class="hljs-comment">// 调用install方法</span><br>    plugin.<span class="hljs-property">instal11</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Cplugin</span>,args)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin ===“<span class="hljs-string">&#x27;function&#x27;</span>) &#123; <span class="hljs-comment">// 直接调用方法</span><br>    plugin.<span class="hljs-title function_">app1y</span>(<span class="hljs-literal">null</span>,args)<br>    了<br>    installedPlugins.<span class="hljs-title function_">push</span>(plugin) <span class="hljs-comment">// 缓存插件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>&#125;                                                      <br><br></code></pre></td></tr></table></figure><h2 id="二十九、组件写name有啥好处？"><a href="#二十九、组件写name有啥好处？" class="headerlink" title="二十九、组件写name有啥好处？"></a>二十九、组件写name有啥好处？</h2><ul><li>增加name属性，会在components属性中增加组件本身，实现组件的递归调用。</li><li>可以表示组件的具体名称，方便调试和查找对应的组件。</li></ul><h2 id="三十、vue的修饰符有哪些？"><a href="#三十、vue的修饰符有哪些？" class="headerlink" title="三十、vue的修饰符有哪些？"></a>三十、vue的修饰符有哪些？</h2><ul><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self</li><li>.once</li><li>.passive</li><li>.right</li><li>.center</li><li>.middle</li><li>.alt</li></ul><h2 id="三十一、如何理解自定义指令？"><a href="#三十一、如何理解自定义指令？" class="headerlink" title="三十一、如何理解自定义指令？"></a>三十一、如何理解自定义指令？</h2><ul><li>在生成ast语法树时，遇到指令会给当前元素添加directives属性</li><li>通过genDirectives生成指令代码</li><li>在patch前，将指令的钩子提取到cbs中，在patch过程中调用对应的钩子</li><li>当执行cbs对应的钩子时，调用对应指令定义方法</li></ul><h2 id="三十二、keep-alive平时在哪里使用？原理是什么？"><a href="#三十二、keep-alive平时在哪里使用？原理是什么？" class="headerlink" title="三十二、keep-alive平时在哪里使用？原理是什么？"></a>三十二、keep-alive平时在哪里使用？原理是什么？</h2><ul><li>使用keep-alive包裹动态组件时，会对组件进行缓存，避免组件重新创建</li></ul><p>使用有两个场景，一个是动态组件，一个是router-view</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive :include=&quot;whiteList&quot; :exclude=&quot;blackList&quot; :max=&quot;count&quot;&gt;<br>    &lt;component :is=&quot;component&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive :include=&quot;whiteList&quot; :exclude=&quot;blackList&quot; :max=&quot;count&quot;&gt;<br>    &lt;router-view&gt;&lt;/router-view&gt;<br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><p>这里创建了一个白名单和一个黑名单。表明哪些需要需要做缓存，哪些不需要做缓存。以及最大的缓存个数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,<br>    <span class="hljs-attr">abstract</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 不会放到对应的lifecycle</span><br>  <br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">include</span>: patternTypes,<span class="hljs-comment">//白名单</span><br>        <span class="hljs-attr">exclude</span>: patternTypes,<span class="hljs-comment">//黑名单</span><br>        <span class="hljs-attr">max</span>: [<span class="hljs-title class_">String</span>,<span class="hljs-title class_">Number</span>] <span class="hljs-comment">//缓存的最大个数</span><br>    &#125;,<br>  <br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">//缓存列表</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span> = [] <span class="hljs-comment">//缓存的key列表</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缓存的是组件的实例，用key和value对象保存。</p><p>加载的时候，监控include和exclude。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">//监控缓存列表</span><br><span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;include&#x27;</span>,<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123; <span class="hljs-comment">//缓存列表可以是动态的</span><br><span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-title function_">matches</span>(val,name))<br>&#125;)<br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;exclude&#x27;</span>,<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br><span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> !<span class="hljs-title function_">matches</span>(val,name))<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不需要缓存，直接返回虚拟节点。</p><p>如果需要缓存，就用组件的id和标签名，生成一个key，把当前vnode的instance作为value，存成一个对象。这就是缓存列表</p><p>如果设置了最大的缓存数，就删除第0个缓存。新增最新的缓存。</p><p>并且给组件添加一个keepAlive变量为true，当组件初始化的时候，不再初始化。</p><h2 id="三十三、vue-router有几种钩子函数？执行流程如何？"><a href="#三十三、vue-router有几种钩子函数？执行流程如何？" class="headerlink" title="三十三、vue-router有几种钩子函数？执行流程如何？"></a>三十三、vue-router有几种钩子函数？执行流程如何？</h2><p>钩子函数有三种：</p><ul><li>全局守卫</li><li>路由守卫</li><li>组件守卫</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tex">1.导航被触发。<br>2.在失活的组件里调用beforeRouteLeave守卫<br>3.调用全局的beforeEach守卫。<br>4.在重用的组件里调用beforeRouteUpdate守卫（2.2+）。<br>5.在路由配置里调用beforeEnter。<br>6.解析异步路由组件。<br>7.在被激活的组件里调用beforeRouteEnter。<br>8.调用全局的beforeResolve守卫（2.5+）。<br>9.导航被确认。<br>10.调用全局的afertEach钩子。<br>11.触发DOM更新。<br>12.调用beforeRouteEnter守卫中传给next的回调函数，创建好的组件实例会作为回调函数的参数传入。<br></code></pre></td></tr></table></figure><h2 id="三十四、vuerouter的两种模式的区别"><a href="#三十四、vuerouter的两种模式的区别" class="headerlink" title="三十四、vuerouter的两种模式的区别"></a>三十四、vuerouter的两种模式的区别</h2><ul><li>vue-router中有三种模式，分别是hash、history、abstract</li><li>abstract在不支持浏览器的API换景使用</li><li>hash模式兼容性好，但是不美观，不利于SEO</li><li>history美观，historyAPI+popState，但是刷新会出现404</li></ul><h2 id="三十五、谈谈Vue的性能优化有哪些？"><a href="#三十五、谈谈Vue的性能优化有哪些？" class="headerlink" title="三十五、谈谈Vue的性能优化有哪些？"></a>三十五、谈谈Vue的性能优化有哪些？</h2><ul><li>数据层级不要过深，合理的设置响应式数据</li><li>使用数据时，缓存值的结果，不频繁取值</li><li>合理设置key</li><li>v-show(频繁切换性能高)和v-if的合理使用</li><li>控制组件的粒度 -&gt; Vue采用组件级别更新</li><li>采用函数式组件 -&gt; 函数式组价开销低</li><li>采用异步组件 -&gt; 借助webpack的分包策略</li><li>使用keep-alive来缓存组件</li><li>虚拟滚动、时间分片等策略</li><li>打包优化</li></ul><h2 id="三十六、谈谈你对Vuex的理解？"><a href="#三十六、谈谈你对Vuex的理解？" class="headerlink" title="三十六、谈谈你对Vuex的理解？"></a>三十六、谈谈你对Vuex的理解？</h2><p>Vuex是专门为vue提供的全局状态管理系统，用于多个组件中的数据共享、数据缓存。</p><p>问题：无法持久化。</p><p><img src="https://s3.uuu.ovh/imgs/2022/11/25/f58979101b7d029d.png"></p><ul><li>mutation 主要修改状态，同步执行</li><li>action 执行业务代码，方便复用，逻辑可以为异步。不能直接修改状态。</li></ul><h2 id="三十七、vue中使用了哪些设计模式？"><a href="#三十七、vue中使用了哪些设计模式？" class="headerlink" title="三十七、vue中使用了哪些设计模式？"></a>三十七、vue中使用了哪些设计模式？</h2><ul><li>单例模式：new多次，只有一个实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">install</span> (<span class="hljs-params">_Vue</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Vue</span> &amp;&amp; _Vue === <span class="hljs-title class_">Vue</span>) &#123;<br>        <span class="hljs-keyword">if</span>(__DEV__)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<br>            <span class="hljs-string">&#x27;[vuex] already installed. Vue.use(Vuex) should be called only once.&#x27;</span><br>            )<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-title class_">Vue</span> = _Vue<br>    <span class="hljs-title function_">applyMixin</span>(<span class="hljs-title class_">Vue</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>工场模式：传入参数就可以创建实例（虚拟节点的创建）</li><li>发布订阅模式：eventBus</li><li>观察者模式：watch和dep</li><li>代理模式：_data属性、proxy、防抖、节流</li><li>中介者模式：vuex</li><li>策略模式</li><li>外观模式</li></ul>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack优化</title>
    <link href="/blog/2022/11/24/webpack-optimization/"/>
    <url>/blog/2022/11/24/webpack-optimization/</url>
    
    <content type="html"><![CDATA[<h1 id="Webpack优化"><a href="#Webpack优化" class="headerlink" title="Webpack优化"></a>Webpack优化</h1><h2 id="一、构建时间优化"><a href="#一、构建时间优化" class="headerlink" title="一、构建时间优化"></a>一、构建时间优化</h2><p>首先就是构建时间的优化了</p><h3 id="1-thread-loader"><a href="#1-thread-loader" class="headerlink" title="1.thread-loader"></a>1.thread-loader</h3><p>多进程打包，可以大大提高构建的速度，使用方法是将<code>thread-loader</code>放在比较费时间的loader之前，比如<code>babel-loader</code></p><blockquote><p>由于启动项目和打包项目都需要加速，所以配置在<code>webpack.base.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i thread-loader -D <br><span class="hljs-comment">// webpack.base.js</span><br><br>&#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-attr">use</span>: [<br>          <span class="hljs-string">&#x27;thread-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;babel-loader&#x27;</span><br>        ],<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-cache-loader"><a href="#2-cache-loader" class="headerlink" title="2.cache-loader"></a>2.cache-loader</h3><p>缓存资源，提高二次构建的速度，使用方法是将<code>cache-loader</code>放在比较费时间的loader之前，比如<code>babel-loader</code></p><blockquote><p>由于启动项目和打包项目都需要加速，所以配置在<code>webpack.base.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i cache-loader -D<br> <br><span class="hljs-comment">// webpack.base.js</span><br><br>&#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-attr">use</span>: [<br>          <span class="hljs-string">&#x27;cache-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;thread-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;babel-loader&#x27;</span><br>        ],<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="3-开启热更新"><a href="#3-开启热更新" class="headerlink" title="3.开启热更新"></a>3.开启热更新</h3><p>比如你修改了项目中某一个文件，会导致整个项目刷新，这非常耗时间。如果只刷新修改的这个模块，其他保持原状，那将大大提高修改代码的重新构建时间</p><blockquote><p>只用于开发中，所以配置在<code>webpack.dev.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.dev.js</span><br><br><span class="hljs-comment">//引入webpack</span><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<br><span class="hljs-comment">//使用webpack提供的热更新插件</span><br>   <span class="hljs-attr">plugins</span>: [<br>   <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>()<br>    ],<br>    <span class="hljs-comment">//最后需要在我们的devserver中配置</span><br>     <span class="hljs-attr">devServer</span>: &#123;<br>+     <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span><br>    &#125;,<br></code></pre></td></tr></table></figure><h3 id="4-exclude-include"><a href="#4-exclude-include" class="headerlink" title="4.exclude &amp; include"></a>4.exclude &amp; include</h3><ul><li><code>exclude</code>：不需要处理的文件</li><li><code>include</code>：需要处理的文件</li></ul><p>合理设置这两个属性，可以大大提高构建速度</p><blockquote><p>在<code>webpack.base.js</code>中配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.base.js</span><br><br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-comment">//使用include来指定编译文件夹</span><br>        <span class="hljs-attr">include</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;../src&#x27;</span>),<br>        <span class="hljs-comment">//使用exclude排除指定文件夹</span><br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>        <span class="hljs-attr">use</span>: [<br>          <span class="hljs-string">&#x27;babel-loader&#x27;</span><br>        ]<br>      &#125;,<br></code></pre></td></tr></table></figure><h3 id="5-构建区分环境"><a href="#5-构建区分环境" class="headerlink" title="5.构建区分环境"></a>5.构建区分环境</h3><p>区分环境去构建是非常重要的，我们要明确知道，开发环境时我们需要哪些配置，不需要哪些配置；而最终打包生产环境时又需要哪些配置，不需要哪些配置：</p><ul><li><code>开发环境</code>：去除代码压缩、gzip、体积分析等优化的配置，大大提高构建速度</li><li><code>生产环境</code>：需要代码压缩、gzip、体积分析等优化的配置，大大降低最终项目打包体积</li></ul><blockquote><p>上篇文章已经带大家进行了环境区分</p></blockquote><h3 id="6-提升webpack版本"><a href="#6-提升webpack版本" class="headerlink" title="6.提升webpack版本"></a>6.提升webpack版本</h3><p>webpack版本越新，打包的效果肯定更好</p><h2 id="二、打包体积优化"><a href="#二、打包体积优化" class="headerlink" title="二、打包体积优化"></a>二、打包体积优化</h2><p>主要是打包后项目整体体积的优化，有利于项目上线后的页面加载速度提升</p><blockquote><p>本项目已经是webpack最新版本</p></blockquote><h3 id="1-CSS代码压缩"><a href="#1-CSS代码压缩" class="headerlink" title="1.CSS代码压缩"></a>1.CSS代码压缩</h3><p>CSS代码压缩使用<code>css-minimizer-webpack-plugin</code>，效果包括压缩、去重</p><blockquote><p>代码的压缩比较耗时间，所以只用在打包项目时，所以只需要在<code>webpack.prod.js</code>中配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i css-minimizer-webpack-plugin -D<br> <br><span class="hljs-comment">// webpack.prod.js</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)<br><br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">minimizer</span>: [<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>(), <span class="hljs-comment">// 去重压缩css</span><br>    ],<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="2-JS代码压缩"><a href="#2-JS代码压缩" class="headerlink" title="2.JS代码压缩"></a>2.JS代码压缩</h3><p>JS代码压缩使用<code>terser-webpack-plugin</code>，实现打包后JS代码的压缩</p><blockquote><p>代码的压缩比较耗时间，所以只用在打包项目时，所以只需要在<code>webpack.prod.js</code>中配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i terser-webpack-plugin -D<br> <br><span class="hljs-comment">// webpack.prod.js</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>)<br><br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">minimizer</span>: [<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>(), <span class="hljs-comment">// 去重压缩css</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(&#123; <span class="hljs-comment">// 压缩JS代码</span><br>        <span class="hljs-attr">terserOptions</span>: &#123;<br>          <span class="hljs-attr">compress</span>: &#123;<br>            <span class="hljs-attr">drop_console</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 去除console</span><br>          &#125;,<br>        &#125;,<br>      &#125;), <span class="hljs-comment">// 压缩JavaScript</span><br>    ],<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="3-tree-shaking"><a href="#3-tree-shaking" class="headerlink" title="3.tree-shaking"></a>3.tree-shaking</h3><p><code>tree-shaking</code>简单说作用就是：只打包用到的代码，没用到的代码不打包，而<code>webpack5</code>默认开启<code>tree-shaking</code>，当打包的<code>mode</code>为<code>production</code>时，自动开启<code>tree-shaking</code>进行优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-source-map类型"><a href="#4-source-map类型" class="headerlink" title="4.source-map类型"></a>4.source-map类型</h3><p><code>source-map</code>的作用是：方便你报错的时候能定位到错误代码的位置。它的体积不容小觑，所以对于不同环境设置不同的类型是很有必要的。</p><ul><li><strong>开发环境</strong></li></ul><p>开发环境的时候我们需要能精准定位错误代码的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.dev.js</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,<br>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;eval-cheap-module-source-map&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>生产环境</strong></li></ul><p>生产环境，我们想开启<code>source-map</code>，但是又不想体积太大，那么可以换一种类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.prod.js</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>,<br>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;nosources-source-map&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-打包体积分析"><a href="#5-打包体积分析" class="headerlink" title="5.打包体积分析"></a>5.打包体积分析</h3><p>使用<code>webpack-bundle-analyzer</code>可以审查打包后的体积分布，进而进行相应的体积优化</p><blockquote><p>只需要打包时看体积，所以只需在<code>webpack.prod.js</code>中配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i webpack-bundle-analyzer -D<br> <br><span class="hljs-comment">// webpack.prod.js</span><br><br><span class="hljs-keyword">const</span> &#123;<br>  <span class="hljs-title class_">BundleAnalyzerPlugin</span><br>&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>)<br><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>(),<br>]<br></code></pre></td></tr></table></figure><h2 id="三、用户体验优化"><a href="#三、用户体验优化" class="headerlink" title="三、用户体验优化"></a>三、用户体验优化</h2><h3 id="1-模块懒加载"><a href="#1-模块懒加载" class="headerlink" title="1.模块懒加载"></a>1.模块懒加载</h3><p>如果不进行<code>模块懒加载</code>的话，最后整个项目代码都会被打包到一个js文件里，单个js文件体积非常大，那么当用户网页请求的时候，首屏加载时间会比较长，使用<code>模块懒加载</code>之后，大js文件会分成多个小js文件，网页加载时会按需加载，大大提升首屏加载速度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/router/index.js</span><br><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,<br>    <span class="hljs-attr">component</span>: login<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>    <span class="hljs-comment">// 懒加载</span><br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/home/home.vue&#x27;</span>),<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><h3 id="2-Gzip"><a href="#2-Gzip" class="headerlink" title="2.Gzip"></a>2.Gzip</h3><p>开启Gzip后，大大提高用户的页面加载速度，因为gzip的体积比原文件小很多，当然需要后端的配合，使用<code>compression-webpack-plugin</code></p><blockquote><p>只需要打包时优化体积，所以只需在<code>webpack.prod.js</code>中配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i compression-webpack-plugin -D<br> <br><span class="hljs-comment">// webpack.prod.js</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CompressionPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;compression-webpack-plugin&#x27;</span>)<br><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">// 之前的代码...</span><br>    <br>    <span class="hljs-comment">// gzip</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressionPlugin</span>(&#123;<br>      <span class="hljs-attr">algorithm</span>: <span class="hljs-string">&#x27;gzip&#x27;</span>,<br>      <span class="hljs-attr">threshold</span>: <span class="hljs-number">10240</span>,<br>      <span class="hljs-attr">minRatio</span>: <span class="hljs-number">0.8</span><br>    &#125;)<br>  ]<br></code></pre></td></tr></table></figure><h3 id="3-小图片转base64"><a href="#3-小图片转base64" class="headerlink" title="3.小图片转base64"></a>3.小图片转base64</h3><p>对于一些小图片，可以转base64，这样可以减少用户的http网络请求次数，提高用户的体验。<code>webpack5</code>中<code>url-loader</code>已被废弃，改用<code>asset-module</code></p><blockquote><p>在<code>webpack.base.js</code>中配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.base.js</span><br><br>&#123;<br>   <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpe?g|gif|svg|webp)$/</span>,<br>   <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset&#x27;</span>,<br>   <span class="hljs-attr">parser</span>: &#123;<br>     <span class="hljs-comment">// 转base64的条件</span><br>     <span class="hljs-attr">dataUrlCondition</span>: &#123;<br>        <span class="hljs-attr">maxSize</span>: <span class="hljs-number">25</span> * <span class="hljs-number">1024</span>, <span class="hljs-comment">// 25kb</span><br>     &#125;<br>   &#125;,<br>   <span class="hljs-attr">generator</span>: &#123;<br>     <span class="hljs-comment">// 打包到 image 文件下</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;images/[contenthash][ext][query]&#x27;</span>,<br>   &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="4-合理配置hash"><a href="#4-合理配置hash" class="headerlink" title="4.合理配置hash"></a>4.合理配置hash</h3><p>我们要保证，改过的文件需要更新hash值，而没改过的文件依然保持原本的hash值，这样才能保证在上线后，浏览器访问时没有改变的文件会命中缓存，从而达到性能优化的目的</p><blockquote><p>在<code>webpack.base.js</code>中配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.base.js</span><br><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;../dist&#x27;</span>),<br>    <span class="hljs-comment">// 给js文件加上 contenthash</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;js/chunk-[contenthash].js&#x27;</span>,<br>    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack4基本配置</title>
    <link href="/blog/2022/11/18/webpack-configuration/"/>
    <url>/blog/2022/11/18/webpack-configuration/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack4基本配置"><a href="#webpack4基本配置" class="headerlink" title="webpack4基本配置"></a>webpack4基本配置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="1-官网解释"><a href="#1-官网解释" class="headerlink" title="1.官网解释"></a>1.官网解释</h4><ul><li>本质上，<strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的 <em>静态模块打包工具</em>。当  webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 [依赖图(dependency graph)]，然后将你项目中所需的每一个 模块组合成一个或多个 <em>bundles</em>，它们均为静态资源，用于展示你的内容</li></ul><h4 id="2-理解"><a href="#2-理解" class="headerlink" title="2.理解"></a>2.理解</h4><ul><li>Webpack可以看做是模块打包机，它做的事情是分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（例如：Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</li></ul><h4 id="3-webpack-基础概念"><a href="#3-webpack-基础概念" class="headerlink" title="3.webpack 基础概念"></a>3.webpack 基础概念</h4><ol><li>Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。</li><li>Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</li><li>Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</li><li>Loader：模块转换器，用于把模块原内容按照需求转换成新内容。</li><li>Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</li><li>Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。</li></ol><h2 id="1-从0开始配置结构"><a href="#1-从0开始配置结构" class="headerlink" title="1. 从0开始配置结构"></a>1. 从0开始配置结构</h2><ul><li>初始化项目结构</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir webpack-init<br>cd webpack-init<br>npm init -y<br>npm install webpack webpack-cli webpack-dev-server -g //安装webpack配置需要的包<br><br>//新建src目录，并在下边新建index.html，并引入index.js<br>mkdir src<br>cd src<br>touch index.html<br>touch index.js<br></code></pre></td></tr></table></figure><h2 id="2-配置webpack-config-js"><a href="#2-配置webpack-config-js" class="headerlink" title="2. 配置webpack.config.js"></a>2. 配置webpack.config.js</h2><ul><li>在项目根目录新建webpack.config.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<span class="hljs-comment">//入口文件，src下的index.js</span><br>    <span class="hljs-attr">output</span>:&#123;<br>        <span class="hljs-attr">publicPath</span>:__dirname+<span class="hljs-string">&quot;dist&quot;</span>,<span class="hljs-comment">//js引用的路径也是可以是cdn地址</span><br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname,<span class="hljs-string">&#x27;dist&#x27;</span>),<span class="hljs-comment">//出口目录，dist文件</span><br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[hash].js&#x27;</span><span class="hljs-comment">//这里那么就是打包出来的文件名</span><br>    &#125;,<br>    <span class="hljs-attr">module</span>:&#123;&#125;,<br>    <span class="hljs-attr">plugins</span>:[],<span class="hljs-comment">//加s的都是数组</span><br>    <span class="hljs-attr">devServer</span>:&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-配置开发服务器"><a href="#3-配置开发服务器" class="headerlink" title="3. 配置开发服务器"></a>3. 配置开发服务器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//修改wbepack.config.js 文件</span><br><br><span class="hljs-attr">devServer</span>:&#123;<br>    <span class="hljs-attr">contentBase</span>:path.<span class="hljs-title function_">resolve</span>(__dirname,<span class="hljs-string">&quot;dist&quot;</span>),<br>    <span class="hljs-attr">port</span>:<span class="hljs-number">9090</span>,<br>    <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    <span class="hljs-attr">overlay</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">compress</span>:<span class="hljs-literal">true</span>  <span class="hljs-comment">//服务器返回浏览器的时候是否启动gzip压缩</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-打包js"><a href="#4-打包js" class="headerlink" title="4. 打包js"></a>4. 打包js</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//修改package.json 文件</span><br><span class="hljs-attr">&quot;script&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --mode prodection&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dev&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server --open --mode development&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-comment">// --mode production 和 --mode devlopment 的区别就是是否进行代码的压缩</span><br><span class="hljs-comment">// 运行npm run build 既可打包生产环境</span><br><span class="hljs-comment">// 运行npm run dev 既可热加载，进行开发</span><br></code></pre></td></tr></table></figure><h2 id="5-支持ES6-react-vue"><a href="#5-支持ES6-react-vue" class="headerlink" title="5. 支持ES6,react,vue"></a>5. 支持ES6,react,vue</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// cnpm i babel-loader @babel/core @babel/preset-env @babel/preset-react -D</span><br><br><span class="hljs-punctuation">&#123;</span><br>    test<span class="hljs-punctuation">:</span> /\.jsx?$/<span class="hljs-punctuation">,</span><br>    exclude<span class="hljs-punctuation">:</span>/node_modules/<span class="hljs-punctuation">,</span><br>    use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            loader<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;babel-loader&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-comment">//.babelrc文件</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;@babel/preset-react&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="6-处理css-sass-以及css3属性前缀"><a href="#6-处理css-sass-以及css3属性前缀" class="headerlink" title="6. 处理css,sass,以及css3属性前缀"></a>6. 处理css,sass,以及css3属性前缀</h2><h3 id="6-1-处理css"><a href="#6-1-处理css" class="headerlink" title="6.1 处理css"></a>6.1 处理css</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// npm install style-loader css-loader postcss-loader autoprefixer -D</span><br><span class="hljs-comment">// css-loader 用来处理css中url的路径</span><br><span class="hljs-comment">// style-loader可以把css文件变成style标签插入head中</span><br><span class="hljs-comment">// 多个loader是有顺序要求的，从右往左写，因为转换的时候是从右往左转换的</span><br><br>module<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    rules<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        test<span class="hljs-punctuation">:</span>/\.css$/<span class="hljs-punctuation">,</span><br>        use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                loader<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;style-loader&quot;</span><span class="hljs-punctuation">,</span><br>                options<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    singeton<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> <span class="hljs-comment">//处理为单个style标签</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span><br>                loader<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;css-loader&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span><br>                loader<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;postcss-loader&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        include<span class="hljs-punctuation">:</span> path.resolve(__dirname<span class="hljs-punctuation">,</span>&#x27;dist&#x27;)<span class="hljs-punctuation">,</span><span class="hljs-comment">//限制范围，提高打包速度</span><br>        exclude<span class="hljs-punctuation">:</span> /node_modules<br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-comment">// css前缀：新建一个postcss.config.js文件，输入</span><br>module.exports = <span class="hljs-punctuation">&#123;</span><br>    plugins<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        require(&#x27;qutoprefixer&#x27;)<br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="6-2-动态卸载和加载CSS"><a href="#6-2-动态卸载和加载CSS" class="headerlink" title="6.2 动态卸载和加载CSS"></a>6.2 动态卸载和加载<code>CSS</code></h3><blockquote><p>style-loader为 css 对象提供了use()和unuse()两种方法可以用来加载和卸载css</p></blockquote><p>比如实现一个点击切换颜色的需求，修改index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> index <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./css/index.css&quot;</span><br><span class="hljs-keyword">let</span> flag =<span class="hljs-literal">false</span>;<br>$(<span class="hljs-string">&#x27;#btn&#x27;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>flag?index.<span class="hljs-title function_">use</span>():index.<span class="hljs-title function_">unuse</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="6-3-处理sass"><a href="#6-3-处理sass" class="headerlink" title="6.3 处理sass"></a>6.3 处理sass</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// npm install sass-loader node -sass style-loader css-loader --save-dev</span><br><br><span class="hljs-comment">//webpack.config.js</span><br>module.exports = <span class="hljs-punctuation">&#123;</span><br>    module<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        rules<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>            test<span class="hljs-punctuation">:</span> /\.scss$/<span class="hljs-punctuation">,</span><br>            use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>                loader<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;style-loader&quot;</span> <span class="hljs-comment">//将JS字符串生成为style节点</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#123;</span><br>                loader<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;css-loader&quot;</span> <span class="hljs-comment">//将css转化成CommonJS模块</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#123;</span><br>                loader<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;sass-loader&quot;</span> <span class="hljs-comment">//将sass编译成css</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="6-4-提取css文件为单独文件"><a href="#6-4-提取css文件为单独文件" class="headerlink" title="6.4 提取css文件为单独文件"></a>6.4 提取css文件为单独文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"> npm install --save-dev extract-text-webpack-plugin@nest  <span class="hljs-comment">//注意：一定是next版本的</span><br><br><span class="hljs-comment">//不再需要style-loader</span><br>rules<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        test<span class="hljs-punctuation">:</span> /\.css$/<br>        <span class="hljs-comment">//</span><br>        use<span class="hljs-punctuation">:</span> ExtractTextWebpackPlugin.extract(<span class="hljs-punctuation">&#123;</span><br>        use<span class="hljs-punctuation">:</span>&#x27;css-loader&#x27;<br>    <span class="hljs-punctuation">&#125;</span>)<br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br><br>new ExtractTextWebpackPlugin(&#x27;index.css&#x27;)<br></code></pre></td></tr></table></figure><h2 id="7-产出html"><a href="#7-产出html" class="headerlink" title="7. 产出html"></a>7. 产出html</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// npm i html-webpack-plugin ---save-dev</span><br>plugins<span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>    new HtmlWebpackPlugin(<span class="hljs-punctuation">&#123;</span><br>        template<span class="hljs-punctuation">:</span> path.resolve(__dirname<span class="hljs-punctuation">,</span>&#x27;src&#x27;<span class="hljs-punctuation">,</span>&#x27;index.html&#x27;)<span class="hljs-punctuation">,</span><span class="hljs-comment">//模板</span><br>        filename<span class="hljs-punctuation">:</span> &#x27;index.html&#x27;<span class="hljs-punctuation">,</span><br>        hash<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-comment">//防止缓存</span><br>        minify<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            removeAttributeQuotes<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>  <span class="hljs-comment">//压缩 去掉引号</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span>)<br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h2 id="8-处理引用的第三方库-暴露全局变量"><a href="#8-处理引用的第三方库-暴露全局变量" class="headerlink" title="8. 处理引用的第三方库,暴露全局变量"></a>8. 处理引用的第三方库,暴露全局变量</h2><p>webpack.ProvidePlugin参数是键值对形式，键就是我们项目中使用的变量名，值就是键所指向的库</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">const webpack = require(<span class="hljs-string">&quot;webpack&quot;</span>);<br><br>new webpack.ProvidePlugin(<span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;$&quot;</span><span class="hljs-punctuation">:</span>&#x27;jquery&#x27;<br><span class="hljs-punctuation">&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="9-code-splitting、懒加载-按需加载"><a href="#9-code-splitting、懒加载-按需加载" class="headerlink" title="9. code splitting、懒加载(按需加载)"></a>9. code splitting、懒加载(按需加载)</h2><p>说白了就是在需要的时候在进行加载，比如一个场景，点击按钮才加载某个js.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  require.ensure的方式</span><br><br><span class="hljs-keyword">if</span>(page==<span class="hljs-string">&#x27;subPageA&#x27;</span>)&#123;<br><span class="hljs-built_in">require</span>.<span class="hljs-title function_">ensure</span>([<span class="hljs-string">&#x27;./subPageA&#x27;</span>],<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> subPageA = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;subPageA&#x27;</span>);<br>    &#125;,<span class="hljs-string">&#x27;subPageA&#x27;</span>)<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(page==<span class="hljs-string">&#x27;subPageB&#x27;</span>)&#123;<br>    <span class="hljs-built_in">require</span>.<span class="hljs-title function_">ensure</span>([<span class="hljs-string">&#x27;./subPageB&#x27;</span>],<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> subPageA = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;subPageB&#x27;</span>);<br>    &#125;,subPageB)<br>&#125;<br><br><span class="hljs-comment">// import的方式</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span><br><span class="hljs-keyword">var</span> page = <span class="hljs-string">&#x27;subpageA&#x27;</span><br><span class="hljs-keyword">if</span>(page==-<span class="hljs-string">&quot;subpageA&quot;</span>)&#123;<br><span class="hljs-keyword">import</span>(<span class="hljs-comment">/*webpackChunkName:&#x27;subpageA&#x27;*/</span><span class="hljs-string">&#x27;./subpageA&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">subpageA</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;subpageA&quot;</span>)<br>    &#125;)<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(page==-<span class="hljs-string">&quot;subpageB&quot;</span>)&#123;<br><span class="hljs-keyword">import</span>(<span class="hljs-comment">/*webpackChunkName:&#x27;subpageB&#x27;*/</span><span class="hljs-string">&#x27;./subpageB&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">subpageB</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;subpageB&quot;</span>)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;pageA&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="10-JS-Tree-Shaking"><a href="#10-JS-Tree-Shaking" class="headerlink" title="10. JS Tree Shaking"></a>10. JS Tree Shaking</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 在webpack之前的版本中，这样使用，显式配置UglifyjsWebpackPlugin即可</span><br><br>const UglifyJSPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;);<br>plugins<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    new UglifyJSPlugin()<br><span class="hljs-punctuation">]</span><br><br><span class="hljs-comment">//但是在webpack4中，只需要配置mode为&quot;production&quot;即可</span><br></code></pre></td></tr></table></figure><h2 id="11-图片处理"><a href="#11-图片处理" class="headerlink" title="11. 图片处理"></a>11. 图片处理</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// yarn add file-loader url-loader -D</span><br><span class="hljs-comment">//file-loader 解决css等文件中引入图片路径的问题</span><br><span class="hljs-comment">//url-loader 当图片较小的时候把图片BASE64编码，大于limit参数的时候还是使用file-loader进行拷贝</span><br><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// file-loader是解析图片地址，把图片从源文件拷贝到目标文件并且修改源文件名称</span><br>    <span class="hljs-comment">// 可以处理任意二进制，bootstrap里的文字</span><br>    <span class="hljs-comment">// url-loader可以在文件比较小的时候，直接变成base64字符串内嵌到页面中</span><br>    <span class="hljs-punctuation">&#123;</span><br>    test<span class="hljs-punctuation">:</span> /\.(png|jpg|jpeg|gif|svg)<span class="hljs-punctuation">,</span><br>    use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    loader<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;url-loader&quot;</span><span class="hljs-punctuation">,</span><br>    options<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  outputPath<span class="hljs-punctuation">:</span> &#x27;image/&#x27;<span class="hljs-punctuation">,</span> <span class="hljs-comment">// 图片输出的路径</span><br>    limit<span class="hljs-punctuation">:</span> <span class="hljs-number">5</span> * <span class="hljs-number">1024</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="12-Clean-Plugin-and-Watch-Mode"><a href="#12-Clean-Plugin-and-Watch-Mode" class="headerlink" title="12. Clean Plugin and Watch Mode"></a>12. Clean Plugin and Watch Mode</h2><p>清空目录，文件有改动就重新打包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>([<span class="hljs-string">&quot;dist&quot;</span>])<br><br><span class="hljs-comment">// webpack --watch 即可开启watch mode</span><br></code></pre></td></tr></table></figure><h2 id="13-区分环境变量"><a href="#13-区分环境变量" class="headerlink" title="13. 区分环境变量"></a>13. 区分环境变量</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">new webpack.DefinePlugin(<span class="hljs-punctuation">&#123;</span><br>NODE_ENV<span class="hljs-punctuation">:</span>JSON.stringify(process.env.NODE_ENV)<br><span class="hljs-punctuation">&#125;</span>)<br><br><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=production webpack --mode development&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="14-开发模式与webpack-dev-server-proxy"><a href="#14-开发模式与webpack-dev-server-proxy" class="headerlink" title="14. 开发模式与webpack-dev-server,proxy"></a>14. 开发模式与webpack-dev-server,proxy</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json">devServer<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    contentBase<span class="hljs-punctuation">:</span> path.resolve(__dirname<span class="hljs-punctuation">,</span><span class="hljs-string">&quot;dist&quot;</span>)<span class="hljs-punctuation">,</span><br>    port<span class="hljs-punctuation">:</span> <span class="hljs-number">8000</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//端口号</span><br>    hot<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-comment">//热重载</span><br>    overlay<span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-comment">//代码出错弹出浮动层</span><br>    proxy<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-comment">//跨域代理转发</span><br>        <span class="hljs-attr">&quot;/comments&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            target<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://m.weibo.cn&quot;</span><span class="hljs-punctuation">,</span><br>            changeOrigin<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            logLevel<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;debug&quot;</span><span class="hljs-punctuation">,</span><br>            headers<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                Cookie<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    historyApiFallback<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-comment">// HTML5 history模式</span><br>        rewrites<span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span> from<span class="hljs-punctuation">:</span> /.*/<span class="hljs-punctuation">,</span> to<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/index.html&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpackp配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript Promise常用方法</title>
    <link href="/blog/2022/11/09/js-promiseMethod/"/>
    <url>/blog/2022/11/09/js-promiseMethod/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise常用方法"><a href="#Promise常用方法" class="headerlink" title="Promise常用方法"></a>Promise常用方法</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>恰逢 <code>Promise</code> 也有四个很像的静态三兄弟(<code>Promise.all</code>、<code>Promise.allSettled</code>、<code>Promise.race</code>、<code>Promise.any</code>)，它们接受的参数类型相同，但各自逻辑处理不同，它们具体会有什么区别那？别急，下面等小包慢慢道来。</p><p>在文章的开始，小包先给大家提出几个问题:</p><ul><li><code>Promise.all</code> 与 <code>Promise.allSettled</code> 有啥区别啊?</li><li><code>Promise.race</code> 的运行机制? <code>Promise.any</code> 呐，两者有啥区别?</li><li>四兄弟只能接受<strong>数组</strong>作为参数吗?</li><li>四兄弟方法我们应该如何优雅完美的实现?</li></ul><h2 id="二、Promise-all"><a href="#二、Promise-all" class="headerlink" title="二、Promise.all"></a>二、Promise.all</h2><p><code>Promise.all</code> 在目前手写题中热度频度应该是 <code>top5</code> 级别的，所以我们要深刻掌握 <code>Promise.all</code> 方法。下面首先来简单回顾一下 <code>all</code> 方法。</p><h3 id="1-基础学习"><a href="#1-基础学习" class="headerlink" title="1.基础学习"></a>1.基础学习</h3><blockquote><p><code>Promise.all</code> 方法类似于<strong>一群兄弟们并肩前行</strong>，参数可以类比为一群兄弟，只有当兄弟全部快乐，<code>all</code> 老大才会收获快乐；只要有一个兄弟不快乐，老大就不会快乐。</p></blockquote><p><code>Promise.all()</code> 方法用于将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3]);<br> <br></code></pre></td></tr></table></figure><p><code>Promise.all</code> 方法接受一个数组做参数，<code>p1、p2、p3</code> 都是 <code>Promise</code> 实例。如果不是 <code>Promise</code> 实例，则会先调用 <code>Promise.resolve</code> 方法将参数先转化为 <code>Promise</code> 实例，之后进行下一步处理。</p><p><strong>返回值 p 的状态由 p1、p2、p3 决定，可以分成两种情况</strong>:</p><ul><li>只有 <code>p1、p2、p3</code> 的状态都变成 <code>fulfilled</code> ，<code>p</code> 的状态才会变成 <code>fulfilled</code> ，此时 <code>p1、p2、p3</code> 的返回值组成一个数组，传递给 <code>p</code> 的回调函数。</li><li>只要 <code>p1、p2、p3</code> 之中有一个被 <code>rejected</code> ，<code>p</code> 的状态就变成 <code>rejected</code> ，此时第一个被 <code>reject</code> 的实例的返回值，会传递给 <code>p</code> 的回调函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟异步的promise</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><span class="hljs-comment">// 普通promise</span><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 常数值</span><br><span class="hljs-keyword">const</span> p3 = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 失败的promise</span><br><span class="hljs-keyword">const</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><span class="hljs-comment">// 异步失败的promise</span><br><span class="hljs-keyword">const</span> p5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;TypeError&quot;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-comment">// 1. promise全部成功</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)) <span class="hljs-comment">// [1, 2, 3]</span><br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error));<br>  <br><span class="hljs-comment">// 2. 存在失败的promise</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3, p4])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)); <span class="hljs-comment">// error</span><br><br><span class="hljs-comment">// 3. 存在多个失败的promise</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3, p4, p5])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)); <span class="hljs-comment">// error</span><br> <br></code></pre></td></tr></table></figure><p>从上面案例的输出中，我们可以得出下列结论:</p><ul><li><code>p</code> 状态由参数执行结果决定，全部成功则返回成功，存有一个失败则失败</li><li>参数为非 <code>Promise</code> 实例，会通过 <code>Promise.resolve</code> 转化成 <code>Promise</code> 实例</li><li><strong>成功后返回一个数组，数组内数据按照参数顺序排列</strong></li><li><strong>短路效应: 只会返回第一个失败信息</strong></li></ul><h4 id="Iterator-接口参数"><a href="#Iterator-接口参数" class="headerlink" title="Iterator 接口参数"></a>Iterator 接口参数</h4><p>《ES6 入门教程》还指出: <strong>Promise.all 方法可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例</strong></p><p>说实话，加粗部分小包是没能完全理解的，难道 <code>Promise.all</code> 使用 <code>Iterator</code> 类型时，要求迭代项都是 <code>Promise</code> 实例吗？我们以 <code>String</code> 类型为例，看 <code>Promise.all</code> 是否可以支持迭代项为非 <code>Promise</code> 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  [&#x27;x&#x27;, &#x27;i&#x27;, &#x27;a&#x27;, &#x27;o&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;o&#x27;]</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<span class="hljs-string">&quot;xiaobao&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br> <br></code></pre></td></tr></table></figure><p>可见 <code>Promise</code> 对 <code>Iterator</code> 类型的处理与数组相同，如果参数不是 <code>Promise</code> 实例，会先调用 <code>Promise.all</code> 转化为 <code>Promise</code> 实例。</p><h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><ol><li><code>Promise.all</code> 会返回一个新 <code>Promise</code> 对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;&#125;);<br>&#125;;<br> <br></code></pre></td></tr></table></figure><ol><li>(<strong>亮点</strong>) <code>all</code> 方法参数可以是数组，同样也可以是 <code>Iterator</code> 类型，因此应该使用 <code>for of</code> 循环进行遍历。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> promises) &#123;<br>    &#125;<br>  &#125;);<br>&#125;;<br> <br></code></pre></td></tr></table></figure><ol><li>某些参数有可能未必是 <code>Promise</code> 类型，因此参数使用前先通过 <code>Promise.resolve</code> 转换</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> promises) &#123;<br>      <span class="hljs-comment">// 保证所有的参数为 promise 实例，然后执行后续操作</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//...</span><br>      &#125;);<br>    &#125;<br>  &#125;);<br>&#125;;<br> <br></code></pre></td></tr></table></figure><ol><li><code>Iterator</code> 类型我们是无法得知迭代深度，因此我们要维护一个 <code>count</code> 用来记录 <code>promise</code> 总数，同时维护 <code>fulfilledCount</code> 代表完成的 <code>promise</code> 数，当 <code>count === fulfilledCount</code> ，代表所有传入的 <code>Promise</code> 执行成功，返回数据。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// promise总数</span><br>  <span class="hljs-keyword">let</span> fulfilledCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 完成的promise数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> promises) &#123;<br>      count++; <span class="hljs-comment">// promise总数 + 1</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>        fulfilledCount++; <span class="hljs-comment">// 完成的promise数量+1</span><br>        <span class="hljs-keyword">if</span> (count === fulfilledCount) &#123;<br>          <span class="hljs-comment">// 代表最后一个promise完成了</span><br>          <span class="hljs-title function_">resolve</span>();<br>        &#125;<br>      &#125;);<br>    &#125;<br>  &#125;);<br>&#125;;<br> <br></code></pre></td></tr></table></figure><p>有可能有的读者会好奇，<strong>为啥 <code>count === fulfilledCount</code> 可以判断所有的 promise 都完成了呐</strong>?</p><p><code>Promise.then</code> 方法是 <code>microTasks</code>(微任务)，当同步任务执行完毕后，<code>Event Loop</code> 才会去执行 <code>microTasks</code>。<code>count++</code> 位于同步代码部分，因此在执行 <code>promise.then</code> 方法之前，已经成功的计算出 <code>promise</code> 的总数。</p><p>然后依次执行 <code>promise.then</code> 方法，<code>fulfilledCount</code> 增加，当 <code>count === fulfilledCount</code> 说明所有的 <code>promise</code> 都已经成功完成了。</p><ol><li>返回数据的顺序应该是 <code>all</code> 方法中比较难处理的部分。</li></ol><ul><li>创建一个数组 <code>result</code> 存储所有 <code>promise</code> 成功的数据</li><li>在 <code>for of</code> 循环中，使用 <code>let</code> 变量定义 <code>i</code>，其值等于当前的遍历索引</li><li><code>let</code> 定义的变量不会发生变量提升，因此我们直接令 <code>result[i]</code> 为 <code>promise</code> 成功数据，这样就可以实现按参数输入顺序输出结果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = []; <span class="hljs-comment">// 存储promise成功数据</span><br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> fulfilledCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> promises) &#123;<br>      <span class="hljs-comment">// i为遍历的第几个promise</span><br>      <span class="hljs-comment">// 使用let避免形成闭包问题</span><br>      <span class="hljs-keyword">let</span> i = count;<br>      count++;<br>      <span class="hljs-comment">// 保证所有的参数为 promise 实例，然后执行后续操作</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>        fulfilledCount++;<br>        <span class="hljs-comment">// 将第i个promise成功数据赋值给对应位置</span><br>        result[i] = data;<br>        <span class="hljs-keyword">if</span> (count === fulfilledCount) &#123;<br>          <span class="hljs-comment">// 代表最后一个promise完成了</span><br>          <span class="hljs-comment">// 返回result数组</span><br>          <span class="hljs-title function_">resolve</span>(result);<br>        &#125;<br>      &#125;);<br>    &#125;<br>  &#125;);<br>&#125;;<br> <br></code></pre></td></tr></table></figure><ol><li>处理一下边界情况<ul><li>某个 <code>promise</code> 失败——直接调用 <code>reject</code> 即可</li><li>传入 <code>promise</code> 数量为 <code>0</code> ——返回空数组(规范规定)</li><li>代码执行过程抛出异常 —— 返回错误信息</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 多余代码省略</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 3.捕获代码执行中的异常</span><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> promises) &#123;<br>                <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;&#125;<br>                                .<span class="hljs-title function_">catch</span>(reject);  <span class="hljs-comment">// 1.直接调用reject函数返回失败原因</span><br>                &#125;)<br>            &#125;<br>            <span class="hljs-comment">// 2.传入promise数量为0</span><br>            <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-title function_">resolve</span>(result)<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>            <span class="hljs-title function_">reject</span>(error)<br>        &#125;<br>    &#125;)<br>&#125;<br> <br></code></pre></td></tr></table></figure><h3 id="3-源码实现"><a href="#3-源码实现" class="headerlink" title="3.源码实现"></a>3.源码实现</h3><p>我们把上面的代码汇总一下，加上详细的注释，同时测试一下手写 <code>Promise.all</code> 是否成功。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = []; <span class="hljs-comment">// 存储promise成功数据</span><br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// promise总数</span><br>  <span class="hljs-keyword">let</span> fulfilledCount = <span class="hljs-number">0</span>; <span class="hljs-comment">//完成promise数量</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 捕获代码执行中的异常</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> promises) &#123;<br>        <span class="hljs-comment">// i为遍历的第几个promise</span><br>        <span class="hljs-comment">// 使用let避免形成闭包问题</span><br>        <span class="hljs-keyword">let</span> i = count;<br>        count++; <span class="hljs-comment">// promise总数 + 1</span><br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p)<br>          .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>            fulfilledCount++; <span class="hljs-comment">// 完成的promise数量+1</span><br>            <span class="hljs-comment">// 将第i个promise成功数据赋值给对应位置</span><br>            result[i] = data;<br>            <span class="hljs-keyword">if</span> (count === fulfilledCount) &#123;<br>              <span class="hljs-comment">// 代表最后一个promise完成了</span><br>              <span class="hljs-comment">// 返回result数组</span><br>              <span class="hljs-title function_">resolve</span>(result);<br>            &#125;<br>          &#125;)<br>          .<span class="hljs-title function_">catch</span>(reject);<br>        <span class="hljs-comment">// 传入promise数量为0</span><br>        <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-title function_">resolve</span>(result); <span class="hljs-comment">// 返回空数组</span><br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-title function_">reject</span>(error);<br>    &#125;<br>  &#125;);<br>&#125;;<br> <br></code></pre></td></tr></table></figure><p>测试代码(使用案例中的测试代码，附加 <code>Iterator</code> 类型 <code>Stirng</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. promise全部成功</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)) <span class="hljs-comment">// [1, 2, 3]</span><br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error));<br><br><span class="hljs-comment">// 2. 存在失败的promise</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3, p4])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)); <span class="hljs-comment">// error</span><br><br><span class="hljs-comment">// 3. 存在多个失败的promise</span><br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3, p4, p5])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)); <span class="hljs-comment">// error</span><br><br><span class="hljs-comment">// 4. String 类型</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<span class="hljs-string">&quot;zcxiaobao&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br><span class="hljs-comment">// [&#x27;z&#x27;, &#x27;c&#x27;, &#x27;x&#x27;, &#x27;i&#x27;, &#x27;a&#x27;, &#x27;o&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;o&#x27;]</span><br> <br></code></pre></td></tr></table></figure><h2 id="三、Promise-allSettled"><a href="#三、Promise-allSettled" class="headerlink" title="三、Promise.allSettled"></a>三、Promise.allSettled</h2><h3 id="1-基础学习-1"><a href="#1-基础学习-1" class="headerlink" title="1.基础学习"></a>1.基础学习</h3><blockquote><p>不是每群兄弟们都会碰到好老大(<code>all</code> 方法)，<code>allSettled</code> 方法他并不管兄弟们的死活，他只管兄弟们是否做了，而他的任务就是把所有兄弟的结果返回。</p></blockquote><p><code>Promise.allSettled()</code> 方法接受一个数组作为参数，数组的每个成员都是一个 <code>Promise</code> 对象，并返回一个新的 <code>Promise</code> 对象。只有等到参数数组的所有 <code>Promise</code> 对象都发生状态变更（不管是 <code>fulfilled</code> 还是 <code>rejected</code>），返回的 <code>Promise</code> 对象才会发生状态变更。</p><p>还是以上面的例子为例，我们来看一下与 <code>Promise.all</code> 方法有啥不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. promise 全部成功</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([p1, p2, p3])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)) <span class="hljs-comment">// [1, 2, 3]</span><br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error));<br>  <br><span class="hljs-comment">// 2. 存在失败的 promise</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([p1, p2, p3, p4])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)); <span class="hljs-comment">// error</span><br><br><span class="hljs-comment">// 3. 存在多个失败的 promise</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([p1, p2, p3, p4, p5])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)); <span class="hljs-comment">// error</span><br><br><span class="hljs-comment">// 4. 传入 String 类型</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(<span class="hljs-string">&quot;zc&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br> <br></code></pre></td></tr></table></figure><p>从输出结果我们可以发现:</p><ol><li><code>allSettled</code> 方法只会成功，不会失败</li><li>返回结果每个成员为对象，对象的格式固定<ul><li>如果 <code>promise</code> 成功，对象属性值 <code>status: fulfilled</code>，<code>value</code> 记录成功值</li><li>如果 promise 失败，对象属性值 <code>status: rejected</code>，<code>reason</code> 记录失败原因。</li></ul></li><li><code>allSettled</code> 方法也可以接受 <code>Iterator</code> 类型参数</li></ol><h3 id="2-思路分析-1"><a href="#2-思路分析-1" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p><code>allSettled</code> 方法与 <code>all</code> 方法最大的区别在于两点:</p><ol><li><code>allSettled</code> 方法没有失败情况</li><li><code>allSettled</code> 方法返回有固定格式</li></ol><p>我们可以围绕这两点改造 <code>all</code> 方法。</p><p><code>all</code> 方法我们是通过计算成功数量来判断是否终结，<code>allSettled</code> 方法不计较成功失败，因此我们需要计算成功&#x2F;失败总数量即可。</p><p>在累加完成总数量的过程中，分情况构造 <code>allSettled</code> 所需要的数据格式: <strong>成功时压入成功格式，失败时压入失败格式</strong>。</p><h3 id="3-源码实现-1"><a href="#3-源码实现-1" class="headerlink" title="3.源码实现"></a>3.源码实现</h3><p>由于有了 <code>all</code> 方法手写的基础，上面就不一步一步啰嗦的实现了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">allSettled</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = [];<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> totalCount = <span class="hljs-number">0</span>; <span class="hljs-comment">//完成promise数量</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> promises) &#123;<br>        <span class="hljs-keyword">let</span> i = count;<br>        count++; <span class="hljs-comment">// promise总数 + 1</span><br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p)<br>          .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>            totalCount++;<br>            <span class="hljs-comment">// 成功时返回成功格式数据</span><br>            result[i] = &#123;<br>              <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;fulfilled&quot;</span>,<br>              <span class="hljs-attr">value</span>: res,<br>            &#125;;<br>            <span class="hljs-comment">// 执行完成</span><br>            <span class="hljs-keyword">if</span> (count === totalCount) &#123;<br>              <span class="hljs-title function_">resolve</span>(result);<br>            &#125;<br>          &#125;)<br>          .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>            totalCount++;<br>            <span class="hljs-comment">// 失败时返回失败格式数据</span><br>            result[i] = &#123;<br>              <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;rejected&quot;</span>,<br>              <span class="hljs-attr">reason</span>: error,<br>            &#125;;<br>            <span class="hljs-comment">// 执行完成</span><br>            <span class="hljs-keyword">if</span> (count === totalCount) &#123;<br>              <span class="hljs-title function_">resolve</span>(result);<br>            &#125;<br>          &#125;);<br>        <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-title function_">resolve</span>(result);<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-title function_">reject</span>(error);<br>    &#125;<br>  &#125;);<br>&#125;;<br> <br></code></pre></td></tr></table></figure><h2 id="四、Promise-race"><a href="#四、Promise-race" class="headerlink" title="四、Promise.race"></a>四、Promise.race</h2><h3 id="1-基础学习-2"><a href="#1-基础学习-2" class="headerlink" title="1.基础学习"></a>1.基础学习</h3><blockquote><p><code>race</code> 方法形象化来讲就是赛跑机制，只认第一名，不管是成功的第一还是失败的第一。</p></blockquote><p><code>Promise.race()</code> 方法同样是接收多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2, p3]);<br> <br></code></pre></td></tr></table></figure><p>上面案例中，只要 <code>p1、p2、p3</code> 之中有一个实例率先改变状态，<code>p</code> 的状态就跟着改变。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给 <code>p</code> 的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>)<br>    &#125;,<span class="hljs-number">2000</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> p3 = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 成功在先，失败在后</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)&#125;) <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 同步在先，异步在后</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)) <span class="hljs-comment">// 3</span><br><span class="hljs-comment">// String</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(<span class="hljs-string">&#x27;zc&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)) <span class="hljs-comment">// z</span><br> <br></code></pre></td></tr></table></figure><h3 id="2-思路分析-2"><a href="#2-思路分析-2" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p><code>race</code> 方法就没有那么多弯弯绕绕了，只要某个 <code>promise</code> 改变状态就返回其对应结果。</p><p>因此我们只需监听每个 <code>promise</code> 的 <code>then</code> 与 <code>catch</code> 方法，当发生状态改变，直接调用 <code>resolve</code> 和 <code>reject</code> 方法即可。</p><h3 id="3-源码实现-2"><a href="#3-源码实现-2" class="headerlink" title="3.源码实现"></a>3.源码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(<span class="hljs-params">promises</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> promises) &#123;<br>            <span class="hljs-comment">// Promise.resolve将p进行转化，防止传入非Promise实例</span><br>            <span class="hljs-comment">// race执行机制为那个实例发生状态改变，则返回其对应结果</span><br>            <span class="hljs-comment">// 因此监听</span><br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(resolve).<span class="hljs-title function_">catch</span>(reject);<br>        &#125;<br>    &#125;)<br>&#125;<br> <br></code></pre></td></tr></table></figure><h2 id="五、Promise-any"><a href="#五、Promise-any" class="headerlink" title="五、Promise.any"></a>五、Promise.any</h2><h3 id="1-基础学习-3"><a href="#1-基础学习-3" class="headerlink" title="1.基础学习"></a>1.基础学习</h3><blockquote><p>any 方法形象化来说是天选唯一，只要第一个成功者。如果全部失败了，就返回失败情况。</p></blockquote><p><code>ES2021</code> 引入了 <code>Promise.any()</code> 方法。该方法接受一组 <code>Promise</code> 实例作为参数，包装成一个新的 <code>Promise</code> 实例返回。</p><p><code>any</code> 方法与 <code>race</code> 方法很像，也存在短路特性，只要有一个实例变成 <code>fulfilled</code> 状态，就会返回成功的结果；如果全部失败，则返回失败情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 成功的promise</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-comment">// 失败的promise</span><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>)<br>    &#125;,<span class="hljs-number">2000</span>)<br>&#125;)<br><span class="hljs-comment">//失败的promise</span><br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">3</span>)<br>&#125;)<br><br><br><span class="hljs-comment">// 存在一个成功的promise</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([p1,p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 全部失败的promise</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([p2,p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br>                    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)) <span class="hljs-comment">// AggregateError: All promises were rejected</span><br>                    <br><span class="hljs-comment">// String类型</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>(<span class="hljs-string">&#x27;zc&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)) <span class="hljs-comment">// z</span><br> <br></code></pre></td></tr></table></figure><p>通过上述输出结果我们可以发现:</p><ul><li><code>any</code> 方法也可以接受 <code>Iterator</code> 格式参数</li><li>当一个 <code>promise</code> 实例转变为 <code>fulfilled</code> 时，<code>any</code> 返回成功的 <code>promise</code> ，值为最早成功的 <code>promise</code>值。</li><li>当 <code>promise</code> 全部失败时，<code>any</code> 返回失败的 <code>promise</code> ，值固定为 <code>AggregateError: All promises were rejected</code></li></ul><h3 id="2-思路分析-3"><a href="#2-思路分析-3" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><p>上面我们分析了 <code>any</code> 方法的机制:</p><ol><li>某个实例转化为 <code>fulfilled</code> ，<code>any</code> 随之返回成功的 <code>promise</code>。因此这里我们就可以类似使用 <code>race</code> 的方法，监测每个 <code>promise</code> 的成功。</li><li>全部实例转化为 <code>rejected</code> ，<code>any</code> 返回 <code>AggregateError: All promises were rejected</code>。这里我们可以参考 <code>all</code> 方法的全部成功，才返回成功，因此我们需要累计失败数量，当 <code>rejectCount === count</code> 时，返回失败值。</li></ol><h3 id="3-源码实现-3"><a href="#3-源码实现-3" class="headerlink" title="3.源码实现"></a>3.源码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">any</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> rejectCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> errors = [];<br>        <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> promises) &#123;<br>            i = count;<br>            count ++;<br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(res)<br>            &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>                errors[i] = error;<br>                rejectCount ++;<br>                <span class="hljs-keyword">if</span> (rejectCount === count) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(errors))<br>                &#125;<br>            &#125;)<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>))        <br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>promise-method</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript手写Promise</title>
    <link href="/blog/2022/11/04/js-overwritePromise/"/>
    <url>/blog/2022/11/04/js-overwritePromise/</url>
    
    <content type="html"><![CDATA[<h1 id="javascript手写Promise方法"><a href="#javascript手写Promise方法" class="headerlink" title="javascript手写Promise方法"></a>javascript手写Promise方法</h1><h2 id="1-Promise-resolve"><a href="#1-Promise-resolve" class="headerlink" title="1.Promise.resolve"></a>1.Promise.resolve</h2><h3 id="简要回顾"><a href="#简要回顾" class="headerlink" title="简要回顾"></a>简要回顾</h3><ol><li><code>Promise.resolve(value) </code>方法返回一个以给定值解析后的<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 对象。</li><li>如果这个值是一个 promise ，那么将返回这个 promise ；</li><li>如果这个值是thenable（即带有<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"><code>&quot;then&quot; </code></a>方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。</li></ol><p>这是MDN上的解释，我们挨个看一下</p><ol><li><code>Promise.resolve</code>最终结果还是一个<code>Promise</code>，并且与<code>Promise.resolve(该值)</code>传入的值息息相关</li><li>传入的参数可以是一个<code>Promise实例</code>，那么该函数执行的结果是直接将实例返回</li><li>这里最主要需要理解跟随，可以理解成<code>Promise最终状态</code>就是这个thenable对象输出的<strong>值</strong></li></ol><hr><p><strong>例子</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 非Promise对象，非thenable对象</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 2. Promise对象成功状态</span><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>))<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p2).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// 3. Promise对象失败状态</span><br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err3&#x27;</span>))<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p3).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>) <span class="hljs-comment">// err3</span><br><br><span class="hljs-comment">// 4. thenable对象</span><br><span class="hljs-keyword">const</span> p4 = &#123;<br>  <span class="hljs-title function_">then</span> (resolve) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>), <span class="hljs-number">1000</span>)<br>  &#125;<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p4).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// 4</span><br><br><span class="hljs-comment">// 5. 啥都没传</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><blockquote></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">myResolve</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 是Promise实例，直接返回即可</span><br>  <span class="hljs-keyword">if</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)) &#123;<br>    <span class="hljs-keyword">return</span> value<br>  &#125;<br>  <span class="hljs-comment">// 否则其他情况一律再通过Promise包装一下 </span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(value)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 测试一下，还是用刚才的例子</span><br><span class="hljs-comment">// 1. 非Promise对象，非thenable对象</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myResolve</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 2. Promise对象成功状态</span><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>))<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myResolve</span>(p2).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// 3. Promise对象失败状态</span><br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err3&#x27;</span>))<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myResolve</span>(p3).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>) <span class="hljs-comment">// err3</span><br><br><span class="hljs-comment">// 4. thenable对象</span><br><span class="hljs-keyword">const</span> p4 = &#123;<br>  <span class="hljs-title function_">then</span> (resolve) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>), <span class="hljs-number">1000</span>)<br>  &#125;<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myResolve</span>(p4).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// 4</span><br><br><span class="hljs-comment">// 5. 啥都没传</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myResolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// undefined</span><br><br></code></pre></td></tr></table></figure><p><strong>疑问</strong></p><p>从源码实现中，并没有看到对于<code>thenable</code>对象的特殊处理呀！其实确实也不需要在<code>Promise.resolve</code>中处理，真实处理的地方应该是在<code>Promise</code>构造函数中，如果你对这块感兴趣，马上就会写<code>Promise</code>的实现篇，期待你的阅读噢。</p><h2 id="2-Promise-reject"><a href="#2-Promise-reject" class="headerlink" title="2.Promise.reject"></a>2.Promise.reject</h2><h3 id="简要回顾-1"><a href="#简要回顾-1" class="headerlink" title="简要回顾"></a>简要回顾</h3><blockquote><p><code>Promise.reject() </code>方法返回一个带有拒绝原因的<code>Promise</code>对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;fail&#x27;</span>))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Resolved&#x27;</span>), <br>        <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Rejected&#x27;</span>, err))<br><span class="hljs-comment">// 输出以下内容        </span><br><span class="hljs-comment">// Rejected Error: fail</span><br><span class="hljs-comment">//    at &lt;anonymous&gt;:2:16        </span><br><br></code></pre></td></tr></table></figure><h3 id="源码实现-1"><a href="#源码实现-1" class="headerlink" title="源码实现"></a>源码实现</h3><blockquote><p>reject实现相对简单，只要返回一个新的Promise，并且将结果状态设置为拒绝就可以</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">myReject</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(value)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 测试一下</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myReject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;fail&#x27;</span>))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Resolved&#x27;</span>), <br>        <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Rejected&#x27;</span>, err))<br><br><span class="hljs-comment">// Rejected Error: fail</span><br><span class="hljs-comment">//    at &lt;anonymous&gt;:9:18</span><br></code></pre></td></tr></table></figure><h2 id="3-Promise-all"><a href="#3-Promise-all" class="headerlink" title="3.Promise.all"></a>3.Promise.all</h2><h3 id="简要回顾-2"><a href="#简要回顾-2" class="headerlink" title="简要回顾"></a>简要回顾</h3><blockquote><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<strong>这个静态方法应该是面试中最常见的啦</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3])<br>复制代码<br></code></pre></td></tr></table></figure><p>最终<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>), <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>), <span class="hljs-number">3000</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err4&#x27;</span>)<br><span class="hljs-keyword">const</span> p5 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err5&#x27;</span>)<br><span class="hljs-comment">// 1. 所有的Promise都成功了</span><br><span class="hljs-keyword">const</span> p11 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([ p1, p2, p3 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// [ 1, 2, 3 ]</span><br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)<br>      <br><span class="hljs-comment">// 2. 有一个Promise失败了</span><br><span class="hljs-keyword">const</span> p12 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([ p1, p2, p4 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// err4</span><br>      <br><span class="hljs-comment">// 3. 有两个Promise失败了，可以看到最终输出的是err4，第一个失败的返回值</span><br><span class="hljs-keyword">const</span> p13 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([ p1, p4, p5 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// err4</span><br></code></pre></td></tr></table></figure><h3 id="源码实现-2"><a href="#源码实现-2" class="headerlink" title="源码实现"></a>源码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">myAll</span> = <span class="hljs-function">(<span class="hljs-params">promises</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">rs, rj</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 计数器</span><br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 存放结果</span><br>    <span class="hljs-keyword">let</span> result = []<br>    <span class="hljs-keyword">const</span> len = promises.<span class="hljs-property">length</span><br>    <br>    <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">rs</span>([])<br>    &#125;<br>    <br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 注意有的数组项有可能不是Promise，需要手动转化一下</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-comment">// 收集每个Promise的返回值 </span><br>        result[ i ] = res<br>        <span class="hljs-comment">// 当所有的Promise都成功了，那么将返回的Promise结果设置为result</span><br>        <span class="hljs-keyword">if</span> (count === len) &#123;<br>          <span class="hljs-title function_">rs</span>(result)<br>        &#125;<br>        <span class="hljs-comment">// 监听数组项中的Promise catch只要有一个失败，那么我们自己返回的Promise也会失败</span><br>      &#125;).<span class="hljs-title function_">catch</span>(rj)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 测试一下</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>), <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>), <span class="hljs-number">3000</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err4&#x27;</span>)<br><span class="hljs-keyword">const</span> p5 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err5&#x27;</span>)<br><span class="hljs-comment">// 1. 所有的Promise都成功了</span><br><span class="hljs-keyword">const</span> p11 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myAll</span>([ p1, p2, p3 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// [ 1, 2, 3 ]</span><br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)<br>      <br><span class="hljs-comment">// 2. 有一个Promise失败了</span><br><span class="hljs-keyword">const</span> p12 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myAll</span>([ p1, p2, p4 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// err4</span><br>      <br><span class="hljs-comment">// 3. 有两个Promise失败了，可以看到最终输出的是err4，第一个失败的返回值</span><br><span class="hljs-keyword">const</span> p13 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myAll</span>([ p1, p4, p5 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>) <span class="hljs-comment">// err4</span><br><span class="hljs-comment">// 与原生的Promise.all返回是一致的    </span><br></code></pre></td></tr></table></figure><h2 id="4-Promise-allSettled"><a href="#4-Promise-allSettled" class="headerlink" title="4.Promise.allSettled"></a>4.Promise.allSettled</h2><h3 id="简要回顾-3"><a href="#简要回顾-3" class="headerlink" title="简要回顾"></a>简要回顾</h3><blockquote><p>有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。显然<code>Promise.all</code>(其只要是一个失败了，结果即进入失败状态)不太适合，所以有了<code>Promise.allSettled</code></p></blockquote><blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">Promise.allSettled()`方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是`fulfilled`还是`rejected`），返回的 Promise 对象才会发生状态变更,一旦发生状态变更，状态总是`fulfilled`，不会变成`rejected<br></code></pre></td></tr></table></figure></blockquote><p>还是以上面的例子为例， 我们看看与<code>Promise.all</code>有什么不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>), <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>), <span class="hljs-number">3000</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err4&#x27;</span>)<br><span class="hljs-keyword">const</span> p5 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err5&#x27;</span>)<br><span class="hljs-comment">// 1. 所有的Promise都成功了</span><br><span class="hljs-keyword">const</span> p11 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([ p1, p2, p3 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res, <span class="hljs-literal">null</span>,  <span class="hljs-number">2</span>)))<br><br><span class="hljs-comment">// 输出 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 1</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 2</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 3</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br>      <br><span class="hljs-comment">// 2. 有一个Promise失败了</span><br><span class="hljs-keyword">const</span> p12 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([ p1, p2, p4 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res, <span class="hljs-literal">null</span>,  <span class="hljs-number">2</span>)))<br>        <br><span class="hljs-comment">// 输出 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 1</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 2</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;rejected&quot;,</span><br><span class="hljs-comment">    &quot;reason&quot;: &quot;err4&quot;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br>      <br><span class="hljs-comment">// 3. 有两个Promise失败了</span><br><span class="hljs-keyword">const</span> p13 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([ p1, p4, p5 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res, <span class="hljs-literal">null</span>,  <span class="hljs-number">2</span>)))<br>        <br><span class="hljs-comment">// 输出 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 1</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;rejected&quot;,</span><br><span class="hljs-comment">    &quot;reason&quot;: &quot;err4&quot;</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;rejected&quot;,</span><br><span class="hljs-comment">    &quot;reason&quot;: &quot;err5&quot;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>可以看到：</strong></p><ol><li>不管是全部成功还是有部分失败，最终都会进入<code>Promise.allSettled</code>的<code>.then</code>回调中</li><li>最后的返回值中，成功和失败的项都有<code>status</code>属性，成功时值是<code>fulfilled</code>，失败时是<code>rejected</code></li><li>最后的返回值中，成功含有<code>value</code>属性，而失败则是<code>reason</code>属性</li></ol><h3 id="源码实现-3"><a href="#源码实现-3" class="headerlink" title="源码实现"></a>源码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">myAllSettled</span> = <span class="hljs-function">(<span class="hljs-params">promises</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">rs, rj</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> result = []<br>    <span class="hljs-keyword">const</span> len = promises.<span class="hljs-property">length</span><br>    <span class="hljs-comment">// 数组是空的话，直接返回空数据</span><br>    <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>([])<br>    &#125;<br><br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p, i</span>) =&gt;</span> &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-comment">// 成功属性设置 </span><br>        result[ i ] = &#123;<br>          <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>,<br>          <span class="hljs-attr">value</span>: res<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (count === len) &#123;<br>          <span class="hljs-title function_">rs</span>(result)<br>        &#125;<br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-comment">// 失败属性设置 </span><br>        result[i] = &#123; <br>          <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, <br>          <span class="hljs-attr">reason</span>: err <br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (count === len) &#123;<br>          <span class="hljs-title function_">rs</span>(result)<br>        &#125;<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 测试一下</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>), <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>), <span class="hljs-number">3000</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err4&#x27;</span>)<br><span class="hljs-keyword">const</span> p5 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err5&#x27;</span>)<br><span class="hljs-comment">// 1. 所有的Promise都成功了</span><br><span class="hljs-keyword">const</span> p11 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myAllSettled</span>([ p1, p2, p3 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res, <span class="hljs-literal">null</span>,  <span class="hljs-number">2</span>)))<br><br><span class="hljs-comment">// 输出 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 1</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 2</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 3</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br>      <br><span class="hljs-comment">// 2. 有一个Promise失败了</span><br><span class="hljs-keyword">const</span> p12 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myAllSettled</span>([ p1, p2, p4 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res, <span class="hljs-literal">null</span>,  <span class="hljs-number">2</span>)))<br>        <br><span class="hljs-comment">// 输出 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 1</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 2</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;rejected&quot;,</span><br><span class="hljs-comment">    &quot;reason&quot;: &quot;err4&quot;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br>      <br><span class="hljs-comment">// 3. 有两个Promise失败了</span><br><span class="hljs-keyword">const</span> p13 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myAllSettled</span>([ p1, p4, p5 ])<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res, <span class="hljs-literal">null</span>,  <span class="hljs-number">2</span>)))<br>        <br><span class="hljs-comment">// 输出 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;fulfilled&quot;,</span><br><span class="hljs-comment">    &quot;value&quot;: 1</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;rejected&quot;,</span><br><span class="hljs-comment">    &quot;reason&quot;: &quot;err4&quot;</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    &quot;status&quot;: &quot;rejected&quot;,</span><br><span class="hljs-comment">    &quot;reason&quot;: &quot;err5&quot;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="5-Promise-race"><a href="#5-Promise-race" class="headerlink" title="5.Promise.race"></a>5.Promise.race</h2><h3 id="简单回顾"><a href="#简单回顾" class="headerlink" title="简单回顾"></a>简单回顾</h3><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">const</span> p = Promise.race([<span class="hljs-built_in">p1</span>, <span class="hljs-built_in">p2</span>, <span class="hljs-built_in">p3</span>])<br>复制代码<br></code></pre></td></tr></table></figure><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-number">1</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-number">2</span>)<br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// 2</span><br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2, <span class="hljs-number">3</span>]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// 3</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="源码实现-4"><a href="#源码实现-4" class="headerlink" title="源码实现"></a>源码实现</h3><blockquote><p>聪明的你一定马上知道该怎么实现了，只要了解哪个实例先改变了，那么<code>Promise.race</code>就跟随这个结果，那么就可以写出以下代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">myRace</span> = <span class="hljs-function">(<span class="hljs-params">promises</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">rs, rj</span>) =&gt;</span> &#123;<br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 对p进行一次包装，防止非Promise对象</span><br>      <span class="hljs-comment">// 并且对齐进行监听，将我们自己返回的Promise的resolve，reject传递给p，哪个先改变状态，我们返回的Promise也将会是什么状态</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(rs).<span class="hljs-title function_">catch</span>(rj)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-number">1</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-number">2</span>)<br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myRace</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// 2</span><br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">myRace</span>([p1, p2, <span class="hljs-number">3</span>]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// 3</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>overwrite-promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中的$nextTick是怎么实现的</title>
    <link href="/blog/2022/11/04/vue-nextTick/"/>
    <url>/blog/2022/11/04/vue-nextTick/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue中的-nextTick是怎么实现的"><a href="#Vue中的-nextTick是怎么实现的" class="headerlink" title="Vue中的$nextTick是怎么实现的"></a>Vue中的$nextTick是怎么实现的</h1><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h3><p>vue官方对nextTick的说明：</p><p>​<a href="https://v2.cn.vuejs.org/v2/api/#vm-nextTick">https://v2.cn.vuejs.org/v2/api/#vm-nextTick</a></p><h3 id="2-简单示例"><a href="#2-简单示例" class="headerlink" title="2.简单示例"></a>2.简单示例</h3><p>先看一个简单的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div @click=&quot;handleClick&quot; ref=&quot;div&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/div<br>&lt;/template&gt;<br>&lt;script&gt;<br>  export default &#123;<br>    data() &#123;<br>      return &#123;<br>        text: &#x27;old&#x27;<br>      &#125;<br>    &#125;,<br>    methods: &#123;<br>      handleClick() &#123;<br>        this.text = &#x27;new&#x27;<br>        console.log(this.$refs.div.innerText)<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>此时打印的结果是什么呢？是 <code>&#39;old&#39;</code>。如果想让它打印 <code>&#39;new&#39;</code>，使用 <code>nextTick</code> 稍加改造就可以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">div</span>.<span class="hljs-property">innerText</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-github源码实现"><a href="#3-github源码实现" class="headerlink" title="3.github源码实现"></a>3.github源码实现</h3><p>但是你想过它内部是怎么实现的么，和我们写 <code>setTimeout</code> 有什么区别呢？</p><p>因为平时工作使用的是Vue2，所以我就以Vue2的最新版本2.6.14为例进行分析，Vue3的实现应该也是大同小异。</p><p>源码地址：<a href="https://link.juejin.cn/?target=https://github.com/vuejs/vue/blob/2.6/src/core/util/next-tick.js">github.com&#x2F;vuejs&#x2F;vue&#x2F;b…</a></p><p>为了方便阅读我删掉了注释，只关注最重要的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">Promise</span>)) &#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    p.<span class="hljs-title function_">then</span>(flushCallbacks)<br>    <span class="hljs-keyword">if</span> (isIOS) <span class="hljs-built_in">setTimeout</span>(noop)<br>  &#125;<br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MutationObserver</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; (<br>  <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">MutationObserver</span>) || <span class="hljs-title class_">MutationObserver</span>.<span class="hljs-title function_">toString</span>() === <span class="hljs-string">&#x27;[object MutationObserverConstructor]&#x27;</span><br>)) &#123;<br>  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(flushCallbacks)<br>  <span class="hljs-keyword">const</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-title class_">String</span>(counter))<br>  observer.<span class="hljs-title function_">observe</span>(textNode, &#123;<br>    <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span><br>  &#125;)<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span><br>    textNode.<span class="hljs-property">data</span> = <span class="hljs-title class_">String</span>(counter)<br>  &#125;<br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(setImmediate)) &#123;<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setImmediate</span>(flushCallbacks)<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-分开解析源码"><a href="#4-分开解析源码" class="headerlink" title="4.分开解析源码"></a>4.分开解析源码</h3><p>先大概扫一遍可知 <code>$nextTick</code> 主要是通过微任务来实现的，其实在2.5版本中，是采用宏任务与微任务相结合的方式实现的，但因为在渲染和事件处理中一些比较怪异的行为（感兴趣的话可以看下issue），所以最终统一采用了微任务。</p><h4 id="1-先看第一块："><a href="#1-先看第一块：" class="headerlink" title="1.先看第一块："></a>1.先看第一块：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">Promise</span>)) &#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    p.<span class="hljs-title function_">then</span>(flushCallbacks)<br>    <span class="hljs-keyword">if</span> (isIOS) <span class="hljs-built_in">setTimeout</span>(noop)<br>  &#125;<br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果可以使用 <code>Promise</code> ，就采用 <code>promise.then</code> 的方式去执行回调，将任务在下一个tick执行。但是其中 <code>if (isIOS) setTimeout(noop)</code> 这句话是在做什么呢？在iOS &gt;&#x3D; 9.3.3的UIWebView中，定义的回调函数通过 <code>Promise</code> 的方式推到微任务队列后，队列不刷新，需要靠 <code>setTimeout</code> 来强制更新一下，<code>noop</code> 就是一个空函数。</p><h4 id="2-再看第二块："><a href="#2-再看第二块：" class="headerlink" title="2.再看第二块："></a>2.再看第二块：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MutationObserver</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; (<br>  <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">MutationObserver</span>) || <span class="hljs-title class_">MutationObserver</span>.<span class="hljs-title function_">toString</span>() === <span class="hljs-string">&#x27;[object MutationObserverConstructor]&#x27;</span><br>)) &#123;<br>  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(flushCallbacks)<br>  <span class="hljs-keyword">const</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-title class_">String</span>(counter))<br>  observer.<span class="hljs-title function_">observe</span>(textNode, &#123;<br>    <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span><br>  &#125;)<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span><br>    textNode.<span class="hljs-property">data</span> = <span class="hljs-title class_">String</span>(counter)<br>  &#125;<br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果不能用 <code>Promise</code> 就降级使用 <code>MutationObserver</code>。创建了一个文本节点，并通过 <code>observer</code> 去观察文本节点的变化。 <code>characterData: true</code> 这个配置就是当文字变化的时候就会执行回调。<code>(counter + 1) % 2</code> 会使文本节点的文字在 <code>0</code> 、 <code>1</code> 、 <code>0</code> 、 <code>1</code>之间不同变化，这样就会被 <code>observer</code> 观察到。<code>MutationObserver</code> 也是微任务。</p><h4 id="3-然后是第三块："><a href="#3-然后是第三块：" class="headerlink" title="3.然后是第三块："></a>3.然后是第三块：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(setImmediate)) &#123; <br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123; <br>    <span class="hljs-title function_">setImmediate</span>(flushCallbacks) <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>当微任务都不被支持时，就要使用宏任务了。其实大多数情况下都不会走到这里，因为 <code>setImmediate</code> 并没有成为正式的标准，并且兼容性很差。</p><h4 id="4-最后是第四块："><a href="#4-最后是第四块：" class="headerlink" title="4.最后是第四块："></a>4.最后是第四块：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">else</span> &#123;<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在所有方案都行不通时，只能采用 <code>setTimeout</code> 的方式。之所以有第三块是因为虽然都是宏任务，但是 <code>setImmediate</code> 会比 <code>setTimeout</code> 快，所以MDN上才会说 <code>setTimeout(fn, 0)</code> 不能成为 <code>setImmediate</code> 的polyfill。就像作者在注释中写的那样：它仍然是比 <code>setTimeout</code> 更好的选择。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nextTick</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题常问2</title>
    <link href="/blog/2022/11/04/interview-20221104/"/>
    <url>/blog/2022/11/04/interview-20221104/</url>
    
    <content type="html"><![CDATA[<h1 id="面试中整理的面试题"><a href="#面试中整理的面试题" class="headerlink" title="面试中整理的面试题"></a>面试中整理的面试题</h1><h4 id="一、某地产的面试"><a href="#一、某地产的面试" class="headerlink" title="一、某地产的面试"></a>一、某地产的面试</h4><h6 id="1、机试"><a href="#1、机试" class="headerlink" title="1、机试"></a>1、机试</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">1、把一个url拆解成origin、文件名、<span class="hljs-built_in">hash</span>拆解成示例的格式。<br>2、两个数组合并成一个数组，并进行算法优化。<br>3、设置值的时候是数字，输出的时候变成百分号的格式。<br>4、首屏优化的方案，分别从代码、网络和缓存说一下。<br>5、如果一次性增加100万个用户访问项目，前端角度你会怎么优化。<br>6、分别用es5和es6的方式解决一个继承问题<br>复制代码<br></code></pre></td></tr></table></figure><h6 id="2、现场面试"><a href="#2、现场面试" class="headerlink" title="2、现场面试"></a>2、现场面试</h6><p>第一轮的机试过了，约了下周进行面试。</p><p>双休在知乎上搜了一下这家公司，网上风评说该公司pua太严重、领导搞小团体，技术栈也不是我熟悉的，给的薪资不高，就拒绝接下来的面试了。</p><h4 id="二、某医疗集团的面试"><a href="#二、某医疗集团的面试" class="headerlink" title="二、某医疗集团的面试"></a>二、某医疗集团的面试</h4><h6 id="1、笔试"><a href="#1、笔试" class="headerlink" title="1、笔试"></a>1、笔试</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">1</span>、宏任务和微任务输出执行问题，打印结果？<br><span class="hljs-number">2</span>、<span class="hljs-keyword">this</span>指向的问题，打印结果？<br><span class="hljs-number">3</span>、computed和watch的使用有什么区别？<br><span class="hljs-number">4</span>、react和vue有什么区别？<br><span class="hljs-number">5</span>、你认为好的团队协作方式应该怎样的？<br><span class="hljs-number">6</span>、你做过哪些项目上的性能优化？<br>复制代码<br></code></pre></td></tr></table></figure><h6 id="2、一面"><a href="#2、一面" class="headerlink" title="2、一面"></a>2、一面</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1</span>、简单介绍一下你自己<br><span class="hljs-number">2</span>、你项目中说自己整理了文档规范、代码规范、项目规范，你说下都做了哪些具体的事情？<br><span class="hljs-number">3</span>、你说在项目各阶段都做了问题的汇总，举例一个你印象最深的问题和解决方案？<br><span class="hljs-number">4</span>、发布上线时间平均由<span class="hljs-number">10</span>分钟提高到<span class="hljs-number">1</span>分钟，你前后做了哪些优化达到这个目标的？<br><span class="hljs-number">5</span>、服务端异常这个问题你是怎么捕捉的？<br><span class="hljs-number">6</span>、webpack的构建流程是怎样的？<br><span class="hljs-number">7</span>、webpack做过哪些优化？<br><span class="hljs-number">8</span>、es <span class="hljs-keyword">module</span>和babel分别有什么作用？<br><span class="hljs-number">9</span>、es <span class="hljs-keyword">module</span>的执行逻辑是怎样的？<br><span class="hljs-number">10</span>、你是如何理解单文件组件的？<br><span class="hljs-number">11</span>、编译<span class="hljs-keyword">template</span>之后最终会生成什么，过程是怎样的？<br><span class="hljs-number">12</span>、vue3在模板方面做了哪些优化？<br><span class="hljs-number">13</span>、说一下响应式原理？<br><span class="hljs-number">14</span>、你在响应式中说到diff算法，那diff算法的目的是什么？<br><span class="hljs-number">15</span>、为什么要引入$set和$<span class="hljs-keyword">delete</span>这两个api？<br><span class="hljs-number">16</span>、你怎么理解异步更新机制的？<br><span class="hljs-number">17</span>、如果我在computed中依赖的data变化，但是返回值没有变化，这个computed会更新吗？<br><span class="hljs-number">18</span>、说一下v-<span class="hljs-keyword">for</span>中key的作用，key值用了下标会存在什么问题？<br><span class="hljs-number">19</span>、说一下作用域的理解？<br><span class="hljs-number">20</span>、说一下原型和原型链？<br><span class="hljs-number">21</span>、说一下如果让你去封装一下extends函数，你会考虑怎么封装？<br><span class="hljs-number">22</span>、说一下<span class="hljs-keyword">this</span>的指向有哪些？<br><span class="hljs-number">23</span>、闭包有什么特别，解决什么问题？<br><span class="hljs-number">24</span>、call、apply的封装应该怎么处理？<br>复制代码<br></code></pre></td></tr></table></figure><h6 id="3、二面"><a href="#3、二面" class="headerlink" title="3、二面"></a>3、二面</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs">1、你说一下这个错误监控上报功能是怎么做的？<br>2、你作为负责人的时候，接手的时候团队有多少人？<br>3、埋点自己开发的还是第三方的，主要埋哪些数据？<br>4、你们通过埋点的数据怎么做分析的？<br>5、你这个发布上线时间平均由10分钟提高到1分钟，做了哪些事情达到这个目标的？<br>6、你的职业规划是怎样的？<br>7、你跟你团队的人员是怎么配合的？<br>8、你大学专业不是计算机，怎么干起了编程呢，说一下过程？<br>9、你想要怎样的公司氛围？<br>10、你还有什么想问我的吗？<br>复制代码<br></code></pre></td></tr></table></figure><h6 id="4、人事面"><a href="#4、人事面" class="headerlink" title="4、人事面"></a>4、人事面</h6><p>人事面遇到的问题都比较类似，我在下面会专门拿一个部分汇总人事面的问题。</p><p>该公司把4轮面试放在了一个下午，直接去了现场面试。因为一轮面试回答的成功率90%以上，跟面试官聊得越来越深入，所以二面的时候基本就问了一些业务和求职意向的问题，也没有给我挖坑。</p><p>第二天人事给我回了电话，说了能给到薪资，我回复考虑一下，然后再决定接不接受offer，考虑了2天，接受了这家公司的offer。</p><h4 id="三、某基金公司的面试"><a href="#三、某基金公司的面试" class="headerlink" title="三、某基金公司的面试"></a>三、某基金公司的面试</h4><h6 id="1、一面"><a href="#1、一面" class="headerlink" title="1、一面"></a>1、一面</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>、简单的介绍一下你自己<br><span class="hljs-number">2</span>、你们这项项目中有微信公众号、后台管理端、医生app端和小程序端，有没有提炼出一些公共的工具js，怎么提炼的？<br><span class="hljs-number">3</span>、你们的git分支管理是怎么样的？<br><span class="hljs-number">4</span>、你在做完前端项目之后，一般都会写哪些文档，readme里面写一些什么？<br><span class="hljs-number">5</span>、你做完一个项目之后写一些什么内容，让接手你的人能够看懂你的项目架构，并且迅速上手？<br><span class="hljs-number">6</span>、你基于你的脚手架做了哪些优化？<br><span class="hljs-number">7</span>、你们的项目文档一般都要记录哪些基本的东西？<br><span class="hljs-number">8</span>、有在项目中遇到过xss攻击吗？<br><span class="hljs-number">9</span>、你这个错误数据上报了哪些数据，怎么实现的？<br><span class="hljs-number">10</span>、成功抵御过多次攻击能具体说一说吗？<br><span class="hljs-number">11</span>、说一下你在项目中遇到印象深刻的项目场景，并且怎么解决的？<br><span class="hljs-number">12</span>、能说一下session跟jwt的优缺点吗？<br><span class="hljs-number">13</span>、你说用户登录之后要在session中加入user_name，为什么要增加？<br><span class="hljs-number">14</span>、jwt的整个流程怎么实现的？<br><span class="hljs-number">15</span>、实现jwt的实现遇到什么困难了吗？<br><span class="hljs-number">16</span>、如果同一部手机用户<span class="hljs-selector-tag">A</span>登录了，更换了<span class="hljs-selector-tag">B</span>登录，此时使用jwt会出现什么问题？<br>  - 我觉得这里他给挖坑了，<span class="hljs-selector-tag">B</span>登录了之后就会返回<span class="hljs-selector-tag">B</span>用户的token，然后请求头带着的就是<span class="hljs-selector-tag">B</span>的token，验证到的用户也就是<span class="hljs-selector-tag">B</span>，我认为没有问题啊。我不太清楚他说的可能会有什么问题值啥情况，可能是我考虑不周全，如果有网友知道可以提醒一下我他想问的答案，让我学习一下。<br><span class="hljs-number">17</span>、当线上出了紧急bug的时候，你们是怎么处理的？<br><span class="hljs-number">18</span>、你们团队成员是怎么配合完成任务的？<br><span class="hljs-number">19</span>、你近<span class="hljs-number">2</span>年的职业规划？<br><span class="hljs-number">20</span>、还有什么想问我的吗？<br>复制代码<br></code></pre></td></tr></table></figure><p>问的一些问题偏向于后端，面试官大概是java工程师吧。然后从团队管理、怎么让新来的成员快速接手项目、文档方便的管理等等；前端技术问题整个面试过程中占比不大。</p><p>看得出来至少要在团队管理方面有比较深的总结，并且对于团队管理积累上，自己有独有的见解，一面才能面试通过啊。</p><p>一面就败了的原因，个人认为一方面即使把自己的技术能力提升到很厉害的水平，可能与这个岗位也不符合，这个看运气和面试官的感觉。</p><p>另一方面，我觉得有可能招聘单位也没太想清楚要招聘怎样的人吧，因为这些问题放在问java、net工程师上估计也行得通。</p><h4 id="四、某电商公司的面试"><a href="#四、某电商公司的面试" class="headerlink" title="四、某电商公司的面试"></a>四、某电商公司的面试</h4><h6 id="1、一面-1"><a href="#1、一面-1" class="headerlink" title="1、一面"></a>1、一面</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">1</span>、事件循环的机制了解吗？宏任务和微任务的执行顺序是怎样的？<br><span class="hljs-number">2</span>、怎么理解闭包这个定义的，在平时工作中有用到闭包的使用吗，举个例子。<br><span class="hljs-number">3</span>、vue组件间的哪些通信方式？<br><span class="hljs-number">4</span>、一个父组件潜嵌套了子组件，他的生命周期函数顺序是怎么执行的？<br><span class="hljs-number">5</span>、vue的权限管理应该怎么做？路由级和按钮级分别怎么处理？<br><span class="hljs-number">6</span>、说一下你对虚拟DOM的理解<br><span class="hljs-number">7</span>、了解diff算法吗？vue的diff算法是怎样的一个过程<br><span class="hljs-number">8</span>、能说一下v-<span class="hljs-keyword">for</span>中key的作用吗？<br><span class="hljs-number">9</span>、做过vue项目哪些性能方面的优化？<br><span class="hljs-number">10</span>、vue组件为什么只能有一个根元素？<br><span class="hljs-number">11</span>、如何实现路由懒加载呢？<br><span class="hljs-number">12</span>、客户端渲染和服务端渲染有什么区别呢？在之前的工作中有做过服务端渲染吗？<br><span class="hljs-number">13</span>、Vue长列表的优化方式怎么做？<br><span class="hljs-number">14</span>、Vue3相比Vue2有哪些优化？<br><span class="hljs-number">15</span>、为什么在模板中绑定事件的时候要加.native?<br><span class="hljs-number">16</span>、能说一下响应式原理的过程吗？<br><span class="hljs-number">17</span>、数组的响应式怎么实现的？<br><span class="hljs-number">18</span>、Vue是数据改变后页面也会重新改变嘛；<span class="hljs-keyword">this</span>.a = <span class="hljs-number">1</span>; <span class="hljs-keyword">this</span>.a = <span class="hljs-number">2</span>; 他是怎么实现异步更新优化整个渲染过程的？<br><span class="hljs-number">19</span>、render函数封装有什么特别的，或者用到比较巧妙的东西吗？<br><span class="hljs-number">20</span>、浏览器缓存的方式有哪些？<br><span class="hljs-number">21</span>、正向代理和反向代理的区别？<br><span class="hljs-number">22</span>、域名解析过程是怎样的？<br><span class="hljs-number">23</span>、TCP协议三次握手、四次挥手的过程，为什么挥手要<span class="hljs-number">4</span>次？<br>复制代码<br></code></pre></td></tr></table></figure><h6 id="2、二面"><a href="#2、二面" class="headerlink" title="2、二面"></a>2、二面</h6><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1</span>、nextTick, setTimeout 以及 setImmediate 三者有什么区别?<br><span class="hljs-number">2</span>、说一下你在项目的安全性做了哪些工作？<br><span class="hljs-number">3</span>、当一张表数据量比较多的时候，为了提高查询速度，你们一般会使用哪些方式做优化？<br><span class="hljs-number">4</span>、webSocket与传统的http相比有什么优势？<br><span class="hljs-number">5</span>、用过koa吗？简要阐述一下koa的洋葱模型。<br><span class="hljs-number">6</span>、用过promise吗？它的使用是为了解决一个什么问题？promise底层是怎么设计的？<br><span class="hljs-number">7</span>、你们现在整个登录鉴权是怎么设计的？如果要考虑单点登录呢，会如何设计？<br><span class="hljs-number">8</span>、如何用同一套代码部署到服务器中，怎么区分当前本地开发环境还是线上环境？是测试环境还是生产环境呢，怎么去区分？<br><span class="hljs-number">9</span>、待支付的订单，到期后主动取消这个功能你会怎么设计去做？<br><span class="hljs-number">10</span>、如果要做音视频的安全性，你能想到哪些方案？<br><span class="hljs-number">11</span>、多台服务器部署定时任务怎么保证一个任务只会做一遍呢？<br><span class="hljs-number">12</span>、你觉得程序员除了提升技术能力之外，其他什么能力你比较看重？<br>复制代码<br></code></pre></td></tr></table></figure><h6 id="3、人事面"><a href="#3、人事面" class="headerlink" title="3、人事面"></a>3、人事面</h6><p>人事面遇到的问题都比较类似，我在下面会专门拿一个部分汇总人事面的问题。</p><p>该公司最后也拿到了offer。</p><h4 id="五、某保险集团的面试"><a href="#五、某保险集团的面试" class="headerlink" title="五、某保险集团的面试"></a>五、某保险集团的面试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">1、你在项目中用到mongodb吗？<br>2、在项目中用到mongodb存储哪些数据？<br>3、mongodb的管道有了解吗？聚合管道怎么用的？<br>4、mongodb和的mysql优缺点？<br>5、你对事务性的了解是怎样的？<br>6、node怎么开启子进程？<br>7、在一台机器上开启负载均衡的时候，如果这个项目有用到定时任务，你怎么去控制这个定时任务只会执行一次？<br>8、你在egg中怎么开启子进程，怎么编写一个定时任务？<br>9、react用的多吗？<br>10、react组件间通信的方式有哪些？<br>11、vuex跟redux的区别有哪些？<br>12、computed和watch的区别？<br>13、watch和computed哪一个可以实现异步？<br>14、vue的通信方式有哪些？<br>15、vue的<span class="hljs-built_in">history</span>模式和<span class="hljs-built_in">hash</span>模式的区别是什么？<br>16、<span class="hljs-built_in">history</span>模式下会出现404，怎么处理？<br>17、你能说一下闭包的优缺点吗？<br>18、内存泄漏和内存溢出有什么区别？<br>19、还有什么想问我的吗？<br>复制代码<br></code></pre></td></tr></table></figure><p>该岗位是node全栈工程师的岗位，对后端的知识点问题的比较深，一层一层的往下问，我后端的知识点稍微薄弱一些，很多很细的问题答不上来；他那边技术栈用的是react，我复习的知识也比较少。</p><p>扑街了理所当然。</p><h4 id="六、某海外直播平台的面试"><a href="#六、某海外直播平台的面试" class="headerlink" title="六、某海外直播平台的面试"></a>六、某海外直播平台的面试</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1.1</span>、自我介绍？<br><span class="hljs-number">1.2</span>、常用的选择器有哪些，优先级怎么样？（除了这些还有其他的嘛）<br><span class="hljs-number">1.3</span>、垂直居中的实现方案有哪些？<br><span class="hljs-number">2.1</span>、你说的网格布局grid垂直居中有哪些属性值？<br><span class="hljs-number">2.2</span>、width:<span class="hljs-number">100</span>%和width:<span class="hljs-keyword">auto</span>有什么区别？<br><span class="hljs-number">3</span>、说一下cookie的作用是什么？<br><span class="hljs-number">4</span>、cookie有哪些属性？<br><span class="hljs-number">5</span>、设置cookie的domain用来实现什么功能？<br><span class="hljs-number">6</span>、懒加载的实现原理是怎样的？（除了你说的那一种还有其他的嘛）<br><span class="hljs-number">7</span>、vue中路由懒加载怎么实现？（除了你说的这一种还有其他的嘛）<br><span class="hljs-number">8</span>、说一下原型链的理解？<br><span class="hljs-number">9</span>、原型链__proto__这个隐式属性的实现原理是怎样的？<br><span class="hljs-number">10</span>、说一下vue中双向数据绑定？<br><span class="hljs-number">11</span>、vue中computed和watch的区别是什么？<br><span class="hljs-number">12</span>、说一下你们的前端登录流程是怎样的？<br><span class="hljs-number">13</span>、jwt是什么？<br><span class="hljs-number">14</span>、jwt由哪些部分组成？<br><span class="hljs-number">15</span>、你在项目中怎么实现打包优化的？<br><span class="hljs-number">16</span>、你说的这些优化方式是webpack哪个版本的？<br><span class="hljs-number">17</span>、你说一下项目中比较困难的事情有哪些（BFF处理模式）？<br><span class="hljs-number">18</span>、你们部署上线是怎么做的？<br><span class="hljs-number">19</span>、在项目中有使用jekenis和docker这些吗？<br><span class="hljs-number">20</span>、有什么想问我的吗？<br>复制代码<br></code></pre></td></tr></table></figure><p>我记得网格布局是有 <code>justify-content</code>和 <code>align-items</code>属性，并且面试之后专门写了一个文件测试，测试通过。面试官说我属性记错了。</p><p><code>width:100%</code>和 <code>width:auto有什么区别?</code>这个问题我没回答出来，最后我问面试官他们的区别是什么。面试结束之后我按照他说的那种方式，也没测试出来区别，很纳闷。</p><p><code>原型链__proto__这个隐式属性的实现原理是怎样的？</code>，我以为这个问题就是让我说一下 <code>实例.__proto__</code>指向构造函数的原型，抓住这个点然后扩展一下原型链的知识就好了。他说不是要你回答这个，而是让我说一下__proto__的底层实现，这个问题我不知道，有知道的朋友可以在评论区帮我回复一下，我学习一下这个知识点。</p><p>整个面试从面试官的表达上可以看得出来他有一些紧张，导致有一些问题我也听的不是特别清楚。结束之后我测试的几个知识点也没达到他说的效果，遗憾。</p><p>最后应该是挂了。</p><h3 id="人事面问题汇总"><a href="#人事面问题汇总" class="headerlink" title="人事面问题汇总"></a>人事面问题汇总</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>、对自己的评价？<br><span class="hljs-number">2</span>、你有哪些兴趣爱好？<br><span class="hljs-number">3</span>、描述一下你自己的优缺点?或者用三个词语描述你自己？<br><span class="hljs-number">4</span>、你在公司主要做一些什么工作？<br><span class="hljs-number">5</span>、离职原因是什么？<br><span class="hljs-number">6</span>、在工作之外有哪些学习技术的方式？<br><span class="hljs-number">7</span>、公司的整个开发流程是怎样的,你跟团队成员如何配合完成任务？<br><span class="hljs-number">8</span>、你有女(男)朋友了吗(稳定性)？<br><span class="hljs-number">9</span>、你有其他offer吗(稳定性)？<br><span class="hljs-number">10</span>、如何提高工作效率? <br><span class="hljs-number">11</span>、与领导意见不统一时应该怎么办?<br><span class="hljs-number">12</span>、你觉得目前自己的技术在什么位置，觉得自己哪一块能力需要加强？<br><span class="hljs-number">13</span>、您还有什么问题想问我的嘛? <br><span class="hljs-number">15</span>、你的职业规划是怎样的? <br><span class="hljs-number">16</span>、入职之后如何开展工作? <br><span class="hljs-number">17</span>、是否愿意接受加班?<br><span class="hljs-number">18</span>、你能为公司带来什么?你希望公司给你什么?<br><span class="hljs-number">19</span>、在项目中遇到了什么难点问题，最后怎么解决的？<br><span class="hljs-number">20</span>、谈一下你在上一家公司整个技术开发流程，你负责哪些工作？<br><span class="hljs-number">21</span>、你希望自己以后的发展方向是什么？<br>复制代码<br></code></pre></td></tr></table></figure><p>人事的这些问题每次都大差不差，这些都问都可以提前自问自答，准备好最好的状态，回复人事。也就是我们常说的：我预判了人事的预判。整理50道左右的面试常问题目，足以应付目前的人事挖坑问题。</p><h3 id="接下来的计划"><a href="#接下来的计划" class="headerlink" title="接下来的计划"></a>接下来的计划</h3><p>在这次的面试中，也发现了自己能力的不足。比如我之前通过node写了一些提升团队的工具，用于提升自己在团队中的kpi。但是在纯前端中可能只能作为一家加分项来看，因为如果问到很具体的node的内存问题、mongodb细节的问题，可能就会被问到哑口无言了，这样整个面试体验确实会比较糟糕。</p><p>深圳很多大公司都是用的react，我之前在项目中用react比较少，所以入职公司之后要把react用起来，不用起来就会忘。</p><p>然后vue3的源码和优化的方面也要继续看看了。</p><p>还有这一次没有投递大厂的原因是我没有刷算法，这一点在之前的求职过程中都没有重视起来。现在年限到这了，必须要刷起来，才能更进一步提升自己。</p><h3 id="给大家的一个建议"><a href="#给大家的一个建议" class="headerlink" title="给大家的一个建议"></a>给大家的一个建议</h3><p>我在面试的过程中有一个体会，就是：当面试官问你一个很大的问题的时候，你要怎么回答？</p><p>比如面试官问题，简单的跟我说一下继承是什么吧？</p><p>很多朋友遇到这样的一个问题，马上就大脑蒙圈了，脑袋里很紊乱，知道很多，但是无法把他们串起来，不知道从何说起，导致回答的结果不是很好。</p><p>所以像这些技能题，我们在记笔记的时候也应该用这样的方式去记忆和背诵。遵循下面的几个步骤就行了，套公式的方式，一点也不会慌乱。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1、解释是什么的问题。<br>2、解释这个技术的应用点、应用场景在哪里。<br>3、整理一下这个问题的优缺点是什么。<br>复制代码<br></code></pre></td></tr></table></figure><p>我举一个例子来回答一下。比如面试官问：<code>你给我讲一下闭包吧？</code></p><p>我就可以按照上面的归纳，分3步走的原则。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>. 闭包是：能够访问其他函数内部变量的函数。<br><span class="hljs-number">2</span>. 闭包一般会在：封装模块的时候，通过函数自执行函数的方式进行实现；或者在模仿块级作用域的时候实现；如：我们常用的库jQuery本身就是一个大的闭包。<br><span class="hljs-number">3</span>. 闭包的优点是：<br>    <span class="hljs-selector-tag">a</span>、能够在离开函数之后继续访问该函数的变量，变量一直保存在内存中。<br>    <span class="hljs-selector-tag">b</span>、闭包中的变量是私有的，只有闭包函数才有权限访问它。不会被外面的变量和方法给污染。<br>闭包的缺点是：<br>    <span class="hljs-selector-tag">a</span>、会增加对内存的使用量，影响性能。<br>    <span class="hljs-selector-tag">b</span>、不正确的使用闭包会造成内存泄漏。<br>复制代码<br></code></pre></td></tr></table></figure><p>针对上面闭包的回答，可能面试官又会继续问你：<code>内存泄漏是什么啊，你能给我讲一下吗？垃圾回收机制说一下吧？内存泄漏和内存溢出的区别是什么？</code>等等。</p><p>就是每一个问题的回答都是可以策划出来的，你回答完了这个问题之后，你可以先假设性的想一下面试官看到你的这个回答可能会问你什么。用上面面对人事的那种：<code>用你的预判去预判他可能的提问</code>。</p><p>这样就可以在这次的大萧条中获得更有利的条件。</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript手写reduce函数</title>
    <link href="/blog/2022/11/03/js-reduce/"/>
    <url>/blog/2022/11/03/js-reduce/</url>
    
    <content type="html"><![CDATA[<h1 id="javascript手写reduce函数"><a href="#javascript手写reduce函数" class="headerlink" title="javascript手写reduce函数"></a>javascript手写reduce函数</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>文章会从三个方面应对这道面试题：认识 <code>reduce</code>、使用 <code>reduce</code>、实现 <code>reduce</code>。 阅读本文，你将学到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> 认识<span class="hljs-string">`reduce`</span>函数；<br><span class="hljs-number">2.</span> <span class="hljs-string">`reduce`</span>函数常见使用场景；<br><span class="hljs-number">3.</span> 从<span class="hljs-number">0</span>到<span class="hljs-number">1</span>实现一个<span class="hljs-string">`reduce`</span>函数；<br></code></pre></td></tr></table></figure><h3 id="2-认识-reduce"><a href="#2-认识-reduce" class="headerlink" title="2. 认识 reduce"></a>2. 认识 reduce</h3><p><code>reduce()</code>方法对<strong>数组</strong>中<strong>每个元素</strong>执行一个由您提供的<strong>函数</strong>（升序执行），将其结果汇总为<strong>单个返回值</strong>。</p><p>注意几个关键词：<strong>数组、每个元素、函数、单个返回值</strong>。</p><p>通俗的解释一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> reduce是数组的一个方法；<br><span class="hljs-number">2.</span> 会对数组的每个元素进行处理，处理的函数作为形参传入；<br><span class="hljs-number">3.</span> reduce最后只返回一个结果；<br></code></pre></td></tr></table></figure><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-title function_">callback</span>(accumulator, currentValue[, index[, array]])[, initialValue])<br><span class="hljs-comment">// 举例</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur, index, array</span>) =&gt;</span> (arr + cur), initialValue)<br></code></pre></td></tr></table></figure><p>可以看到，<code>reduce</code> 接受两个参数：<code>callback</code> 函数、<code>initialValue</code> 初始值；其中，传入的处理数组每个元素的函数（<code>callback</code>）接受 4 个参数：</p><ul><li><ol><li><code>Accumulator</code> 累计器</li></ol></li><li><ol><li><code>Current Value</code> 当前值</li></ol></li><li><ol><li><code>Index</code> 当前索引</li></ol></li><li><ol><li><code>array</code> 源数组</li></ol></li></ul><p>每次处理一个元素，<code>callback</code> 都有返回值，这个返回值就是累计器，并最终成为单个结果。</p><h3 id="3-使用-reduce"><a href="#3-使用-reduce" class="headerlink" title="3. 使用 reduce"></a>3. 使用 reduce</h3><p>常用的使用场景：</p><h4 id="3-1-数组里所有值的和"><a href="#3-1-数组里所有值的和" class="headerlink" title="3.1 数组里所有值的和"></a>3.1 数组里所有值的和</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> initVal = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> total = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur, index, array</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(acc, cur);<br>  <span class="hljs-comment">// 0 1</span><br>  <span class="hljs-comment">// 1 2</span><br>  <span class="hljs-comment">// 3 3</span><br>  <span class="hljs-comment">// 6 4</span><br>  <span class="hljs-keyword">return</span> acc + cur;<br>&#125;, initVal);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total); <span class="hljs-comment">// 输出：10</span><br></code></pre></td></tr></table></figure><p>可以看到，在 <code>reduce</code> 有初始值的情况下, 第一次迭代累加器 <code>acc</code> 的值是 <code>0</code>, 当前值 <code>cur</code> 是 <code>1</code>, 现在把初始值去掉：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> total = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur, index, array</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(acc, cur);<br>  <span class="hljs-comment">// 1 2</span><br>  <span class="hljs-comment">// 3 3</span><br>  <span class="hljs-comment">// 6 4</span><br>  <span class="hljs-keyword">return</span> acc + cur;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total); <span class="hljs-comment">// 输出：10</span><br></code></pre></td></tr></table></figure><p>可以看到，第一次迭代的累加器 <code>acc</code> 的值是 <code>1</code>, 当前值 <code>cur</code> 是 <code>2</code>, 也就是说：<strong>有初始值的情况下: 累计器是从初始值开始累加；没有初始值的情况下：累计器是从数组的第一个元素开始累加</strong>。</p><h4 id="3-2-将二维数组转换为一维数组"><a href="#3-2-将二维数组转换为一维数组" class="headerlink" title="3.2 将二维数组转换为一维数组"></a>3.2 将二维数组转换为一维数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> res = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cur === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    acc = acc.<span class="hljs-title function_">concat</span>(cur);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    acc.<span class="hljs-title function_">push</span>(cur);<br>  &#125;<br>  <span class="hljs-keyword">return</span> acc;<br>&#125;, []);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br></code></pre></td></tr></table></figure><p>主要是通过数组的 <code>concat</code> 方法, 累计得到最终的一维数组。当然，二维数组转换为一维数组也可以使用<code>ECMAScript 2019</code>提出的<code>flat</code>方法(不支持 IE 浏览器)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>].<span class="hljs-title function_">flat</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 输出：[1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h4 id="3-3-计算数组中每个元素出现的次数"><a href="#3-3-计算数组中每个元素出现的次数" class="headerlink" title="3.3 计算数组中每个元素出现的次数"></a>3.3 计算数组中每个元素出现的次数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;kobe&#x27;</span>, <span class="hljs-string">&#x27;james&#x27;</span>, <span class="hljs-string">&#x27;kobe&#x27;</span>, <span class="hljs-string">&#x27;jim&#x27;</span>, <span class="hljs-string">&#x27;wade&#x27;</span>, <span class="hljs-string">&#x27;wade&#x27;</span>, <span class="hljs-string">&#x27;kobe&#x27;</span>];<br><span class="hljs-keyword">const</span> res = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(cur <span class="hljs-keyword">in</span> acc) &#123;<br>        acc[cur]++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        acc[cur] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> acc<br>&#125;, &#123;&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// 输出：&#123; kobe: 3, james: 1, jim: 1, wade: 2 &#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-4-按属性对object进行分类"><a href="#3-4-按属性对object进行分类" class="headerlink" title="3.4 按属性对object进行分类"></a>3.4 按属性对object进行分类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> players = [<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kobe&#x27;</span>, <span class="hljs-attr">number</span>: <span class="hljs-number">24</span> &#125;,<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-attr">number</span>: <span class="hljs-number">23</span> &#125;,<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jordon&#x27;</span>, <span class="hljs-attr">number</span>: <span class="hljs-number">23</span> &#125;,<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;George&#x27;</span>, <span class="hljs-attr">number</span>: <span class="hljs-number">24</span> &#125;<br>];<br><span class="hljs-keyword">const</span> groupe = players.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(!(item.<span class="hljs-property">number</span> <span class="hljs-keyword">in</span> acc)) &#123;<br>            acc[item.<span class="hljs-property">number</span>] = [];<br>        &#125;<br>        acc[item.<span class="hljs-property">number</span>].<span class="hljs-title function_">push</span>(item);<br>        <span class="hljs-keyword">return</span> acc<br>&#125;, &#123;&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(groupe)<br><span class="hljs-comment">// 输出</span><br>&#123;<br>    <span class="hljs-number">23</span>: [<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;James&#x27;</span>, <span class="hljs-attr">number</span>: <span class="hljs-number">23</span> &#125;,<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jordon&#x27;</span>, <span class="hljs-attr">number</span>: <span class="hljs-number">23</span> &#125;,<br>    ],<br>    <span class="hljs-number">24</span>: [<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kobe&#x27;</span>, <span class="hljs-attr">number</span>: <span class="hljs-number">24</span> &#125;,<br>        &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;George&#x27;</span>, <span class="hljs-attr">number</span>: <span class="hljs-number">24</span> &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-5-计算数组中的最大值"><a href="#3-5-计算数组中的最大值" class="headerlink" title="3.5 计算数组中的最大值"></a>3.5 计算数组中的最大值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> max = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(pre, cur));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(max) <span class="hljs-comment">// 输出：10</span><br><br><span class="hljs-comment">// 也可以使用`Math.max`配合扩展运算符找出最大值</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr)  <span class="hljs-comment">// 输出：10</span><br></code></pre></td></tr></table></figure><h4 id="3-6-数组去重"><a href="#3-6-数组去重" class="headerlink" title="3.6 数组去重"></a>3.6 数组去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">retArr, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(retArr.<span class="hljs-title function_">indexOf</span>(cur) === -<span class="hljs-number">1</span>) &#123;<br>        retArr.<span class="hljs-title function_">push</span>(cur);<br>    &#125;<br>    <span class="hljs-keyword">return</span> retArr<br>&#125;, [])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr) <span class="hljs-comment">// 输出：[3, 4, 6, 10, 5]</span><br><br><span class="hljs-comment">// 也可以使用Set数据结构来实现</span><br>[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)]; <span class="hljs-comment">// 输出：[3, 4, 6, 10, 5]</span><br></code></pre></td></tr></table></figure><h3 id="4-手写实现"><a href="#4-手写实现" class="headerlink" title="4. 手写实现"></a>4. 手写实现</h3><p>通过以上的一些使用场景，我们对reduce函数有了一些了解，先来分析下实现步骤：</p><ul><li><ol><li>reduce是个函数，且有一个返回值；</li></ol></li><li><ol><li>reduce接受两个参数，第一个是callback函数，第二个是初始值（可选）；</li></ol></li><li><ol><li>callback函数接受4个参数：累加器、当前值、当前索引、原数组；</li></ol></li><li><ol><li>callback函数有返回值，且返回值会赋值给第一个参数；</li></ol></li></ul><p>动手来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">selfReduce</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, initValue</span>) &#123;<br>        <span class="hljs-comment">// 获取源数组</span><br>        <span class="hljs-keyword">const</span> originArray = <span class="hljs-variable language_">this</span>;<br><br>        <span class="hljs-comment">// 判断源数组是否为空，如果为空，抛出异常</span><br>        <span class="hljs-keyword">if</span>(!originArray.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;selfReduce of empty array with no initial value&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 声明累计器</span><br>        <span class="hljs-keyword">let</span> accumulator<br><br>        <span class="hljs-comment">// 是否有初始值情况</span><br>        <span class="hljs-comment">// 设置累计器初始值（如果有初始值，第一次调用`callback`时，`callback`的第一个参数的值为初始值，否则为源数组的第一项）</span><br>        <span class="hljs-keyword">if</span> (initValue === <span class="hljs-literal">undefined</span>) &#123;<br>            accumulator = originArray[<span class="hljs-number">0</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            accumulator = initValue;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历数组，执行`callback`函数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; originArray.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-comment">// 如果是最后一次循环，不在执行callback</span><br>            <span class="hljs-keyword">if</span>((i + <span class="hljs-number">1</span>) === originArray.<span class="hljs-property">length</span>) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-comment">// 循环执行 `callback`</span><br>            <span class="hljs-comment">// 这里判断一下`currentValue`</span><br>            <span class="hljs-comment">// 因为有初始值时，`currentValue`是`originArray[i]`</span><br>            <span class="hljs-comment">// 没有初始值时`currentValue`是`originArray[i + 1]`</span><br>            accumulator = <span class="hljs-title function_">callback</span>(accumulator, initValue === <span class="hljs-literal">undefined</span> ? originArray[i + <span class="hljs-number">1</span>] : originArray[i], i, originArray);<br>        &#125;<br><br>        <span class="hljs-comment">// 把累计器返回出去</span><br>        <span class="hljs-keyword">return</span> accumulator<br>&#125;<br></code></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 找出最大值</span><br><span class="hljs-keyword">const</span> r = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>].<span class="hljs-title function_">selfReduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(a, b))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r) <span class="hljs-comment">// 输出： 8</span><br><br><span class="hljs-comment">// 数组元素求和</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> initVal = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> total = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur, index, array</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(acc, cur);<br>        <span class="hljs-comment">// 0 1</span><br>        <span class="hljs-comment">// 1 2</span><br>        <span class="hljs-comment">// 3 3</span><br>        <span class="hljs-comment">// 6 4</span><br>        <span class="hljs-keyword">return</span> acc + cur;<br>&#125;, initVal);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total); <span class="hljs-comment">// 输出：10</span><br></code></pre></td></tr></table></figure><p>至此，就基本实现了<code>reduce</code>的功能；</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>面试过程中，经常会被问到一些手写实现原生api的问题；如果真的问到了，也不用特别紧张，其实只要梳理一下思路的话，没有那么难的；如果是函数的话，就要从函数的参数、返回值开始分析，一步一步的去实现，基本是没什么问题的。</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题常问1</title>
    <link href="/blog/2022/09/08/interview-20220908/"/>
    <url>/blog/2022/09/08/interview-20220908/</url>
    
    <content type="html"><![CDATA[<h1 id="20220908前端面试题"><a href="#20220908前端面试题" class="headerlink" title="20220908前端面试题"></a>20220908前端面试题</h1><p><strong>中国电信集成</strong></p><ul><li>vue生命周期</li><li>webpack打包机制</li><li>v-if v-show</li><li>如何实现一个深拷贝</li><li>敏捷开发的思维模式</li></ul><p><strong>牧原股份一面</strong></p><ul><li>讲一下react hooks内部实现原理</li><li>微前端中微任务注入权限如何控制</li><li>讲一下宏任务和微任务</li><li>讲一下为什么用微前端，qiankun的特性是什么，有没有看过single-spa的内部实现方式</li><li>需要去南阳出差，接受吗</li></ul><p><strong>数字郑州一面</strong></p><ul><li>浏览器协商缓存</li><li>事件循环 宏任务 微任务（没回答好）</li><li>react父子组件如何通信，redux通信机制</li><li>父组件如何调用子组件方法</li><li>react生命周期</li><li>antd from表单自定义组件</li><li>webpack打包原理</li><li>webpack 如何分包</li><li>webpack load plugin区别</li><li>输入URL回车发生了啥（从发送http开始说）</li><li>受控组件和非受控组件</li><li>为什么要使用微前端</li><li>react context</li><li>ES6+用过哪些特性</li><li>如何解决跨域问题（只讲项目中用到的，cors原理及如何配置）</li><li>promise能取消吗</li><li>如何解决移动端适配问题，rem和vw有啥区别</li><li>能接受加班吗，有没有遇到压力特别大的时候</li></ul><p><strong>数字郑州二面</strong></p><ul><li>如何实现一个forEach，forEach单词循环返回的是个什么</li><li>如何使用react hooks实现之前的生命周期</li><li>如何实现一个ajaix，讲下原理</li><li>promise内部是如何实现的，geneor函数内部是如何实现的，如何通过gene实现一个async await方法</li><li>讲讲你都加班和出差的看法</li><li>vue3 有哪些特性</li><li>讲一下redux的数据运转及原理，讲一下你对redux使用场景的看法</li><li>css实现动画vs js来实现动画</li><li>讲一下如何实现前端自动化</li><li>使用过docker部署吗</li></ul><p><strong>uu跑腿共四面</strong></p><ul><li>es6有哪些特性</li><li>前端打包工具vite</li><li>高阶组件平时使用过没</li><li>redux 原则， connect</li><li>深浅拷贝 如何实现一个深拷贝</li><li>从拿到一个大型项目开始，如何做优化</li><li>有没有做过大屏项目</li><li>有没有做过可视化拖拽生成页面，可以简单讲下实现流程</li><li>redux 三大原则</li><li>如何解决跨域问题</li></ul><p><strong>鸿翼股份一面</strong></p><ul><li>css 伪类 伪元素</li><li>html行内元素和块级元素</li><li>什么是外边距合并，如何解决</li><li>react hooks 相对于class组件的优势</li><li>如何实现一个闭包</li><li>讲一讲js 垃圾回收机制，如何回收</li></ul><p><strong>鸿翼股份二面</strong></p><ul><li>webpack如何优化包体积</li><li>webpack 如何优化构建时间</li><li>平时你是怎么学习和进步的，遇到不会的问题怎么办</li><li>高阶组件的使用场景</li><li>你未来的发展方向是什么</li><li>拿到一个项目除了webpack外，如何做代码层面的优化</li><li>react 实现异步加载组件的方式有哪些</li></ul><p><strong>字节跳动一面</strong></p><ul><li>手写代码 实现一个react memo效果，react.meno第二个参数是什么</li><li>pureComponent</li><li>手写代码实现一个有状态的倒计时</li><li>浏览器强缓存，cacle-control 有哪些字段 浏览器缓存原理</li><li>微信原生小程序性能指标</li><li>有没有看过qiankun的底层原理</li><li>webpack5缓存有哪几种方式</li><li>强缓存和协商缓存的状态码是多少</li><li>HTTP2.0相当于1.X有哪些优势</li><li>webpack 是利用什么机制分包的</li><li>webpack5 模块联邦简单介绍下如何实现</li></ul><p><strong>字节跳动二面</strong></p><ul><li>自定义一个hooks</li><li>实现一个节流函数（然后改成hoos的写法）</li><li>实现一个快排</li><li>说说你期望的前端发展方向</li></ul><p><strong>中软国际(电信公司)</strong></p><ul><li>webpack dllPlugin 具体如何做配置的</li><li>react class和hooks 分别是如何实现生命周期的</li><li>纯函数组件的好处</li><li>高阶组件</li><li>react 项目如何做代码优化</li><li>load和plugin有什么区别，常用的load和plugin有哪些</li><li>一个页面的按钮权限如何控制（假如给你一个整个项目的按钮权限数据）</li></ul><p><strong>XX一面（过了）</strong></p><ul><li>宏任务微任务</li><li>为什么会有跨域问题，如果接口有跨域问题，那接口到服务端了吗</li><li>解释一下BFC。BFC脱离文档流没</li><li>commonjs的模块导入导出和ES6的导入导出有什么区别</li><li>flex用过没</li><li>如何解决移动端适配问题</li><li>一个div内嵌一个div margin-top30，2个div相差多少</li><li>CORS2个请求有什么区别，能否合并成一个</li><li>HTTP1.0和HTTP1.1有什么区别</li><li>[‘fldffd’,’flrtoss’,’flodofs’] 求最长相同字符前缀</li><li>forEach如何跳出循环</li><li>你对自己的未来规划是什么</li></ul><p><strong>XX二面（过了）</strong></p><ul><li>之前遇到最大的困惑和挑战是什么</li><li>如何做移动端适配</li><li>如何做页面性能优化</li><li>如何保证一个项目从开发到上线没有bug，讲讲你的思路</li><li>webpack如何优化包体积和构建速度</li></ul><p><strong>XX三面（过了）</strong></p><ul><li>做微前端之前是如何考虑的，利用微前端能解决什么痛点，前期做了哪些调研</li><li>qiankun配置微应用入口后，entry是如何实现应用的路由的</li><li>jsx为什么能在js里写html代码，最后是怎么处理和编译的</li><li>webpack的编译和浏览器的编译主要做了哪些事情</li><li>vue中 html中可以写指令，如v-model,请问是如何实现的</li><li>vue中双向数据绑定是如何实现的</li><li>react中 状态的更新是如何触发视图渲染的</li><li>一个项目做性能优化前，是做如何考虑的，做性能优化有哪些指标能参考，拿到一个项目后，是如何做性能优化的</li></ul><p><strong>开源中国一面</strong></p><ul><li>less sass平时使用过没，有哪些特性</li><li>nodejs用过哪些东西</li><li>讲一下栅格布局和flex布局</li><li>如何实现一个换肤功能；（2个不同的css文件）</li><li>如何实现一个导航栏的显示隐藏（根据分辨率）</li><li>如何实现一个导航栏变窄</li><li>class super是干嘛的</li><li>class方法和纯函数有什么不一样</li><li>ts数据类型用过哪些</li><li>ts @符合的使用，angular中@是用来实现个什么东西的</li><li>ts中的一些没听过的知识点（记不起来了）</li><li>react forwardRef用过没</li><li>react hooks 如何实现组件销毁</li><li>vue熟悉吗</li><li>HTTP缓存是如何处理的（服务器或者ng是如何返回缓存字段的）</li><li>三方npm资源链接复用，你们公司一般都放在哪里</li><li>说说复杂数据类型，function是复杂数据类型吗，如何判定复杂数据类型的类型</li><li>项目打包从200M优化到120M这之间做了哪些事情</li></ul><p><strong>开源二面</strong></p><ul><li>CDN如何做配置，浏览器缓存及CDN缓存策略，CDN基本概念，CDN对应的服务器宕机了，前端快速让页面能正常打开</li><li>移动端适配原理和方案，flex布局和栅格系统</li><li>redux是干嘛的，是否是必须的</li><li>抛开三方插件，如何实现跨页面通信，缓存有I&#x2F;O，有没有其他方案，react context之类</li><li>在做性能优化之前，是基于什么做考虑的，为什么需要做性能优化</li><li>如何从代码层面做性能优化，讲讲你的思路</li><li>一般项目从开发到上线，你认为需要具备几个环境才是合理的</li><li>git merge 和 git rebase有什么区别</li><li>用react实现一个slect下拉组件，从简单到负责，通过对props、状态、事件并运用组件化的思想讲一下你的思路</li><li>ts平时都使用过，在项目中你认为ts的定位是什么</li></ul>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript对象数组去重</title>
    <link href="/blog/2022/08/08/js-ArrayDeleteRepetition/"/>
    <url>/blog/2022/08/08/js-ArrayDeleteRepetition/</url>
    
    <content type="html"><![CDATA[<h1 id="javascript-对象数组去重"><a href="#javascript-对象数组去重" class="headerlink" title="javascript 对象数组去重"></a>javascript 对象数组去重</h1><h3 id="1-使用set和map结合"><a href="#1-使用set和map结合" class="headerlink" title="1.使用set和map结合"></a>1.使用set和map结合</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> jsonArray = [  <br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;,  <br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mary&#x27;</span> &#125;,  <br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span> &#125;,  <br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;,  <br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mary&#x27;</span> &#125;,  <br>];  <br>  <br><span class="hljs-keyword">let</span> uniqueArray = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(jsonArray.<span class="hljs-title function_">map</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-property">stringify</span>))].<span class="hljs-title function_">map</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-property">parse</span>);  <br>  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueArray);<br></code></pre></td></tr></table></figure><p>​首先，使用<code>Array.prototype.map</code>和<code>JSON.stringify</code>将数组中的每个对象转换为字符串。<br>​然后，我们使用<code>Set</code>对象去除重复的字符串。<br>​最后，我们使用<code>Array.prototype.map</code>和<code>JSON.parse</code>将结果转换回对象数组</p><h3 id="2-双重for循环"><a href="#2-双重for循环" class="headerlink" title="2.双重for循环"></a>2.双重for循环</h3><h4 id="i-对比id属性"><a href="#i-对比id属性" class="headerlink" title="i.对比id属性"></a>i.对比id属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kuye&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;gucheng&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kuye&#x27;</span>&#125;<br>]<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i].<span class="hljs-property">id</span> === arr[j].<span class="hljs-property">id</span>) &#123;<br>            arr.<span class="hljs-title function_">splice</span>(j, <span class="hljs-number">1</span>)<br>            j--<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;arr--&#x27;</span>, arr)<br></code></pre></td></tr></table></figure><h4 id="ii-使用JSON-stringify转字符串，在对比"><a href="#ii-使用JSON-stringify转字符串，在对比" class="headerlink" title="ii.使用JSON.stringify转字符串，在对比"></a>ii.使用JSON.stringify转字符串，在对比</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> jsonArray = [  <br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;,  <br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mary&#x27;</span> &#125;,  <br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span> &#125;,  <br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;,  <br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Mary&#x27;</span> &#125;,  <br>];  <br>  <br><span class="hljs-keyword">let</span> uniqueArray = [];  <br>  <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; jsonArray.<span class="hljs-property">length</span>; i++) &#123;  <br>  <span class="hljs-keyword">let</span> isDuplicate = <span class="hljs-literal">false</span>;  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; uniqueArray.<span class="hljs-property">length</span>; j++) &#123;  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(jsonArray[i]) === <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(uniqueArray[j])) &#123;  <br>      isDuplicate = <span class="hljs-literal">true</span>;  <br>      <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>  &#125;  <br>  <span class="hljs-keyword">if</span> (!isDuplicate) &#123;  <br>    uniqueArray.<span class="hljs-title function_">push</span>(jsonArray[i]);  <br>  &#125;  <br>&#125;  <br>  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueArray);<br></code></pre></td></tr></table></figure><p>​使用两个嵌套的 for 循环。外部循环遍历原始数组，内部循环遍历新数组。如果原始数组中的当前元素与新数组中的任何元素相同，那么我们将 <code>isDuplicate</code> 设置为 <code>true</code> 并跳出内部循环。如果 <code>isDuplicate</code> 为 <code>false</code>，则我们将当前元素添加到新数组中。最后，新数组将只包含没有重复的数据。</p><h3 id="3-forEach搭配findindex"><a href="#3-forEach搭配findindex" class="headerlink" title="3.forEach搭配findindex"></a>3.forEach搭配findindex</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kuye&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;gucheng&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kuye&#x27;</span>&#125;<br>]<br><span class="hljs-keyword">let</span> newArr1 = []<br>arr1.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    arr1.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-property">id</span> == item.<span class="hljs-property">id</span>) == index &amp;&amp; newArr1.<span class="hljs-title function_">push</span>(item)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;newArr1&#x27;</span>, newArr1)<br></code></pre></td></tr></table></figure><p>找到遍历的数组中的第一个符合判断条件的值，并返回该值对应的索引，停止遍历</p><h3 id="4-filter搭配findIndex"><a href="#4-filter搭配findIndex" class="headerlink" title="4.filter搭配findIndex"></a>4.filter搭配findIndex</h3><p>作为一名优秀的程序员，只会两种去重方式怎么行，继续去粘，，，继续总结…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr2 = [<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kuye&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;gucheng&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kuye&#x27;</span>&#125;<br>]<br>arr2 = arr2.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> arr2.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-property">id</span> == item.<span class="hljs-property">id</span>) == index<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;arr3--&#x27;</span>, arr2)<br></code></pre></td></tr></table></figure><p>实现数组过滤。判断filter回调函数中的条件是否为true，如果为true，返回该遍历项，最终包装到一个数组中统一返回</p><h3 id="5-forEach搭配some"><a href="#5-forEach搭配some" class="headerlink" title="5.forEach搭配some"></a>5.forEach搭配some</h3><p>​在总结完上述三个方法之后，我就在想了：数组去重，如果这个数组是个基本数据类型的数组，我们只要遍历一层，循环体里面只要配合indexOf、includes等方法，就可以找出符合条件的值了，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;lsm&quot;</span>, <span class="hljs-string">&quot;52&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">81</span>, <span class="hljs-number">2</span>, <span class="hljs-number">81</span>]<br><span class="hljs-keyword">let</span> newArr = []<br>arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//!newArr.includes(item) &amp;&amp; newArr.push(item)</span><br>    newArr.<span class="hljs-title function_">indexOf</span>(arr1[i]) === -<span class="hljs-number">1</span> &amp;&amp; newArr.<span class="hljs-title function_">push</span>(arr1[i])<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;newArr--&#x27;</span>, newArr)<br></code></pre></td></tr></table></figure><p>​判断一个数组中有没有符合条件的值，只要数组中有一项符合条件返回true，但是不会终止循环，可以使用return终止循环（该例中并没用到该特性）</p><h3 id="6-filter和find"><a href="#6-filter和find" class="headerlink" title="6.filter和find"></a>6.filter和find</h3><p>​按照上面的总结，想进行引用类型数组去重，得进行双重for循环，内层循环要有一个具体的返回值。外层循环用来提供去重的对象，可以使用forEach，map等单纯提供遍历的方法，但是需要重新定义一个新的数组接收符合条件的对象。也可以使用filter，根据条件，直接返回一个新的数组，不需要重新定义一个新的数组，也不用进行push操作。和findIndex方法类似的还有find方法，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr4 = [<br>      &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kuye&#x27;</span>&#125;,<br>      &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;gucheng&#x27;</span>&#125;,<br>      &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kuye&#x27;</span>&#125;<br>    ]<br>    arr4 = arr4.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> arr4.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-property">id</span> == item.<span class="hljs-property">id</span>) === item<br>    &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;arr4&#x27;</span>, arr4)<br></code></pre></td></tr></table></figure><p>找出符合判断条件的第一项，并进行返回</p><h3 id="7-map结合some-find-findexIndex"><a href="#7-map结合some-find-findexIndex" class="headerlink" title="7.map结合some | find | findexIndex"></a>7.map结合some | find | findexIndex</h3><p><strong>最终总结：</strong></p><p><strong>1. 实现引用类型数组去重，主要靠双重循环。</strong></p><p><strong>2. 外层的循环可以是forEach、map这种方法，单纯的给内层循环提供去重对象。这要我们在最外面定义一个新的数组，用来存放符合条件的数组。也可以用filter方法，根据filter的特性返回符合条件的数组，不用自定义新数组。</strong></p><p><strong>3. 内层的函数实现去重，并且内层的函数要有一个有具体含义的返回值，用于外层函数的判断。可以是some，findIndex，find等。</strong></p><p>具体情况是不是与上述总结一直呢。我们最后使用map和some、find、findexIndex再来证明一遍</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr5 = [<br>  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kuye&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;gucheng&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kuye&#x27;</span>&#125;<br>]<br><span class="hljs-keyword">let</span> newArr5 = []<br>arr5.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// !newArr5.some(el =&gt; el.id == item.id) &amp;&amp; newArr5.push(item)</span><br>  <span class="hljs-comment">// arr5.findIndex(el =&gt; el.id === item.id) === index &amp;&amp; newArr5.push(item)</span><br>  arr5.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-property">id</span> === item.<span class="hljs-property">id</span>) === item &amp;&amp; newArr5.<span class="hljs-title function_">push</span>(item)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;arr5&#x27;</span>, newArr5)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>去重</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript-基础</title>
    <link href="/blog/2022/07/12/ts-basic/"/>
    <url>/blog/2022/07/12/ts-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-基础"><a href="#TypeScript-基础" class="headerlink" title="TypeScript-基础"></a>TypeScript-基础</h1><h2 id="1、常用类型"><a href="#1、常用类型" class="headerlink" title="1、常用类型"></a>1、常用类型</h2><h3 id="1-1-交叉类型"><a href="#1-1-交叉类型" class="headerlink" title="1.1 交叉类型"></a>1.1 交叉类型</h3><p>交叉类型就是通过 &amp; 符号，将多个类型合并为一个类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> T1 &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> T2 &#123;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-variable constant_">T2</span> &amp; <span class="hljs-variable constant_">T1</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-variable constant_">T3</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xm&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-联合类型"><a href="#1-2-联合类型" class="headerlink" title="1.2 联合类型"></a>1.2 联合类型</h3><p>联合类型就是通过 | 符号，表示一个值可以是几种类型之一。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="1-3-字面量类型"><a href="#1-3-字面量类型" class="headerlink" title="1.3 字面量类型"></a>1.3 字面量类型</h3><p>字面量类型就是使用一个字符串或数字或布尔类型作为变量的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 字符串</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">BtnType</span> =<span class="hljs-string">&#x27;default&#x27;</span>| <span class="hljs-string">&#x27;primary&#x27;</span>| <span class="hljs-string">&#x27;ghost&#x27;</span>| <span class="hljs-string">&#x27;dashed&#x27;</span>| <span class="hljs-string">&#x27;link&#x27;</span>| <span class="hljs-string">&#x27;text&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">btn</span>:<span class="hljs-title class_">BtnType</span>= <span class="hljs-string">&#x27;primary&#x27;</span><br><br><span class="hljs-comment">// 数字</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 布尔</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-literal">true</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="1-4-字符串模板类型"><a href="#1-4-字符串模板类型" class="headerlink" title="1.4 字符串模板类型"></a>1.4 字符串模板类型</h3><p>字符串模板类型就是通过 ES6 的模板字符串语法，对类型进行约束。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> https = <span class="hljs-string">`https://<span class="hljs-subst">$&#123;<span class="hljs-built_in">string</span>&#125;</span>`</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>:https = <span class="hljs-string">`https://www.baidu.com</span><br></code></pre></td></tr></table></figure><h2 id="2、运算符"><a href="#2、运算符" class="headerlink" title="2、运算符"></a>2、运算符</h2><h3 id="2-1-非空断言运算符"><a href="#2-1-非空断言运算符" class="headerlink" title="2.1 非空断言运算符"></a>2.1 非空断言运算符</h3><p>非空断言运算符 ! 用于强调元素是非 null 非 undefined，告诉 Typescript 该属性会被明确的赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 你可以使用类型断言将其指定为一个更具体的类型：</span><br><span class="hljs-keyword">const</span> myCanvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;main_canvas&quot;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLCanvasElement</span>;<br><br><span class="hljs-comment">// 也可以使用尖括号语法（注意不能在 .tsx 文件内使用），是等价的：</span><br><span class="hljs-keyword">const</span> myCanvas = &lt;<span class="hljs-title class_">HTMLCanvasElement</span>&gt;<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;main_canvas&quot;</span>);<br><br><br><span class="hljs-comment">// 当你明确的知道这个值不可能是 null 或者 undefined 时才使用 ! </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">liveDangerously</span>(<span class="hljs-params"><span class="hljs-attr">x</span>?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x!.<span class="hljs-title function_">toFixed</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-可选运算符"><a href="#2-2-可选运算符" class="headerlink" title="2.2 可选运算符"></a>2.2 可选运算符</h3><p>可选链运算符 ?. 用于判断左侧表达式的值是否是 null 或 undefined，如果是将停止表达式运行。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> name = <span class="hljs-built_in">object</span>?.<span class="hljs-property">name</span><br></code></pre></td></tr></table></figure><h3 id="2-3-空值合并运算符"><a href="#2-3-空值合并运算符" class="headerlink" title="2.3 空值合并运算符"></a>2.3 空值合并运算符</h3><p>空值合并运算符 ?? 用于判断左侧表达式的值是否是 null 或 undefined，如果不是返回右侧的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> a = b ?? <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="3、操作符"><a href="#3、操作符" class="headerlink" title="3、操作符"></a>3、操作符</h2><h3 id="3-1-keyof"><a href="#3-1-keyof" class="headerlink" title="3.1 keyof"></a>3.1 keyof</h3><p>keyof 用于获取某种类型的所有键，其返回值是联合类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>: keyof &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125; = <span class="hljs-string">&#x27;name&#x27;</span>   <span class="hljs-comment">//const person: &#x27;name&#x27; | &#x27;age&#x27; = &#x27;name&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-2-typeof"><a href="#3-2-typeof" class="headerlink" title="3.2 typeof"></a>3.2 typeof</h3><p>typeof 用于获取对象或者函数的结构类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> a2 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xm&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-keyword">typeof</span> a2 <span class="hljs-comment">// &#123; name: string &#125;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-keyword">typeof</span> fn1 <span class="hljs-comment">// (x: number) =&gt; number</span><br></code></pre></td></tr></table></figure><h3 id="3-3-in"><a href="#3-3-in" class="headerlink" title="3.3 in"></a>3.3 in</h3><p>in 用于遍历联合类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xm&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T5</span> = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof obj]: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123; name: string, age: string &#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="3-4-T-K"><a href="#3-4-T-K" class="headerlink" title="3.4 T[K]"></a>3.4 T[K]</h3><p>T[K] 用于访问索引，得到索引对应的值的联合类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> I3 &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T6</span> = <span class="hljs-variable constant_">I3</span>[keyof <span class="hljs-variable constant_">I3</span>] <span class="hljs-comment">// string | number</span><br></code></pre></td></tr></table></figure><h2 id="4、类型别名"><a href="#4、类型别名" class="headerlink" title="4、类型别名"></a>4、类型别名</h2><p>类型别名用来给一个类型起个新名字。类型别名常用于联合类型。这里需要注意的是我们仅仅是给类型取了一个新的名字，并不是创建了一个新的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Message</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">string</span>[]<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">greet</span> = (<span class="hljs-params"><span class="hljs-attr">message</span>: <span class="hljs-title class_">Message</span></span>) =&gt; &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、类型断言"><a href="#5、类型断言" class="headerlink" title="5、类型断言"></a>5、类型断言</h2><p>类型断言就是告诉浏览器我非常确定的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 尖括号 语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// as 语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h2 id="6、类型缩小"><a href="#6、类型缩小" class="headerlink" title="6、类型缩小"></a>6、类型缩小</h2><p>我们可以通过某些操作将变量的类型由一个较为宽泛的集合缩小到相对较小、较明确的集合</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"><span class="hljs-attr">anything</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) =&gt; &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> anything === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>     <span class="hljs-keyword">return</span> anything; <span class="hljs-comment">// 类型是 string </span><br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">return</span> anything; <span class="hljs-comment">// 类型是 number</span><br>   &#125;<br> &#125;;<br></code></pre></td></tr></table></figure><h2 id="7、泛型"><a href="#7、泛型" class="headerlink" title="7、泛型"></a>7、泛型</h2><p>泛型就是通过给类型传参，得到一个更加通用的类型，就像给函数传参一样。 如下我们得到一个通用的泛型类型 T1，通过传参，可以得到 T2 类型 string[]、T3 类型 number[]； T 是变量，我们可以用任意其他变量名代替他。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span>&lt;T&gt; = T[]<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-variable constant_">T1</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-comment">// string[]</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-variable constant_">T1</span>&lt;<span class="hljs-built_in">number</span>&gt; <span class="hljs-comment">// number[]</span><br></code></pre></td></tr></table></figure><h3 id="7-1-常见泛型定义"><a href="#7-1-常见泛型定义" class="headerlink" title="7.1 常见泛型定义"></a>7.1 常见泛型定义</h3><ul><li>T：表示第一个参数</li><li>K： 表示对象的键类型</li><li>V：表示对象的值类型</li><li>E：表示元素类型</li></ul><h3 id="7-2-泛型接口"><a href="#7-2-泛型接口" class="headerlink" title="7.2 泛型接口"></a>7.2 泛型接口</h3><p>泛型接口和上述示例类似，为接口类型传参：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> I1&lt;T, U&gt; &#123;<br>  <span class="hljs-attr">name</span>: T;<br>  <span class="hljs-attr">age</span>: U;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">I2</span> = <span class="hljs-variable constant_">I1</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="7-3-泛型约束"><a href="#7-3-泛型约束" class="headerlink" title="7.3 泛型约束"></a>7.3 泛型约束</h3><p>Typescript 通过 extends 实现类型约束。让传入值满足特定条件；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IWithLength</span> &#123;<br>  <span class="hljs-attr">length</span>:<span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">function</span> echoWithLength&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IWithLength</span>&gt;(<span class="hljs-attr">arg</span>:T):T&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>)<br>  <span class="hljs-keyword">return</span> arg<br>&#125;<br><br><span class="hljs-title function_">echoWithLength</span>(<span class="hljs-string">&#x27;str&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通过 extends 约束了 K 必须是 T 的 key。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> getProperty&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K): T[K] &#123;<br>    <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br><br><span class="hljs-keyword">let</span> tsInfo = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Typescript&quot;</span>,<br>    <span class="hljs-attr">supersetOf</span>: <span class="hljs-string">&quot;Javascript&quot;</span>,<br>    <span class="hljs-attr">difficulty</span>: <span class="hljs-title class_">Difficulty</span>.<span class="hljs-property">Intermediate</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">difficulty</span>: <span class="hljs-title class_">Difficulty</span> =<br>    <span class="hljs-title function_">getProperty</span>(tsInfo, <span class="hljs-string">&#x27;difficulty&#x27;</span>); <span class="hljs-comment">// OK</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">supersetOf</span>: <span class="hljs-built_in">string</span> =<br>    <span class="hljs-title function_">getProperty</span>(tsInfo, <span class="hljs-string">&#x27;superset_of&#x27;</span>); <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><h3 id="7-4-泛型参数默认值"><a href="#7-4-泛型参数默认值" class="headerlink" title="7.4 泛型参数默认值"></a>7.4 泛型参数默认值</h3><p>泛型参数默认值，和函数参数默认值一样，在没有传参时，给定默认值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> I4&lt;T = <span class="hljs-built_in">string</span>&gt; &#123;<br>  <span class="hljs-attr">name</span>: T;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">S1</span>: <span class="hljs-variable constant_">I4</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;123&#x27;</span> &#125; <span class="hljs-comment">// 默认 name: string类型</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">S2</span>: <span class="hljs-variable constant_">I4</span>&lt;<span class="hljs-built_in">number</span>&gt; = &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">123</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="7-5-泛型工具类型"><a href="#7-5-泛型工具类型" class="headerlink" title="7.5 泛型工具类型"></a>7.5 泛型工具类型</h3><h4 id="7-5-1-typeof"><a href="#7-5-1-typeof" class="headerlink" title="7.5.1 typeof"></a>7.5.1 typeof</h4><p>typeof 的主要用途是在类型上下文中获取变量或者属性的类型；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">sem</span>: <span class="hljs-title class_">Person</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;semlinker&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Sem</span> = <span class="hljs-keyword">typeof</span> sem; <span class="hljs-comment">// type Sem = Person</span><br><br><span class="hljs-comment">// 使用Sem类型</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">lolo</span>: <span class="hljs-title class_">Sem</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lolo&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">5</span> &#125; <br></code></pre></td></tr></table></figure><h4 id="7-5-2-keyof"><a href="#7-5-2-keyof" class="headerlink" title="7.5.2 keyof"></a>7.5.2 keyof</h4><p>keyof 可以用于获取某种类型的所有键，其返回类型是联合类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K1</span> = keyof <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// &quot;name&quot; | &quot;age&quot;</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K2</span> = keyof <span class="hljs-title class_">Person</span>[]; <span class="hljs-comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot; </span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K3</span> = keyof &#123; [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Person</span> &#125;;  <span class="hljs-comment">// string | number</span><br></code></pre></td></tr></table></figure><h4 id="7-5-3-映射类型"><a href="#7-5-3-映射类型" class="headerlink" title="7.5.3 映射类型"></a>7.5.3 映射类型</h4><p>映射类型，它是一种泛型类型，可用于把原有的对象类型映射成新的对象类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestInterface</span>&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-comment">// 我们可以通过+/-来指定添加还是删除</span><br><span class="hljs-comment">// 把上面定义的接口里面的属性全部变成可选</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionalTestInterface</span>&lt;T&gt; = &#123;<br>  [p <span class="hljs-keyword">in</span> keyof T]+?:T[p]<br>&#125;<br><br><span class="hljs-comment">// 再加上只读</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">OptionalTestInterface</span>&lt;T&gt; = &#123;<br>  +<span class="hljs-keyword">readonly</span> [p <span class="hljs-keyword">in</span> keyof T]+?:T[p]<br>&#125;<br><br><br><br><span class="hljs-keyword">type</span> newTestInterface = <span class="hljs-title class_">OptionalTestInterface</span>&lt;<span class="hljs-title class_">TestInterface</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="7-5-4-Partial"><a href="#7-5-4-Partial" class="headerlink" title="7.5.4 Partial"></a>7.5.4 Partial</h4><p>Partial 将类型的属性变成可选</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]?: T[P]<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Partial</span>&lt;&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>&#125;&gt;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-variable constant_">T1</span> = &#123;&#125; <span class="hljs-comment">// 没有name属性也不会报错</span><br></code></pre></td></tr></table></figure><h4 id="7-5-5-Required"><a href="#7-5-5-Required" class="headerlink" title="7.5.5 Required"></a>7.5.5 Required</h4><p>Required 将泛型的所有属性变为必选。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 语法-?，是把?可选属性减去的意思</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Required</span>&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]-?: T[P]<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Required</span>&lt;&#123;<br>  <span class="hljs-attr">name</span>?: <span class="hljs-built_in">string</span>,<br>&#125;&gt;<br><br><span class="hljs-comment">// ts报错，类型 &quot;&#123;&#125;&quot; 中缺少属性 &quot;name&quot;，但类型 &quot;Required&lt;&#123; name?: string | undefined; &#125;&gt;&quot; 中需要该属性。ts(2741)</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>: <span class="hljs-variable constant_">T2</span> = &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="7-5-6-Readonly"><a href="#7-5-6-Readonly" class="headerlink" title="7.5.6 Readonly"></a>7.5.6 Readonly</h4><p>Readonly 将泛型的所有属性变为只读。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">Readonly</span>&lt;&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>&#125;&gt;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">c</span>: <span class="hljs-variable constant_">T3</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tj&#x27;</span>,<br>&#125;<br><br>c.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;tj1&#x27;</span> <span class="hljs-comment">// ts 报错，无法分配到 &quot;name&quot; ，因为它是只读属性。ts(2540)</span><br></code></pre></td></tr></table></figure><h4 id="7-5-7-Pick"><a href="#7-5-7-Pick" class="headerlink" title="7.5.7 Pick"></a>7.5.7 Pick</h4><p>Pick 从类型中选择一下属性，生成一个新类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 例子一</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Pick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> K]: T[P]<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = <span class="hljs-title class_">Pick</span>&lt;<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>,<br>  &#125;,<br>  <span class="hljs-string">&#x27;name&#x27;</span><br>&gt;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这是一个新类型，T4=&#123;name: string&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">d</span>: <span class="hljs-variable constant_">T4</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tj&#x27;</span>,<br>&#125;<br><br><span class="hljs-comment">// 例子二</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">completed</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoPreview</span> = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">Todo</span>, <span class="hljs-string">&quot;title&quot;</span> | <span class="hljs-string">&quot;completed&quot;</span>&gt;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">todo</span>: <span class="hljs-title class_">TodoPreview</span> = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Clean room&quot;</span>,<br>  <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="7-5-8-Record"><a href="#7-5-8-Record" class="headerlink" title="7.5.8 Record"></a>7.5.8 Record</h4><p>Record 将 key 和 value 转化为 T 类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 例子一</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Record</span>&lt;K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>, T&gt; = &#123;<br>  [key <span class="hljs-keyword">in</span> K]: T<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">e</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tj&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">f</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt; = &#123;<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">11</span>,<br>&#125;<br><br><br><span class="hljs-comment">// 例子二</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageInfo</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Page</span> = <span class="hljs-string">&quot;home&quot;</span> | <span class="hljs-string">&quot;about&quot;</span> | <span class="hljs-string">&quot;contact&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">x</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">Page</span>, <span class="hljs-title class_">PageInfo</span>&gt; = &#123;<br>  <span class="hljs-attr">about</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;about&quot;</span> &#125;,<br>  <span class="hljs-attr">contact</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;contact&quot;</span> &#125;,<br>  <span class="hljs-attr">home</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;home&quot;</span> &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="7-5-9-Exclude"><a href="#7-5-9-Exclude" class="headerlink" title="7.5.9 Exclude"></a>7.5.9 Exclude</h4><p>Exclude 将某个类型中属于另一个的类型移除掉。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Exclude</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? <span class="hljs-built_in">never</span> : T;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>&gt;; <span class="hljs-comment">// &quot;b&quot; | &quot;c&quot;</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span>&gt;; <span class="hljs-comment">// &quot;c&quot;</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>), <span class="hljs-title class_">Function</span>&gt;; <span class="hljs-comment">// string | number</span><br></code></pre></td></tr></table></figure><h4 id="7-5-10-Extract"><a href="#7-5-10-Extract" class="headerlink" title="7.5.10 Extract"></a>7.5.10 Extract</h4><p>Extract 从 T 中提取出 U。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Extract</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? T : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;f&quot;</span>&gt;; <span class="hljs-comment">// &quot;a&quot;</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>), <span class="hljs-title class_">Function</span>&gt;; <span class="hljs-comment">// () =&gt;void</span><br></code></pre></td></tr></table></figure><h4 id="7-5-11-Omit"><a href="#7-5-11-Omit" class="headerlink" title="7.5.11 Omit"></a>7.5.11 Omit</h4><p>Omit 使用 T 类型中除了 K 类型的所有属性，来构造一个新的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Omit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>&gt; = <span class="hljs-title class_">Pick</span>&lt;T, <span class="hljs-title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Todo</span> &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">completed</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">TodoPreview</span> = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">Todo</span>, <span class="hljs-string">&quot;description&quot;</span>&gt;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  title: string;</span><br><span class="hljs-comment">  completed: boolean;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="8、类型别名与接口区别"><a href="#8、类型别名与接口区别" class="headerlink" title="8、类型别名与接口区别"></a>8、类型别名与接口区别</h2><h3 id="8-1-定义"><a href="#8-1-定义" class="headerlink" title="8.1 定义"></a>8.1 定义</h3><p>接口：接口的作用就是为这些类型命名和为你的代码或第三方代码定义数据模型。</p><p>类型别名：type(类型别名)会给一个类型起个新名字。</p><p>type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型。</p><h3 id="8-2-Objects-Functions"><a href="#8-2-Objects-Functions" class="headerlink" title="8.2 Objects &#x2F; Functions"></a>8.2 Objects &#x2F; Functions</h3><p>两者都可以用来描述对象或函数的类型，但是语法不同。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// interface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetPoint</span> &#123;<br>  (<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-comment">// type</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">SetPoint</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br></code></pre></td></tr></table></figure><h3 id="8-3-type定义其他类型"><a href="#8-3-type定义其他类型" class="headerlink" title="8.3 type定义其他类型"></a>8.3 type定义其他类型</h3><p>与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// primitive</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Name</span> = <span class="hljs-built_in">string</span>;<br><br><span class="hljs-comment">// object</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointX</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPointY</span> = &#123; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; &#125;;<br><br><span class="hljs-comment">// union</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PartialPoint</span> = <span class="hljs-title class_">PartialPointX</span> | <span class="hljs-title class_">PartialPointY</span>;<br><br><span class="hljs-comment">// tuple</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Data</span> = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>];<br><br><span class="hljs-comment">// dom</span><br><span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">type</span> B = <span class="hljs-keyword">typeof</span> div;<br></code></pre></td></tr></table></figure><h3 id="8-4-接口可以定义多次-类型别名不可以"><a href="#8-4-接口可以定义多次-类型别名不可以" class="headerlink" title="8.4 接口可以定义多次,类型别名不可以"></a>8.4 接口可以定义多次,类型别名不可以</h3><p>与类型别名不同，接口可以定义多次，会被自动合并为单个接口。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123; <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; &#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> &#123; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>; &#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span> = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br></code></pre></td></tr></table></figure><h3 id="8-5-扩展"><a href="#8-5-扩展" class="headerlink" title="8.5 扩展"></a>8.5 扩展</h3><p>两者都可以扩展，接口通过 extends 来实现。类型别名的扩展就是交叉类型，通过 &amp; 来实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 接口扩展接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-comment">// 类型别名扩展类型别名</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PointX</span> = &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PointX</span> &amp; &#123;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-comment">// 接口扩展类型别名</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PointX</span> = &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-comment">// 类型别名扩展接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PointX</span> &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = <span class="hljs-title class_">PointX</span> &amp; &#123;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts-basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue混入mixin</title>
    <link href="/blog/2022/07/08/vue-mixin/"/>
    <url>/blog/2022/07/08/vue-mixin/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue混入mixin"><a href="#Vue混入mixin" class="headerlink" title="Vue混入mixin"></a>Vue混入mixin</h1><h2 id="1、什么是混入"><a href="#1、什么是混入" class="headerlink" title="1、什么是混入"></a>1、什么是混入</h2><p><strong>Vue官方：</strong></p><blockquote><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p></blockquote><p><strong>自悟：</strong></p><blockquote><p>将组件的公共逻辑或者配置提取出来，哪个组件需要用到时，直接将提取的这部分混入到组件内部即可。这样既可以减少代码冗余度，也可以让后期维护起来更加容易</p></blockquote><p><strong>混入分为<code>全局混入</code>和<code>局部混入</code></strong></p><blockquote><p>局部混入和组件的按需加载有点类似，就是需要用到mixin中的代码时，我们再在组件章引入它。<br>全局混入的话，则代表我在项目的任何组件中都可以使用mixin。</p></blockquote><h2 id="2、实例"><a href="#2、实例" class="headerlink" title="2、实例"></a>2、实例</h2><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><p>在我们的项目src目录下新建mixin文件夹，然后新建index.js文件，该文件存放我们的mixin代码。</p><p><strong>代码如下：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/mixin/index.js</span><br><span class="hljs-comment">//可以看到我们的mixin非常的简单，主要包含了一个Vue组件的常见的逻辑结构</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mixins = &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;我是小猪课堂&quot;</span>,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">computed</span>: &#123;&#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是mixin中的created生命周期函数&quot;</span>);<br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是mixin中的mounted生命周期函数&quot;</span>);<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">clickMe</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是mixin中的点击事件&quot;</span>);<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-局部混入"><a href="#2-局部混入" class="headerlink" title="2.局部混入"></a>2.局部混入</h3><p>组件中引入mixin也非常简单，修改App.vue组件。</p><p><strong>代码如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">// src/App.vue<br>&lt;template&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;<br>    &lt;button @click=&quot;clickMe&quot;&gt;点击我&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; mixins &#125; from &quot;./mixin/index&quot;;<br>export default &#123;<br>  name: &quot;App&quot;,<br>  mixins: [mixins],<br>  components: &#123;&#125;,<br>  created()&#123;<br>    console.log(&quot;组件调用minxi数据&quot;,this.msg);<br>  &#125;,<br>  mounted()&#123;<br>    console.log(&quot;我是组件的mounted生命周期函数&quot;)<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="3-全局混入"><a href="#3-全局混入" class="headerlink" title="3.全局混入"></a>3.全局混入</h3><p>上一点我们使用mixin是在需要的组件中引入它，我们也可以在全局先把它注册好，这样我们就可以在任何组件中直接使用了。</p><p>修改main.js，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; mixins &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./mixin/index&quot;</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(mixins);<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;).$mount(<span class="hljs-string">&quot;#app&quot;</span>);<br></code></pre></td></tr></table></figure><p>然后把App.vue中引入mixin的代码注释掉，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;<br>    &lt;button @click=&quot;clickMe&quot;&gt;点击我&lt;/button&gt;<br>    &lt;button @click=&quot;changeMsg&quot;&gt;更改mixin数据&lt;/button&gt;<br>    &lt;demo&gt;&lt;/demo&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>// import &#123; mixins &#125; from &quot;./mixin/index&quot;;<br>import demo from &quot;./components/demo.vue&quot;;<br>export default &#123;<br>  name: &quot;App&quot;,<br>  // mixins: [mixins],<br>  components: &#123; demo &#125;,<br>  created() &#123;<br>    console.log(&quot;组件调用minxi数据&quot;, this.msg);<br>  &#125;,<br>  mounted() &#123;<br>    console.log(&quot;我是组件的mounted生命周期函数&quot;);<br>  &#125;,<br>  methods: &#123;<br>    changeMsg() &#123;<br>      this.msg = &quot;我是变异的小猪课堂&quot;;<br>      console.log(&quot;更改后的msg:&quot;, this.msg);<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>虽然这样做很方便，但是我们不推荐，来看看官方的一段话：</p><blockquote><p>请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为<a href="https://link.juejin.cn/?target=https://link.zhihu.com/?target=https://cn.vuejs.org/v2/guide/plugins.html">插件</a>发布，以避免重复应用混入。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mixin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue自定义指令</title>
    <link href="/blog/2022/07/08/vue-directive/"/>
    <url>/blog/2022/07/08/vue-directive/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue自定义指令"><a href="#Vue自定义指令" class="headerlink" title="Vue自定义指令"></a>Vue自定义指令</h1><h2 id="一、vue自定义指令API"><a href="#一、vue自定义指令API" class="headerlink" title="一、vue自定义指令API"></a>一、vue自定义指令API</h2><h3 id="1-钩子函数"><a href="#1-钩子函数" class="headerlink" title="1.钩子函数"></a>1.钩子函数</h3><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li><li><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</li><li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li></ul><h3 id="2-钩子函数参数"><a href="#2-钩子函数参数" class="headerlink" title="2.钩子函数参数"></a>2.钩子函数参数</h3><p>指令钩子函数会被传入以下参数：</p><ul><li><p><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM。</p></li><li><p>binding对象，包含以下 property：</p></li><li><p><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</p></li><li><p><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</p><ul><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li><li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li><li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li></ul></li><li><p><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a href="https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3">VNode API</a> 来了解更多详情。</p></li><li><p><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</p></li></ul><h2 id="二、自定义指令例子"><a href="#二、自定义指令例子" class="headerlink" title="二、自定义指令例子"></a>二、自定义指令例子</h2><h3 id="1-聚焦指令（v-focus）"><a href="#1-聚焦指令（v-focus）" class="headerlink" title="1.聚焦指令（v-focus）"></a>1.聚焦指令（v-focus）</h3><p>​除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子</p><p>​需求：当页面加载时，该元素将获得焦点，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。</p><p>现在让我们用指令来实现这个功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 注册一个全局自定义指令 `v-focus`</span><br><span class="hljs-comment">// 可以新建一个directive文件夹，里面放v-focus.js</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-comment">// 当被绑定的元素插入到 DOM 中时……</span><br>  <span class="hljs-attr">inserted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-comment">// 聚焦元素</span><br>    el.<span class="hljs-title function_">focus</span>()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//和method同级</span><br><span class="hljs-attr">directives</span>: &#123;<br>  <span class="hljs-attr">focus</span>: &#123;<br>    <span class="hljs-comment">// 指令的定义</span><br>    <span class="hljs-attr">inserted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>      el.<span class="hljs-title function_">focus</span>()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> property，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-focus</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-图片懒加载指令（v-LazyLoad）"><a href="#2-图片懒加载指令（v-LazyLoad）" class="headerlink" title="2.图片懒加载指令（v-LazyLoad）"></a>2.图片懒加载指令（v-LazyLoad）</h3><p>需求：实现一个图片懒加载指令，只加载浏览器可见区域的图片。</p><p>思路：</p><ol><li>图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的</li><li>拿到所有的图片 Dom ，遍历每个图片判断当前图片是否到了可视区范围内</li><li>如果到了就设置图片的 <code>src</code> 属性，否则显示默认图片</li></ol><p>图片懒加载有两种方式可以实现，一是绑定 <code>srcoll</code> 事件进行监听，二是使用 <code>IntersectionObserver</code> 判断图片是否到了可视区域，但是有浏览器兼容性问题。</p><p>下面封装一个懒加载指令兼容两种方法，判断浏览器是否支持 <code>IntersectionObserver</code> API，如果支持就使用 <code>IntersectionObserver</code> 实现懒加载，否则则使用 <code>srcoll</code> 事件监听 + 节流的方法实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">LazyLoad</span> = &#123;<br>  <span class="hljs-comment">// install方法</span><br>  <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue, options</span>) &#123;<br>    <span class="hljs-keyword">const</span> defaultSrc = options.<span class="hljs-property">default</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;lazy&#x27;</span>, &#123;<br>      <span class="hljs-title function_">bind</span>(<span class="hljs-params">el, binding</span>) &#123;<br>        <span class="hljs-title class_">LazyLoad</span>.<span class="hljs-title function_">init</span>(el, binding.<span class="hljs-property">value</span>, defaultSrc)<br>      &#125;,<br>      <span class="hljs-title function_">inserted</span>(<span class="hljs-params">el</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">IntersectionObserver</span>) &#123;<br>          <span class="hljs-title class_">LazyLoad</span>.<span class="hljs-title function_">observe</span>(el)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title class_">LazyLoad</span>.<span class="hljs-title function_">listenerScroll</span>(el)<br>        &#125;<br>      &#125;,<br>    &#125;)<br>  &#125;,<br>  <span class="hljs-comment">// 初始化</span><br>  <span class="hljs-title function_">init</span>(<span class="hljs-params">el, val, def</span>) &#123;<br>    el.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>, val)<br>    el.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>, def)<br>  &#125;,<br>  <span class="hljs-comment">// 利用IntersectionObserver监听el</span><br>  <span class="hljs-title function_">observe</span>(<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> realSrc = el.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span><br>      <span class="hljs-keyword">if</span> (entries[<span class="hljs-number">0</span>].<span class="hljs-property">isIntersecting</span>) &#123;<br>        <span class="hljs-keyword">if</span> (realSrc) &#123;<br>          el.<span class="hljs-property">src</span> = realSrc<br>          el.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>)<br>        &#125;<br>      &#125;<br>    &#125;)<br>    io.<span class="hljs-title function_">observe</span>(el)<br>  &#125;,<br>  <span class="hljs-comment">// 监听scroll事件</span><br>  <span class="hljs-title function_">listenerScroll</span>(<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">const</span> handler = <span class="hljs-title class_">LazyLoad</span>.<span class="hljs-title function_">throttle</span>(<span class="hljs-title class_">LazyLoad</span>.<span class="hljs-property">load</span>, <span class="hljs-number">300</span>)<br>    <span class="hljs-title class_">LazyLoad</span>.<span class="hljs-title function_">load</span>(el)<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">handler</span>(el)<br>    &#125;)<br>  &#125;,<br>  <span class="hljs-comment">// 加载真实图片</span><br>  <span class="hljs-title function_">load</span>(<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">const</span> windowHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span><br>    <span class="hljs-keyword">const</span> elTop = el.<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">top</span><br>    <span class="hljs-keyword">const</span> elBtm = el.<span class="hljs-title function_">getBoundingClientRect</span>().<span class="hljs-property">bottom</span><br>    <span class="hljs-keyword">const</span> realSrc = el.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span><br>    <span class="hljs-keyword">if</span> (elTop - windowHeight &lt; <span class="hljs-number">0</span> &amp;&amp; elBtm &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (realSrc) &#123;<br>        el.<span class="hljs-property">src</span> = realSrc<br>        el.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>)<br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 节流</span><br>  <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer<br>    <span class="hljs-keyword">let</span> prevTime<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>      <span class="hljs-keyword">const</span> currTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>      <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span><br>      <span class="hljs-keyword">if</span> (!prevTime) prevTime = currTime<br>      <span class="hljs-built_in">clearTimeout</span>(timer)<br><br>      <span class="hljs-keyword">if</span> (currTime - prevTime &gt; delay) &#123;<br>        prevTime = currTime<br>        fn.<span class="hljs-title function_">apply</span>(context, args)<br>        <span class="hljs-built_in">clearTimeout</span>(timer)<br>        <span class="hljs-keyword">return</span><br>      &#125;<br><br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        prevTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>        timer = <span class="hljs-literal">null</span><br>        fn.<span class="hljs-title function_">apply</span>(context, args)<br>      &#125;, delay)<br>    &#125;<br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">LazyLoad</span><br></code></pre></td></tr></table></figure><p>使用，将组件内  标签的 <code>src</code> 换成 <code>v-LazyLoad</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-LazyLoad</span>=<span class="hljs-string">&quot;xxx.jpg&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-权限验证（v-permission）"><a href="#3-权限验证（v-permission）" class="headerlink" title="3.权限验证（v-permission）"></a>3.权限验证（v-permission）</h3><p>需求：自定义一个权限指令，对需要权限判断的 Dom 进行显示隐藏。</p><p>思路：</p><ol><li>自定义一个权限数组</li><li>判断用户的权限是否在这个数组内，如果是则显示，否则则移除 Dom</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkArray</span>(<span class="hljs-params">key</span>) &#123;<br>  <span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;pro&#x27;</span>]<br>  <span class="hljs-keyword">let</span> index = arr.<span class="hljs-title function_">indexOf</span>(key)<br>  <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 有权限</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 无权限</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> permission = &#123;<br>  <span class="hljs-attr">inserted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding</span>) &#123;<br>    <span class="hljs-keyword">let</span> permission = binding.<span class="hljs-property">value</span> <span class="hljs-comment">// 获取到 v-permission的值</span><br>    <span class="hljs-keyword">if</span> (permission) &#123;<br>      <span class="hljs-keyword">let</span> hasPermission = <span class="hljs-title function_">checkArray</span>(permission)<br>      <span class="hljs-keyword">if</span> (!hasPermission) &#123;<br>        <span class="hljs-comment">// 没有权限 移除Dom元素</span><br>        el.<span class="hljs-property">parentNode</span> &amp;&amp; el.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(el)<br>      &#125;<br>    &#125;<br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> permission<br></code></pre></td></tr></table></figure><p>使用：给 <code>v-permission</code> 赋值判断即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btns&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 显示 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-permission</span>=<span class="hljs-string">&quot;&#x27;admin&#x27;&quot;</span>&gt;</span>新增<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 不显示 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-permission</span>=<span class="hljs-string">&quot;&#x27;person&#x27;&quot;</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自定义指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm run xxx 的时候发生了什么？</title>
    <link href="/blog/2022/07/08/js-npmRunTime/"/>
    <url>/blog/2022/07/08/js-npmRunTime/</url>
    
    <content type="html"><![CDATA[<h1 id="运行-npm-run-xxx-的时候发生了什么？"><a href="#运行-npm-run-xxx-的时候发生了什么？" class="headerlink" title="运行 npm run xxx 的时候发生了什么？"></a>运行 npm run xxx 的时候发生了什么？</h1><h3 id="1-npm-run-serve的时候，发生了什么？"><a href="#1-npm-run-serve的时候，发生了什么？" class="headerlink" title="1.npm run serve的时候，发生了什么？"></a>1.npm run serve的时候，发生了什么？</h3><p>​首先会去项目的package.json文件里找scripts 里找对应的xxx，然后执行 xxx的命令，例如启动vue项目 npm run serve的时候，实际上就是执行了vue-cli-service serve 这条命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;h5&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.7&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;private&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;serve&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vue-cli-service serve&quot;</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-为什么-不直接执行vue-cli-service-serve而要执行npm-run-serve-呢？"><a href="#2-为什么-不直接执行vue-cli-service-serve而要执行npm-run-serve-呢？" class="headerlink" title="2.为什么 不直接执行vue-cli-service serve而要执行npm run serve 呢？"></a>2.为什么 不直接执行<code>vue-cli-service serve</code>而要执行<code>npm run serve</code> 呢？</h3><p>​因为 直接执行<code>vue-cli-service serve</code>，会报错，因为操作系统中没有存在<code>vue-cli-service</code>这一条指令</p><h3 id="3-那既然vue-cli-service这条指令不存在操作系统中，为什么执行npm-run-serve的时候，也就是相当于执行了vue-cli-service-serve-，为什么这样它就能成功，而且不报指令不存在的错误呢？"><a href="#3-那既然vue-cli-service这条指令不存在操作系统中，为什么执行npm-run-serve的时候，也就是相当于执行了vue-cli-service-serve-，为什么这样它就能成功，而且不报指令不存在的错误呢？" class="headerlink" title="3.那既然vue-cli-service这条指令不存在操作系统中，为什么执行npm run serve的时候，也就是相当于执行了vue-cli-service serve ，为什么这样它就能成功，而且不报指令不存在的错误呢？"></a>3.那既然<code>vue-cli-service</code>这条指令不存在操作系统中，为什么执行<code>npm run serve</code>的时候，也就是相当于执行了<code>vue-cli-service serve</code> ，为什么这样它就能成功，而且不报指令不存在的错误呢？</h3><p>​我们在安装依赖的时候，是通过npm i xxx 来执行的，例如 <code>npm i @vue/cli-service</code>，npm 在 安装这个依赖的时候，就会<code>node_modules/.bin/</code> 目录中创建 好<code>vue-cli-service</code> 为名的几个可执行文件了。</p><p>​.bin 目录，这个目录不是任何一个 npm 包。目录下的文件，表示这是一个个软链接，打开文件可以看到文件顶部写着 <code>#!/bin/sh</code> ，表示这是一个脚本。</p><p>由此我们可以知道，当使用 <code>npm run serve</code> 执行 <code>vue-cli-service  serve</code> 时，虽然没有安装 <code>vue-cli-service</code>的全局命令，但是 npm 会到 <code>./node_modules/.bin</code> 中找到 <code>vue-cli-service</code> 文件作为  脚本来执行，则相当于执行了 <code>./node_modules/.bin/vue-cli-service serve</code>（最后的 serve 作为参数传入）</p><h3 id="4-bin-目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？它又是怎么知道这条软连接是执行哪里的呢？"><a href="#4-bin-目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？它又是怎么知道这条软连接是执行哪里的呢？" class="headerlink" title="4. .&#x2F;bin 目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？它又是怎么知道这条软连接是执行哪里的呢？"></a>4. .&#x2F;bin 目录下的文件表示软连接，那这个bin目录下的那些软连接文件是哪里来的呢？它又是怎么知道这条软连接是执行哪里的呢？</h3><p>​我们可以直接在新建的vue项目里面搜索vue-cli-service</p><p>可以看到，它存在项目最外层的<strong>package-lock.json</strong>文件中</p><p>从 package-lock.json 中可知，当我们npm i 整个新建的vue项目的时候，npm 将 bin&#x2F;vue-cli-service.js 作为 bin 声明了。</p><p>所以在 npm install 时，npm 读到该配置后，就将该文件软链接到 .&#x2F;node_modules&#x2F;.bin 目录下，而 npm 还会自动把node_modules&#x2F;.bin加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了。</p><p>假如我们在安装包时，使用 <code>npm install -g xxx</code> 来安装，那么会将其中的 bin 文件加入到全局，比如 create-react-app 和 vue-cli ，在全局安装后，就可以直接使用如 vue-cli projectName 这样的命令来创建项目了。</p><p>搜噶，也就是说，npm i 的时候，npm 就帮我们把这种软连接配置好了，其实这种软连接相当于一种映射，执行npm run xxx 的时候，就会到 node_modules&#x2F;bin中找对应的映射文件，然后再找到相应的js文件来执行。</p><h3 id="5-在node-modules-bin中-有三个vue-cli-service文件。为什么会有三个文件呢？"><a href="#5-在node-modules-bin中-有三个vue-cli-service文件。为什么会有三个文件呢？" class="headerlink" title="5.在node_modules&#x2F;bin中 有三个vue-cli-service文件。为什么会有三个文件呢？"></a>5.在node_modules&#x2F;bin中 有三个vue-cli-service文件。为什么会有三个文件呢？</h3><p>如果我们在 cmd 里运行的时候，windows 一般是调用了 <code>vue-cli-service.cmd</code>，这个文件，这是 windows 下的批处理脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">@ECHO off<br>GOTO start<br>:find_dp0<br>SET dp0=%~dp0<br>EXIT /b<br>:start<br>SETLOCAL<br>CALL :find_dp0<br><br>IF EXIST <span class="hljs-string">&quot;%dp0%\node.exe&quot;</span> (<br>  SET <span class="hljs-string">&quot;_prog=%dp0%\node.exe&quot;</span><br>) ELSE (<br>  SET <span class="hljs-string">&quot;_prog=node&quot;</span><br>  SET PATHEXT=%PATHEXT:;.JS;=;%<br>)<br><br>endLocal &amp; goto <span class="hljs-comment">#_undefined_# 2&gt;NUL || title %COMSPEC% &amp; &quot;%_prog%&quot;  &quot;%dp0%\..\@vue\cli-service\bin\vue-cli-service.js&quot; %*</span><br></code></pre></td></tr></table></figure><p>所以当我们运行<code>vue-cli-service serve</code>这条命令的时候，就相当于运行 <code>node_modules/.bin/vue-cli-service.cmd serve</code>。</p><p>然后这个脚本会使用 node 去运行<code> vue-cli-service.js</code>这个 js 文件</p><p>由于 node 中可以使用一系列系统相关的 api ，所以在这个 js 中可以做很多事情，例如读取并分析运行这条命令的目录下的文件，根据模板生成文件等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"># unix 系默认的可执行文件，必须输入完整文件名<br>vue-cli-service<br><br># windows cmd 中默认的可执行文件，当我们不添加后缀名时，自动根据 pathext 查找文件<br>vue-cli-service.<span class="hljs-property">cmd</span><br><br># <span class="hljs-title class_">Windows</span> <span class="hljs-title class_">PowerShell</span> 中可执行文件，可以跨平台<br>vue-cli-service.<span class="hljs-property">ps1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm run serve</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mock.js CRUD</title>
    <link href="/blog/2022/07/01/mock-crud/"/>
    <url>/blog/2022/07/01/mock-crud/</url>
    
    <content type="html"><![CDATA[<h1 id="mock-js注解实现增删改查CRUD"><a href="#mock-js注解实现增删改查CRUD" class="headerlink" title="mock.js注解实现增删改查CRUD"></a>mock.js注解实现增删改查CRUD</h1><p>注:CRUD即:增Create、查Retrive、删Delete、改Update</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// cdn引入文件 ：</span><br><span class="hljs-comment">// &lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1、创建一个对象"><a href="#1、创建一个对象" class="headerlink" title="1、创建一个对象"></a>1、创建一个对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr =  [<br>&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;fei&#x27;</span>,<br><span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br><span class="hljs-attr">id</span>: <span class="hljs-number">1</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;liang&#x27;</span>,<br><span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br><span class="hljs-attr">id</span>: <span class="hljs-number">2</span><br>&#125;<br>]<br></code></pre></td></tr></table></figure><p>​   </p><h3 id="2、删除元素"><a href="#2、删除元素" class="headerlink" title="2、删除元素"></a>2、删除元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Mock</span>.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&#x27;ip地址&#x27;</span>, <span class="hljs-string">&#x27;delete&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) &#123;<br><span class="hljs-keyword">var</span> id = <span class="hljs-built_in">parseInt</span>(options.<span class="hljs-property">body</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">1</span>]) <br><span class="hljs-keyword">var</span> index;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> arr) &#123;<br><span class="hljs-keyword">if</span> (arr[i].<span class="hljs-property">id</span> === id) &#123; <br>index = i<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>arr.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>) <br><span class="hljs-keyword">return</span> arr; <br>&#125;)<br><br>$.<span class="hljs-title function_">ajax</span>(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;ip地址&#x27;</span>,<br><span class="hljs-attr">type</span>: <span class="hljs-string">&quot;DELETE&quot;</span>,<br><span class="hljs-attr">data</span>: &#123;<br><span class="hljs-attr">id</span>: <span class="hljs-number">1</span> <br>&#125;,<br><span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br><span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="3、添加元素"><a href="#3、添加元素" class="headerlink" title="3、添加元素"></a>3、添加元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Mock</span>.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&#x27;ip地址&#x27;</span>, <span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) &#123;<br><span class="hljs-keyword">var</span> id = <span class="hljs-built_in">parseInt</span>(options.<span class="hljs-property">body</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">1</span>]) <br><span class="hljs-keyword">var</span> index;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> arr) &#123;<br><span class="hljs-keyword">if</span> (arr[i].<span class="hljs-property">id</span> === id) &#123; <br>index = i<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>arr.<span class="hljs-title function_">push</span>(index) <br><span class="hljs-keyword">return</span> arr; <br>&#125;)<br><br>$.<span class="hljs-title function_">ajax</span>(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;ip地址&#x27;</span>,<br><span class="hljs-attr">type</span>: <span class="hljs-string">&quot;push&quot;</span>,<br><span class="hljs-attr">data</span>: &#123;<br><span class="hljs-attr">id</span>: <span class="hljs-number">1</span> <br>&#125;,<br><span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br><span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="4、编辑元素"><a href="#4、编辑元素" class="headerlink" title="4、编辑元素"></a>4、编辑元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Mock</span>.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&#x27;ip地址&#x27;</span>, <span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) &#123;<br><span class="hljs-keyword">var</span> id = <span class="hljs-built_in">parseInt</span>(options.<span class="hljs-property">body</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> arr) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (arr[i].<span class="hljs-property">id</span> === id) &#123; <br>arr[i].<span class="hljs-property">name</span> = <span class="hljs-built_in">decodeURI</span>(options.<span class="hljs-property">body</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">2</span>])<br><span class="hljs-comment">// index = i</span><br><span class="hljs-comment">// break;</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> arr; <br>&#125;)<br><br>$.<span class="hljs-title function_">ajax</span>(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;ip地址&#x27;</span>,<br><span class="hljs-attr">type</span>: <span class="hljs-string">&quot;POST&quot;</span>,<br><span class="hljs-attr">data</span>: &#123;<br><span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <br><span class="hljs-attr">mane</span>: <span class="hljs-string">&#x27;qwe&#x27;</span><br>&#125;,<br><span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br><span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="5、查找元素"><a href="#5、查找元素" class="headerlink" title="5、查找元素"></a>5、查找元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Mock</span>.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&#x27;ip地址&#x27;</span>, <span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) &#123;<br><span class="hljs-keyword">var</span> id = <span class="hljs-built_in">parseInt</span>(options.<span class="hljs-property">body</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">1</span>]) <br><span class="hljs-keyword">var</span> findo = &#123;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> arr) &#123;<br><span class="hljs-keyword">if</span> (arr[i].<span class="hljs-property">id</span> === id) &#123;<br>    findo[i] = arr[i]<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> findo; <br>&#125;)<br><br>$.<span class="hljs-title function_">ajax</span>(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;ip地址&#x27;</span>,<br><span class="hljs-attr">type</span>: <span class="hljs-string">&quot;push&quot;</span>,<br><span class="hljs-attr">data</span>: &#123;<br><span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <br>&#125;,<br><span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br><span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mock</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mock-crud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mock.js语法</title>
    <link href="/blog/2022/07/01/mock-fastMock/"/>
    <url>/blog/2022/07/01/mock-fastMock/</url>
    
    <content type="html"><![CDATA[<h1 id="Mock-js语法"><a href="#Mock-js语法" class="headerlink" title="Mock.js语法"></a>Mock.js语法</h1><h3 id="1-基础随机内容的生成"><a href="#1-基础随机内容的生成" class="headerlink" title="1.基础随机内容的生成"></a>1.基础随机内容的生成</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;string|1-10&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;=&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 随机生成1到10个等号</span><br>  <span class="hljs-attr">&quot;string2|3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;=&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 随机生成2个或者三个等号</span><br>  <span class="hljs-attr">&quot;number|+1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 从0开始自增</span><br>  <span class="hljs-attr">&quot;number2|1-00.1-3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 生成一个小数，小数点前面1到10，小数点后1到3位</span><br>  <span class="hljs-attr">&quot;boolean&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@boolean( 1, 2, true )&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 生成boolean值 三个参数，1表示第三个参数true出现的概率，2表示false出现的概率</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@cname&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 随机生成中文姓名</span><br>  <span class="hljs-attr">&quot;firstname&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@cfirst&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 随机生成中文姓</span><br>  <span class="hljs-attr">&quot;int&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@integer(1, 10)&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 随机生成1-10的整数</span><br>  <span class="hljs-attr">&quot;float&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@float(1,2,3,4)&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 随机生成浮点数，四个参数分别为，整数部分的最大最小值和小数部分的最大最小值</span><br>  <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@range(1,100,10)&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 随机生成整数数组，三个参数为，最大最小值和加的步长</span><br>  <span class="hljs-attr">&quot;natural&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@natural(60, 100)&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 随机生成自然数（大于零的数）</span><br>  <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@email&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 邮箱</span><br>  <span class="hljs-attr">&quot;ip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@ip&quot;</span> <span class="hljs-punctuation">,</span><span class="hljs-comment">// ip</span><br>  <span class="hljs-attr">&quot;datatime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@date(&#x27;yy-MM-dd hh:mm:ss&#x27;)&quot;</span> <span class="hljs-comment">// 随机生成指定格式的时间</span><br>  <span class="hljs-comment">// ......</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-列表数据"><a href="#2-列表数据" class="headerlink" title="2.列表数据"></a>2.列表数据</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0000&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;pageNo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@integer(1, 100)&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalRecord&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@integer(100, 1000)&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pageSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;list|10&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;id|+1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@cword(10)&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@cword(20)&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;descript&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@csentence(20,50)&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@float(10,100,10,100)&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;desc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;成功&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-图片"><a href="#3-图片" class="headerlink" title="3.图片"></a>3.图片</h3><p>mockjs可以生成任意大小，任意颜色块，且用文字填充内容的图片，使我们不用到处找图片资源就能轻松实现图片的模拟展示</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0000&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;pageNo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@integer(1, 100)&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;totalRecord&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@integer(100, 1000)&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pageSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;list|10&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// 参数从左到右依次为，图片尺寸，背景色，前景色（及文字颜色）,图片格式，图片中间的填充文字内容</span><br>      <span class="hljs-attr">&quot;image&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@image(&#x27;200x100&#x27;, &#x27;#ffcc33&#x27;, &#x27;#FFF&#x27;, &#x27;png&#x27;, &#x27;Fast Mock&#x27;)&quot;</span> <br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;desc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;成功&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-fastMock的跟地址"><a href="#4-fastMock的跟地址" class="headerlink" title="4.fastMock的跟地址"></a>4.fastMock的跟地址</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//https://www.fastmock.site/mock/72e7ab90b2647c478924e7c328542c82/api</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mock</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fibonacci函数</title>
    <link href="/blog/2022/07/01/js-fibonacci/"/>
    <url>/blog/2022/07/01/js-fibonacci/</url>
    
    <content type="html"><![CDATA[<h1 id="js-记忆函数"><a href="#js-记忆函数" class="headerlink" title="js 记忆函数"></a>js 记忆函数</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>fibonacci<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> memoizer = <span class="hljs-keyword">function</span>(<span class="hljs-params">memo, fundamental</span>) &#123;    <span class="hljs-comment">//memo记忆数组和fundamental函数</span></span><br><span class="language-javascript">            <span class="hljs-comment">//管理memo存储、何时调用fundamental</span></span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> shell = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> result = memo[n];                  </span><br><span class="language-javascript">                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> result !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;</span><br><span class="language-javascript">                    result = <span class="hljs-title function_">fundamental</span>(shell, n);</span><br><span class="language-javascript">                    memo[n] = result;</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> result;</span><br><span class="language-javascript">            &#125;;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> shell;</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        <span class="hljs-comment">//用memoizer定义fibonacci函数</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> fibonacci = <span class="hljs-title function_">memoizer</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">shell, n</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-title function_">shell</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">shell</span>(n - <span class="hljs-number">2</span>);</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">        </span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;111&#x27;</span>,<span class="hljs-title function_">fibonacci</span>(<span class="hljs-number">10</span>));</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fibonacci</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v-select懒加载</title>
    <link href="/blog/2022/06/20/vue-select/"/>
    <url>/blog/2022/06/20/vue-select/</url>
    
    <content type="html"><![CDATA[<h1 id="v-select懒加载"><a href="#v-select懒加载" class="headerlink" title="v-select懒加载"></a>v-select懒加载</h1><h3 id="1-标签代码"><a href="#1-标签代码" class="headerlink" title="1.标签代码"></a>1.标签代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;el-select placeholder=&quot;请选择&quot; v-model=&quot;selectedCode&quot; @change=&quot;changeSelected&quot;<br>    :filter-method=&quot;filterMethodHandler&quot; filterable v-el-select-lazy=&#x27;loadMore&#x27;&gt;<br>        &lt;el-option :label=&quot;&#x27;请选择&#x27;&quot; value=&quot;&quot;&gt;&lt;/el-option&gt;<br>        &lt;el-option :label=&quot;item[labelKey]&quot; :key=&quot;item.id&quot; :value=&quot;item[labelKey]&quot; v-for=&quot;item in expectCodeFilter&quot;&gt;<br>            &lt;span class=&quot;fl&quot;&gt;&#123;&#123;item[labelKey]&#125;&#125;&lt;/span&gt;<br>            &lt;span class=&quot;fl codeName t-overflow&quot; :title=&quot;item[labelValue]&quot;&gt;(&#123;&#123;item[labelValue]&#125;&#125;)&lt;/span&gt;<br>        &lt;/el-option&gt;<br>    &lt;/el-select&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="2-vue代码"><a href="#2-vue代码" class="headerlink" title="2.vue代码"></a>2.vue代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>    export default &#123;<br>        name: &quot;selectLazyLoading&quot;,<br>        directives:&#123;<br>            &#x27;el-select-lazy&#x27;: &#123;<br>                bind(el, binding) &#123;<br>                    const SELECTWRAP_DOM = el.querySelector( &#x27;.el-select-dropdown .el-select-dropdown__wrap&#x27;);<br>                    SELECTWRAP_DOM.addEventListener(&#x27;scroll&#x27;, function() &#123;<br>                        const condition = this.scrollHeight - this.scrollTop &lt;= this.clientHeight;<br>                        if (condition) &#123;<br>                            binding.value();<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;<br>        &#125;,<br>        data()&#123;<br>            return &#123;<br>                formData:&#123;<br>                    pageIndex:1,<br>                    pageSize:20,<br>                &#125;,<br>                selectedCode:&#x27;&#x27;,<br>                allCodeData:[]<br>            &#125;<br>        &#125;,<br>        props:&#123;<br>            selectModel:String,<br>            labelKey:&#123;<br>                type:String,<br>                default:&#x27;&#x27;<br>            &#125;,<br>            labelValue:&#123;<br>                type:String,<br>                default:&#x27;&#x27;<br>            &#125;,<br>            renderCode:&#123;<br>                type:Array,<br>                default:function()&#123;<br>                    return []<br>                &#125;<br>            &#125;,<br>        &#125;,<br>        model:&#123;<br>            prop:&#x27;selectModel&#x27;,<br>            event:&#x27;selection&#x27;<br>        &#125;,<br>        computed:&#123;<br>            expectCodeFilter()&#123;<br>                let num = this.formData.pageIndex * this.formData.pageSize;<br>                return this.allCodeData.filter((ele,index)=&gt;&#123;<br>                    return index &lt; num;<br>                &#125;)<br>            &#125;<br>        &#125;,<br>        watch: &#123;<br>            selectModel:&#123;<br>                handler:function(val) &#123;<br>                    this.selectedCode = val<br>                &#125;,<br>                immediate:true<br>            &#125;<br>        &#125;,<br>        methods:&#123;<br>            filterMethodHandler(query)&#123;<br>                //搜索时，从全部的数据中查找<br>                if(query !== &#x27;&#x27;)&#123;<br>                    this.allCodeData =  this.renderCode.filter(item =&gt;<br>                item[this.labelKey].toLowerCase().indexOf(query.toLowerCase()) &gt; -1)<br>                &#125; else &#123;<br>                    //如果搜索框为空，则初始化下拉框<br>                    this.initSelectData();<br>                &#125;<br>            &#125;,<br>            changeSelected(val)&#123;<br>                //获取下拉框选中的值<br>                let sendEmit = &#123;&#125;;<br>                for (let i = 0; i &lt; this.expectCodeFilter.length; i++) &#123;<br>                    const item = this.expectCodeFilter[i];<br>                    if(item[this.labelKey] === val)&#123;<br>                        sendEmit = item;<br>                        break<br>                    &#125;<br>                &#125;<br>                this.$emit(&#x27;getChangeValue&#x27;,sendEmit);<br>                this.$emit(&#x27;selection&#x27;,val);<br>            &#125;,<br>            loadMore()&#123;<br>                //下拉框滚动时触发<br>                this.formData.pageIndex++;<br>            &#125;,<br>            initSelectData()&#123;<br>                //初始化搜索下拉框<br>                this.formData = &#123;<br>                    pageIndex:1,<br>                    pageSize:20,<br>                &#125;;<br>                this.allCodeData = this.renderCode;<br>            &#125;,<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>v-select懒加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谷歌浏览器高级调试技巧</title>
    <link href="/blog/2022/06/10/chrome/"/>
    <url>/blog/2022/06/10/chrome/</url>
    
    <content type="html"><![CDATA[<h1 id="谷歌浏览器高级调试技巧"><a href="#谷歌浏览器高级调试技巧" class="headerlink" title="谷歌浏览器高级调试技巧"></a>谷歌浏览器高级调试技巧</h1><h3 id="1-一键重新发起请求"><a href="#1-一键重新发起请求" class="headerlink" title="1.一键重新发起请求"></a>1.一键重新发起请求</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 选中<span class="hljs-code">`Network`</span><br><span class="hljs-bullet">2.</span> 点击<span class="hljs-code">`Fetch/XHR`</span><br><span class="hljs-bullet">3.</span> 选择要重新发送的请求<br><span class="hljs-bullet">4.</span> 右键选择<span class="hljs-code">`Replay XHR`</span><br></code></pre></td></tr></table></figure><h3 id="2-在控制台快速发起请求"><a href="#2-在控制台快速发起请求" class="headerlink" title="2.在控制台快速发起请求"></a>2.在控制台快速发起请求</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 选中<span class="hljs-code">`Network`</span><br><span class="hljs-bullet">2.</span> 点击<span class="hljs-code">`Fetch/XHR`</span><br><span class="hljs-bullet">3.</span> 选择<span class="hljs-code">`Copy as fetch`</span><br><span class="hljs-bullet">4.</span> 控制台粘贴代码<br><span class="hljs-bullet">5.</span> 修改参数，回车搞定<br></code></pre></td></tr></table></figure><h3 id="3-复制JavaScript变量"><a href="#3-复制JavaScript变量" class="headerlink" title="3. 复制JavaScript变量"></a>3. 复制JavaScript变量</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">假如你的代码经过计算会输出一个**复杂的对象**，且需要被复制下来发送给其他人，怎么办？<br><br><span class="hljs-number">1</span>. 使用`copy`函数，将`对象`作为入参执行即可<br></code></pre></td></tr></table></figure><h3 id="4-一键展开所有DOM元素"><a href="#4-一键展开所有DOM元素" class="headerlink" title="4.一键展开所有DOM元素"></a>4.一键展开所有DOM元素</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">按住`opt`键 + click（需要展开的最外层元素）<br></code></pre></td></tr></table></figure><h3 id="5-截取一张全屏的网页"><a href="#5-截取一张全屏的网页" class="headerlink" title="5.截取一张全屏的网页"></a>5.截取一张全屏的网页</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-number">1</span>. 准备好需要截屏的内容<br><span class="hljs-number">2</span>. `cmd + shift + p` 执行`Command`命令<br><span class="hljs-number">3</span>. 输入`Capture full size screenshot` 按下回车<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>browser</category>
      
    </categories>
    
    
    <tags>
      
      <tag>谷歌浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React函数组件和类组件</title>
    <link href="/blog/2022/06/01/react-class-function%EF%BC%88component%EF%BC%89/"/>
    <url>/blog/2022/06/01/react-class-function%EF%BC%88component%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="React-函数组件和类组件"><a href="#React-函数组件和类组件" class="headerlink" title="React-函数组件和类组件"></a>React-函数组件和类组件</h1><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p><strong>何谓类组件（Class Component)</strong></p><p>所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。以下是一个典型的类组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-comment">// 初始化类组件的 state</span><br>  state = &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;&quot;</span><br>  &#125;;<br><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 省略业务逻辑</span><br>  &#125;<br><br>  changeText = <span class="hljs-function">(<span class="hljs-params">newText</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 更新 state</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">text</span>: newText<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-comment">// 编写生命周期方法 render</span><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;this.state.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>this.changeText(&quot;newText&quot;)&#125;&gt;点我修改<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>为了避免代码冗余，提高代码利用率，组件可以重复调用</li><li>组件的属性props是只读的，调用者可以传递参数到props对象中定义属性，调用者可以直接将属性作为组件内的属性或方法直接调用。往往是组件调用方调用组件时指定props定义属性，往往定值后就不改边了，注意组件调用方可赋值被调用方。</li><li>通过props的方式进行父子组件交互,通过传递一个新的props属性值使得子组件重新render，从而达到父子组件通讯。</li><li>{…this.props}可以传递属性集合，…为属性扩展符</li><li>组件必须返回了一个 React 元素</li><li>组件中state为私有属性，是可变的，一般在construct()中定义，使用方法：不要直接修改 state(状态)</li><li>修改子组件还有一种方式，通过 ref属性，表示为对组件真正实例引用，其实就是ReactDOM.render()返回的组件实例</li></ul><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p><strong>何谓函数组件&#x2F;无状态组件（Function Component&#x2F;Stateless Component）</strong></p><p>函数组件顾名思义，就是以函数的形态存在的 React 组件。早期并没有 React-Hooks 的加持，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。以下是一个典型的函数组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">DemoFunction</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; text &#125; = props<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;demoFunction&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;`function 组件所接收到的来自外界的文本内容是：[$&#123;text&#125;]`&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>只负责接收 props，渲染 DOM</li><li>没有 state</li><li>返回了一个 React 元素</li><li>不能访问生命周期方法</li><li>不需要声明类：可以避免 extends 或 constructor 之类的代码，语法上更加简洁。</li><li>不会被实例化：因此不能直接传 ref（可以使用 React.forwardRef 包装后再传 ref）。</li><li>不需要显示声明 this 关键字：在 ES6 的类声明中往往需要将函数的 this 关键字绑定到当前作用域，而因为函数式声明的特性，我们不需要再强制绑定。</li><li>更好的性能表现：因为函数式组件中并不需要进行生命周期的管理与状态管理，因此React并不需要进行某些特定的检查或者内存分配，从而保证了更好地性能表现。</li></ul><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ul><li>接收值：都一样接收了一个只读的 props</li><li>返回值：都是返回了一个 React 元素</li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><h4 id="设计思想层面"><a href="#设计思想层面" class="headerlink" title="设计思想层面"></a>设计思想层面</h4><blockquote><ul><li>类组件的根基是 OOP（面向对象编程），所以它有继承、有属性、有内部状态的管理。</li><li>函数组件的根基是 FP (函数式编程)。它属于“结构化编程”的一种，与数学函数思想类似。也就是假定输入与输出存在某种特定的映射关系，那么输入一定的情况下，输出必然是确定的。</li></ul></blockquote><h4 id="渲染差异"><a href="#渲染差异" class="headerlink" title="渲染差异"></a>渲染差异</h4><p><strong>函数组件会捕获render内部的状态</strong></p><blockquote><p>具体文章参见：React 作者 Dan的文章<a href="https://link.juejin.cn/?target=https://overreacted.io/how-are-function-components-different-from-classes/">How Are Function Components Different from Classes</a></p></blockquote><h4 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h4><ul><li>类组件通过生命周期包装业务逻辑</li><li>函数组件可以通过<strong>React Hooks</strong> 钩子函数来模拟类组件中的生命周期（useState ，useEffect，useContext，useCallback 等）</li></ul><blockquote><p>Hooks 的本质：一套能够使函数组件更强大、更灵活的“钩子”</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>在不使用 Recompose 或者 Hooks 的情况下，如果需要使用生命周期，那么就用类组件，限定的场景是非常固定的；</li><li>但在 recompose 或 Hooks 的加持下，这样的边界就模糊化了，类组件与函数组件的能力边界是完全相同的，都可以使用类似生命周期等能力。</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>在设计模式上，因为类本身的原因，<strong>类组件</strong>是可以实现继承的，而函数组件缺少继承的能力。</p><p>当然在 React 中也是不推荐继承已有的组件的，因为继承的灵活性更差，细节屏蔽过多，所以有这样一个铁律，<strong>组合优于继承</strong>。</p><h3 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h3><p><strong>函数组件更加契合 React 框架的设计理念</strong></p><p>React 组件本身的定位就是函数，一个吃进数据、吐出 UI 的函数。作为开发者，我们编写的是声明式的代码，而 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。</p><p>由于 React Hooks 的推出，函数组件成了社区未来主推的方案。</p><p>React 团队从 Facebook 的实际业务出发，通过探索时间切片与并发模式，以及考虑性能的进一步优化与组件间更合理的代码拆分结构后，认为类组件的模式并不能很好地适应未来的趋势。 他们给出了3 个原因：</p><blockquote><ul><li>this 的模糊性；</li><li>业务逻辑散落在生命周期中；</li><li>React 的组件代码缺乏标准的拆分方式。</li></ul></blockquote><p>而使用 Hooks 的函数组件可以提供比原先更细粒度的逻辑组织与复用，且能更好地适用于时间切片与并发模式。</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数组件和类组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react常用的两个Hook</title>
    <link href="/blog/2022/03/16/react-command-two/"/>
    <url>/blog/2022/03/16/react-command-two/</url>
    
    <content type="html"><![CDATA[<h1 id="React最常用的两个Hook"><a href="#React最常用的两个Hook" class="headerlink" title="React最常用的两个Hook"></a>React最常用的两个Hook</h1><h2 id="一-useState"><a href="#一-useState" class="headerlink" title="一.useState"></a>一.useState</h2><p>代码中：</p><p>React.useState(0)相当于class组件中的this.state添加一个属性值</p><p>variable相当于class组件中的this.state. variable的值</p><p>setVariable可以用来修改variable的值，可以相当于class组件中的this.setState</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,(useState) <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useState_Demo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> [variable, setVariable] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//通过解构赋值，我们拿到的variable、setVariable</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeVariable</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">setVariable</span>(<span class="hljs-function">(<span class="hljs-params">variable</span>) =&gt;</span> variable +<span class="hljs-number">1</span>) <span class="hljs-comment">//setVariable的回调中传进来的参数是variable</span><br>    &#125;<br>    <span class="hljs-title function_">render</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span> = <span class="hljs-string">&#123;change&#125;</span>&gt;</span>点我会使variable+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二-useEffect"><a href="#二-useEffect" class="headerlink" title="二.useEffect"></a>二.useEffect</h2><p>代码中：</p><p>以下代码中可以看出，useEffect的使用代替了在class组件中componentDidMoun、componentDidUpdate、componentWillUnmount的使用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,(useState, useEffect) <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useState_Demo</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">const</span> [variable, setVariable] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//通过解构赋值，我们拿到的variable、setVariable</span><br>    <br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">//这个return是在该组件监测的数据变化时或者被卸载时调用的，被卸载时调用可以相当于componentWillUnmount钩子 </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;该组件被卸载了&#x27;</span>)<br>        &#125;<br>    &#125;, [variable])<span class="hljs-comment">//第二个参数传了[variable]，表示检测variable的更新变化，一旦variable变化就会再次执行useEffect的回调</span><br>                  <span class="hljs-comment">//第二个参数传了[],表示谁都不检测只执行一次useEffect的回调，相当于componentDidMount钩子</span><br>                  <span class="hljs-comment">//第二个参数不传参，只要该组件有state变化就会执行useEffect的回调，相当于componentDidUpdate钩子</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeVariable</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">setVariable</span>(<span class="hljs-function">(<span class="hljs-params">variable</span>) =&gt;</span> variable +<span class="hljs-number">1</span>) <span class="hljs-comment">//setVariable的回调中传进来的参数是variable</span><br>    &#125;<br>    <span class="hljs-title function_">render</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span> = <span class="hljs-string">&#123;change&#125;</span>&gt;</span>点我会使variable+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-使用hook需要注意的"><a href="#三-使用hook需要注意的" class="headerlink" title="三.使用hook需要注意的"></a>三.使用hook需要注意的</h2><p>1、只在组件函数的最外层使用Hook，不要在循环，条件或嵌套函数中调用 Hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,(useEffect) <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useState_Demo</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-comment">//这里才是正确的</span><br>   <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br>    <br>   <span class="hljs-comment">//错误1，使用了条件判断</span><br>   <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br>   &#125;<br>   <span class="hljs-comment">//错误2，使用了循环</span><br>   <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br>   &#125;<br>  <span class="hljs-comment">//错误3,使用了嵌套</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>2、不能在组件的函数外使用Hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,(useState, useEffect) <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-comment">//错误1，在组件函数外使用了useState</span><br><span class="hljs-keyword">const</span> [variable, setVariable] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//错误2，在组件函数外使用了useEffect</span><br><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useState_Demo</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-comment">//在组件函数里使用才是正确的</span><br>   <span class="hljs-keyword">const</span> [variable, setVariable] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、为了避免以上的错误，可以 安装<a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/eslint-plugin-react-hooks"><code>eslint-plugin-react-hooks</code></a> ESLint 插件来检查代码上错误</p><h2 id="四-自定义hook"><a href="#四-自定义hook" class="headerlink" title="四.自定义hook"></a>四.自定义hook</h2><p>hook就是一个函数，自定义hook是为了方便组件之间共享逻辑，其实就是对复用功能进行封装，自定义hook内部也调用了react自带的hook，命名要以use开头</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//自定义hook</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useHook</span>(<span class="hljs-params">initState</span>) &#123;<br>  <span class="hljs-keyword">const</span> [variable, setVariable] = <span class="hljs-title function_">useState</span>(initState)<br>  <span class="hljs-keyword">return</span> variable;<br>&#125;<br><span class="hljs-comment">//使用自定义hook</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useState_Demo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> variableState = <span class="hljs-title function_">useHook</span>(<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可能你会疑惑，多个组件中使用相同的 Hook 会共享 state 吗？</p><p>答案是：不会。因为每次调用react自带的hook都是独自互不影响的，所以自定义hook被多次重复调用也是独自互不影响的</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react常用的两个Hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 常用命令</title>
    <link href="/blog/2022/03/16/linux-basic/"/>
    <url>/blog/2022/03/16/linux-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h3 id="一-目录操作命令"><a href="#一-目录操作命令" class="headerlink" title="一.目录操作命令"></a>一.目录操作命令</h3><h4 id="2-1-目录切换-cd"><a href="#2-1-目录切换-cd" class="headerlink" title="2.1 目录切换 cd"></a>2.1 目录切换 cd</h4><p>命令：cd 目录</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> /        切换到根目录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">/usr</span>        切换到根目录下的usr目录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">../</span>        切换到上一级目录 或者  <span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br><span class="hljs-keyword">cd</span> ~        切换到home目录<br><span class="hljs-keyword">cd</span> -        切换到上次访问的目录<br></code></pre></td></tr></table></figure><h4 id="2-2-目录查看-ls-al"><a href="#2-2-目录查看-ls-al" class="headerlink" title="2.2 目录查看 ls [-al]"></a>2.2 目录查看 ls [-al]</h4><p>命令：ls [-al]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span>                查看当前目录下的所有目录和文件<br><span class="hljs-built_in">ls</span> -a            查看当前目录下的所有目录和文件（包括隐藏的文件）<br><span class="hljs-built_in">ls</span> -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）<br><span class="hljs-built_in">ls</span> /dir            查看指定目录下的所有目录和文件   如：<span class="hljs-built_in">ls</span> /usr<br></code></pre></td></tr></table></figure><h4 id="2-3-目录操作【增，删，改，查】"><a href="#2-3-目录操作【增，删，改，查】" class="headerlink" title="2.3 目录操作【增，删，改，查】"></a>2.3 目录操作【增，删，改，查】</h4><h5 id="2-3-1-创建目录【增】-mkdir"><a href="#2-3-1-创建目录【增】-mkdir" class="headerlink" title="2.3.1 创建目录【增】 mkdir"></a>2.3.1 创建目录【增】 mkdir</h5><p>命令：mkdir 目录</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">mkdir   <span class="hljs-keyword">aaa</span>       在当前目录下创建一个名为<span class="hljs-keyword">aaa</span>的目录<br>mkdir   /usr/<span class="hljs-keyword">aaa</span>   在指定目录下创建一个名为<span class="hljs-keyword">aaa</span>的目录<br></code></pre></td></tr></table></figure><h4 id="2-3-2-删除目录或文件【删】rm"><a href="#2-3-2-删除目录或文件【删】rm" class="headerlink" title="2.3.2 删除目录或文件【删】rm"></a>2.3.2 删除目录或文件【删】rm</h4><p>命令：rm [-rf] 目录</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 删除文件：</span><br><span class="hljs-built_in">rm</span> 文件        删除当前目录下的文件<br><span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> 文件    删除当前目录的的文件（不询问）<br><br><span class="hljs-comment"># 删除目录：</span><br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-r</span> aaa    递归删除当前目录下的aaa目录<br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span> aaa    递归删除当前目录下的aaa目录（不询问）<br><br><span class="hljs-comment"># 全部删除：</span><br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span> *    将当前目录下的所有目录和文件全部删除<br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span> /*    【命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除<br></code></pre></td></tr></table></figure><p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录&#x2F;文件&#x2F;压缩包</p><h4 id="2-3-3-目录修改【改】mv-和-cp"><a href="#2-3-3-目录修改【改】mv-和-cp" class="headerlink" title="2.3.3 目录修改【改】mv 和 cp"></a>2.3.3 目录修改【改】mv 和 cp</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">重命名目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   命令：<span class="hljs-built_in">mv</span> 当前目录 新目录 （将目录aaa改为bbb）</span><br>mv aaa bbb <br><span class="hljs-meta prompt_"># </span><span class="language-bash">   注意：<span class="hljs-built_in">mv</span>的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">剪切目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   命令：<span class="hljs-built_in">mv</span> 目录名称 目录的新位置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   示例：将/usr/tmp目录下的aaa目录剪切到 /usr目录下面</span>  <br>mv /usr/tmp/aaa /usr<br><span class="hljs-meta prompt_"># </span><span class="language-bash">   注意：<span class="hljs-built_in">mv</span>语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   命令：<span class="hljs-built_in">cp</span> -r 目录名称 目录拷贝的目标位置  -r代表递归</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   示例：将/usr/tmp目录下的aaa目录复制到 /usr目录下面</span>   <br>cp /usr/tmp/aaa  /usr<br><span class="hljs-meta prompt_"># </span><span class="language-bash">   注意：<span class="hljs-built_in">cp</span>命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用写-r递归</span><br><br></code></pre></td></tr></table></figure><h4 id="2-3-4-搜索目录【查】find"><a href="#2-3-4-搜索目录【查】find" class="headerlink" title="2.3.4 搜索目录【查】find"></a>2.3.4 搜索目录【查】find</h4><p>命令：find 目录 参数 文件名称</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">find</span> <span class="hljs-regexp">/usr/</span>tmp -name <span class="hljs-string">&#x27;a*&#x27;</span>   查找<span class="hljs-regexp">/usr/</span>tmp目录下的所有以a开头的目录或文件<br></code></pre></td></tr></table></figure><h3 id="二-文件操作命令"><a href="#二-文件操作命令" class="headerlink" title="二.文件操作命令"></a>二.文件操作命令</h3><h4 id="3-1-文件操作【增，删，改，查】"><a href="#3-1-文件操作【增，删，改，查】" class="headerlink" title="3.1 文件操作【增，删，改，查】"></a>3.1 文件操作【增，删，改，查】</h4><h5 id="3-1-1-新建文件【增】touch"><a href="#3-1-1-新建文件【增】touch" class="headerlink" title="3.1.1 新建文件【增】touch"></a>3.1.1 新建文件【增】touch</h5><p>命令：touch 文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 示例：在当前目录创建一个名为aa.txt的文件   </span><br><span class="hljs-built_in">touch</span>  aa.txt<br></code></pre></td></tr></table></figure><h5 id="3-1-2-删除文件-【删】-rm"><a href="#3-1-2-删除文件-【删】-rm" class="headerlink" title="3.1.2 删除文件 【删】 rm"></a>3.1.2 删除文件 【删】 rm</h5><p>命令：rm -rf 文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 示例：在当前目录删除一个名为aa.txt的文件   </span><br><span class="hljs-built_in">rm</span> -rf aa.txt<br></code></pre></td></tr></table></figure><h5 id="3-1-3-修改文件【改】-vi或vim"><a href="#3-1-3-修改文件【改】-vi或vim" class="headerlink" title="3.1.3 修改文件【改】 vi或vim"></a>3.1.3 修改文件【改】 vi或vim</h5><p>【vi编辑器的3种模式】<br>    基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>) 命令行模式<span class="hljs-keyword">command</span> <span class="hljs-keyword">mode</span>）<br>     控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert <span class="hljs-keyword">mode</span>下，或者到 <span class="hljs-keyword">last</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">mode</span>。<br>     命令行模式下的常用命令：<br>        【<span class="hljs-number">1</span>】控制光标移动：↑，↓，<span class="hljs-keyword">j</span><br>        【<span class="hljs-number">2</span>】删除当前行：dd <br>        【<span class="hljs-number">3</span>】查找：/字符<br>        【<span class="hljs-number">4</span>】进入编辑模式：i <span class="hljs-keyword">o</span> <span class="hljs-keyword">a</span><br>        【<span class="hljs-number">5</span>】进入底行模式：:<br>     <br><span class="hljs-number">2</span>) 编辑模式（Insert <span class="hljs-keyword">mode</span>）<br>     只有在Insert <span class="hljs-keyword">mode</span>下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>      编辑模式下常用命令：<br>        【<span class="hljs-number">1</span>】ESC 退出编辑模式到命令行模式；<br>     <br><span class="hljs-number">3</span>) 底行模式（<span class="hljs-keyword">last</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">mode</span>）<br>      将文件保存或退出<span class="hljs-keyword">vi</span>，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>      底行模式下常用命令：<br>        【<span class="hljs-number">1</span>】退出编辑：   :q<br>        【<span class="hljs-number">2</span>】强制退出：   :q!<br>        【<span class="hljs-number">3</span>】保存并退出：  :<span class="hljs-keyword">wq</span><br></code></pre></td></tr></table></figure><p>​      </p><p><strong>打开文件</strong></p><p>命令：vi 文件名</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 示例：打开当前目录下的aa.txt文件   </span><br><span class="hljs-attribute">vi</span> aa.txt <br><span class="hljs-comment"># 或者</span><br>vim aa.txt<br></code></pre></td></tr></table></figure><p>注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i&#x2F;a&#x2F;o进入编辑模式。</p><p><strong>编辑文件</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less">使用<span class="hljs-selector-tag">vi</span>编辑器打开文件后点击按键：<span class="hljs-selector-tag">i</span> ，<span class="hljs-selector-tag">a</span>或者<span class="hljs-selector-tag">o</span>即可进入编辑模式。<br><br><span class="hljs-selector-tag">i</span>:在光标所在字符前开始插入<br><span class="hljs-selector-tag">a</span>:在光标所在字符后开始插入<br><span class="hljs-selector-tag">o</span>:在光标所在行的下面另起一新行插入<br></code></pre></td></tr></table></figure><p><strong>保存或者取消编辑</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">保存文件：<br><br>第一步：ESC  进入命令行模式<br><span class="hljs-section">第二步：:     进入底行模式</span><br>第三步：wq     保存并退出编辑<br><br>取消编辑：<br><br>第一步：ESC  进入命令行模式<br><span class="hljs-section">第二步：:     进入底行模式</span><br>第三步：q!     撤销本次修改并退出编辑<br></code></pre></td></tr></table></figure><h5 id="3-1-4-文件的查看【查】"><a href="#3-1-4-文件的查看【查】" class="headerlink" title="3.1.4 文件的查看【查】"></a>3.1.4 文件的查看【查】</h5><p>文件的查看命令：cat&#x2F;more&#x2F;less&#x2F;tail</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span>：看最后一屏</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例：使用<span class="hljs-built_in">cat</span>查看/etc/sudo.conf文件，只能显示最后一屏内容</span><br>cat sudo.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">more：百分比显示</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看</span><br>more sudo.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">less：翻页查看</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看</span><br>less sudo.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">tail</span>：指定行数或者动态查看</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">示例：使用<span class="hljs-built_in">tail</span> -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束</span>  <br>tail -10 sudo.conf<br></code></pre></td></tr></table></figure><h3 id="三-压缩文件操作"><a href="#三-压缩文件操作" class="headerlink" title="三.压缩文件操作"></a>三.压缩文件操作</h3><h4 id="4-1-打包和压缩"><a href="#4-1-打包和压缩" class="headerlink" title="4.1 打包和压缩"></a>4.1 打包和压缩</h4><p>linux中打包并压缩的文件：.tar.gz</p><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p><p>命令：tar -zcvf 打包压缩后的文件名 要打包的文件</p><p>  z：调用gzip压缩命令进行压缩<br>  c：打包文件<br>  v：显示运行过程<br>  f：指定文件名</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 示例：打包并压缩/usr/tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar</span><br>tar -zcvf ab.tar aa.txt <span class="hljs-keyword">bb.txt </span><br><span class="hljs-comment"># 或</span><br>tar -zcvf ab.tar *<br></code></pre></td></tr></table></figure><h4 id="4-2-解压"><a href="#4-2-解压" class="headerlink" title="4.2 解压"></a>4.2 解压</h4><p>命令：tar [-zxvf] 压缩文件<br>其中：x：代表解压<br>示例：将&#x2F;usr&#x2F;tmp 下的ab.tar解压到当前目录下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tar</span> -zxvf ab.tar<br></code></pre></td></tr></table></figure><p>示例：将&#x2F;usr&#x2F;tmp 下的ab.tar解压到根目录&#x2F;usr下<br>tar -xvf ab.tar -C &#x2F;usr——C代表指定解压的位置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">tar -zxvf ab.tar -C <span class="hljs-regexp">/usr/</span><br></code></pre></td></tr></table></figure><h3 id="四-查找命令"><a href="#四-查找命令" class="headerlink" title="四.查找命令"></a>四.查找命令</h3><h4 id="1-grep"><a href="#1-grep" class="headerlink" title="1.grep"></a>1.grep</h4><p>grep命令是一种强大的文本搜索工具</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 查找指定ssh服务进程</span><br>ps -ef | <span class="hljs-keyword">grep</span> sshd <br><span class="hljs-comment"># 查找指定服务进程，排除gerp身 </span><br>ps -ef | <span class="hljs-keyword">grep</span> sshd | <span class="hljs-keyword">grep</span> -v <span class="hljs-keyword">grep</span> <br><span class="hljs-comment"># 查找指定进程个数 </span><br>ps -ef | <span class="hljs-keyword">grep</span> sshd -c <br></code></pre></td></tr></table></figure><h4 id="2-find"><a href="#2-find" class="headerlink" title="2.find"></a>2.find</h4><p>find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 </p><p>find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 在当前目录查找以.log结尾的文件，并显示详细信息。 </span><br><span class="hljs-built_in">find</span> . -name <span class="hljs-string">&quot;*.log&quot;</span> -ls <br><span class="hljs-comment">#  查找/root/目录下权限为600的文件 </span><br><span class="hljs-built_in">find</span> /root/ -perm 600 <br><span class="hljs-comment">#  查找当目录，以.log结尾的普通文件 </span><br><span class="hljs-built_in">find</span> . -type f -name <span class="hljs-string">&quot;*.log&quot;</span>  <br><span class="hljs-comment">#  查找当前所有目录并排序 </span><br><span class="hljs-built_in">find</span> . -type d | sort <br><span class="hljs-comment">#  查找当前目录大于100M的文件</span><br><span class="hljs-built_in">find</span> . -size +100M <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>common</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-redux使用</title>
    <link href="/blog/2022/03/03/react-redux/"/>
    <url>/blog/2022/03/03/react-redux/</url>
    
    <content type="html"><![CDATA[<h1 id="react-redux使用"><a href="#react-redux使用" class="headerlink" title="react-redux使用"></a>react-redux使用</h1><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><ul><li>A Predictable State Container for JS Apps（JS 应用程序的可预测状态容器）</li></ul><h4 id="2-redux简介"><a href="#2-redux简介" class="headerlink" title="2. redux简介"></a>2. redux简介</h4><ul><li>redux是react全家桶的一员，它试图为 React 应用提供「可预测化的状态管理」机制。</li><li>Redux是将整个应用状态存储到到一个地方，称为store</li><li>里面保存一棵状态树(state tree)</li><li>组件可以派发(dispatch)行为(action)给store,而不是直接通知其它组件</li><li>其它组件可以通过订阅store中的状态(state)来刷新自己的视图</li></ul><h4 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save redux</span><br></code></pre></td></tr></table></figure><h4 id="4-redux核心"><a href="#4-redux核心" class="headerlink" title="4. redux核心"></a>4. redux核心</h4><h5 id="4-1-State"><a href="#4-1-State" class="headerlink" title="4.1 State"></a>4.1 State</h5><p>state是数据集合</p><p><strong>可以理解为工厂加工商品所需的原材料</strong></p><h5 id="4-2-action"><a href="#4-2-action" class="headerlink" title="4.2 action"></a>4.2 action</h5><p>State的变化，会导致View的变化。但是，用户接触不到 State，只能接触到View 所以，State的变化必须是 View导致的。</p><p>action就是改变state的指令，有多少操作state的动作就会有多少action。</p><p><strong>可以将action理解为描述发生了什么的指示器</strong></p><h5 id="4-3-reducer-加工函数"><a href="#4-3-reducer-加工函数" class="headerlink" title="4.3 reducer 加工函数"></a>4.3 reducer 加工函数</h5><p>action发出命令后将state放入reucer加工函数中，返回新的state。 <strong>可以理解为加工的机器</strong></p><h5 id="4-4-store"><a href="#4-4-store" class="headerlink" title="4.4 store"></a>4.4 store</h5><p><strong>store 可以理解为有多个加工机器的总工厂</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">let</span> store = <span class="hljs-title function_">createStore</span>(reducers);<br></code></pre></td></tr></table></figure><p>Store 就是把它们联系到一起的对象。Store 有以下职责：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">维持应用的 <span class="hljs-keyword">state</span>；<br>提供 getState() 方法获取 <span class="hljs-keyword">state</span>；<br>提供 dispatch(action) 方法更新 <span class="hljs-keyword">state</span>；<br>通过 subscribe(listener) 注册监听器;<br>通过 subscribe(listener) 返回的函数注销监听器。<br></code></pre></td></tr></table></figure><p>我们可以通过store.getState()来了解工厂中商品的状态， 使用store.dispatch发送action指令。</p><h4 id="5-经典案例"><a href="#5-经典案例" class="headerlink" title="5. 经典案例"></a>5. 经典案例</h4><p>这是一个redux的经典案例</p><ul><li>定义reducer函数根据action的类型改变state</li><li>actions 定义指令</li><li>通过createStore创建store</li><li>调用store.dispatch()发出修改state的命令</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state = &#123;count: <span class="hljs-number">0</span>&#125;, action</span>) =&gt; &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;INCREASE&#x27;</span>: <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;DECREASE&#x27;</span>: <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-attr">default</span>: <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> actions = &#123;<br>  <span class="hljs-attr">increase</span>: <span class="hljs-function">() =&gt;</span> (&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREASE&#x27;</span>&#125;),<br>  <span class="hljs-attr">decrease</span>: <span class="hljs-function">() =&gt;</span> (&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;DECREASE&#x27;</span>&#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer);<br><br>store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store.<span class="hljs-title function_">getState</span>())<br>);<br><br>store.<span class="hljs-title function_">dispatch</span>(actions.<span class="hljs-title function_">increase</span>()) <span class="hljs-comment">// &#123;count: 1&#125;</span><br>store.<span class="hljs-title function_">dispatch</span>(actions.<span class="hljs-title function_">increase</span>()) <span class="hljs-comment">// &#123;count: 2&#125;</span><br>store.<span class="hljs-title function_">dispatch</span>(actions.<span class="hljs-title function_">increase</span>()) <span class="hljs-comment">// &#123;count: 3&#125;</span><br><br></code></pre></td></tr></table></figure><p><strong>我们可以直接在react component上使用store.dispatch，但是这样不太方便，这个时候我们需要react-redux</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Todos</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>(<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onCLick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>store.dispatch(actions.delTodo()) &#125;&gt;test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-react-redux"><a href="#6-react-redux" class="headerlink" title="6. react-redux"></a>6. react-redux</h4><p>Redux 官方提供的 React 绑定库。 具有高效且灵活的特性。</p><h5 id="6-1-安装"><a href="#6-1-安装" class="headerlink" title="6.1 安装"></a>6.1 安装</h5><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save react-redux</span><br></code></pre></td></tr></table></figure><h5 id="6-2-核心"><a href="#6-2-核心" class="headerlink" title="6.2 核心"></a>6.2 核心</h5><ul><li>&lt; Provider store&gt;</li><li>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</li></ul><p>Provider 内的任何一个组件（比如这里的 Comp），如果需要使用 state 中的数据，就必须是「被 connect 过的」组件——使用 connect 方法对「你编写的组件（MyComp）」进行包装后的产物。</p><p>这个函数允许我们将 store 中的数据作为 props 绑定到组件上。</p><p>react-redux中的connect方法将store上的getState 和 dispatch 包装成组件的props。</p><p>将之前直接在组件上dispatch的代码修改为如下：</p><p>index.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store&#x27;</span>;<br><span class="hljs-keyword">import</span> actions <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store/actions/list&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Todos</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>(<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onCLick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>this.props.del_todo() &#125;&gt;test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(<br>    <span class="hljs-function"><span class="hljs-params">state</span>=&gt;</span>state,<br>    actions<br>)(<span class="hljs-title class_">Todos</span>);<br></code></pre></td></tr></table></figure><p>Provider 能拿到关键的store并传递给每个子组件</p><h4 id="7-connect如何工作的？"><a href="#7-connect如何工作的？" class="headerlink" title="7. connect如何工作的？"></a>7. connect如何工作的？</h4><p>connect() 接收四个参数，它们分别是 mapStateToProps ， mapDispatchToProps， mergeProps 和 options 。</p><h5 id="7-1-mapStateToProps这个函数允许我们将-store-中的数据作为-props-绑定到组件上。"><a href="#7-1-mapStateToProps这个函数允许我们将-store-中的数据作为-props-绑定到组件上。" class="headerlink" title="7.1 mapStateToProps这个函数允许我们将 store 中的数据作为 props 绑定到组件上。"></a>7.1 <code>mapStateToProps这个函数允许我们将 store 中的数据作为 props 绑定到组件上。</code></h5><p><strong>reducer.js</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">state = &#123; lists: [&#123;text:<span class="hljs-string">&#x27;移动端计划&#x27;</span>&#125;],newType:<span class="hljs-string">&#x27;all&#x27;</span>&#125;, action</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>        <span class="hljs-keyword">case</span> types.<span class="hljs-property">ADD_TODO</span>:<br>            <span class="hljs-keyword">return</span> &#123;...state,<span class="hljs-attr">lists</span>:[...state.<span class="hljs-property">lists</span>,&#123;<span class="hljs-attr">text</span>:action.<span class="hljs-property">text</span>&#125;]&#125;<br>        <span class="hljs-keyword">case</span> types.<span class="hljs-property">TOGGLE_TODO</span>:<br>            <span class="hljs-keyword">return</span> &#123;...state,<span class="hljs-attr">lists</span>:state.<span class="hljs-property">lists</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span>(index == action.<span class="hljs-property">index</span>)&#123;<br>                    item.<span class="hljs-property">completed</span> = !item.<span class="hljs-property">completed</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> item<br>            &#125;)&#125;<br>        <span class="hljs-keyword">case</span> types.<span class="hljs-property">DEL_TODO</span>:<br>            <span class="hljs-keyword">return</span> &#123;...state,<span class="hljs-attr">lists</span>:[...state.<span class="hljs-property">lists</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,action.<span class="hljs-property">index</span>),...state.<span class="hljs-property">lists</span>.<span class="hljs-title function_">slice</span>(action.<span class="hljs-property">index</span>+<span class="hljs-number">1</span>)]&#125;<br>        <span class="hljs-keyword">case</span> types.<span class="hljs-property">SWITCH_TYPE</span>:<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;...state,<span class="hljs-attr">newType</span>:action.<span class="hljs-property">newType</span>&#125;)<br>            <span class="hljs-keyword">return</span> &#123;...state,<span class="hljs-attr">newType</span>:action.<span class="hljs-property">newType</span>&#125;<br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在reducer.js中，定义了初始化的state，通过connect方法，我们就能使用this.props.lists拿到初始化的state。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store&#x27;</span>;<br><span class="hljs-keyword">import</span> actions <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store/actions/list&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;connect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Todos</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>(<br>            &#123;<br>                + <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">                +    this.props.state.lists.map(list =&gt;(</span><br><span class="language-xml">                +        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;list.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                +    ))</span><br><span class="language-xml">                + <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>   <br>            &#125;<br>            &lt;div onCLick=&#123;<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">del_todo</span>() &#125;&gt;test&lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(<br>    <span class="hljs-function"><span class="hljs-params">state</span>=&gt;</span>state,<br>    actions<br>)(<span class="hljs-title class_">Todos</span>);<br></code></pre></td></tr></table></figure><p>当 state 变化，或者 ownProps 变化的时候，mapStateToProps 都会被调用，计算出一个新的 stateProps，（在与 ownProps merge 后）更新给 MyComp。</p><h5 id="7-2-mapDispatchToProps-dispatch-ownProps-dispatchProps-connect-的第二个参数是-mapDispatchToProps，它的功能是，将-action-作为-props-绑定到-MyComp-上。"><a href="#7-2-mapDispatchToProps-dispatch-ownProps-dispatchProps-connect-的第二个参数是-mapDispatchToProps，它的功能是，将-action-作为-props-绑定到-MyComp-上。" class="headerlink" title="7.2 mapDispatchToProps(dispatch, ownProps): dispatchProps connect 的第二个参数是 mapDispatchToProps，它的功能是，将 action 作为 props 绑定到 MyComp 上。"></a>7.2 <code>mapDispatchToProps(dispatch, ownProps): dispatchProps connect 的第二个参数是 mapDispatchToProps，它的功能是，将 action 作为 props 绑定到 MyComp 上。</code></h5><p><strong>action.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> types <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../action-types&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-title function_">add_todo</span>(<span class="hljs-params">text</span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: types.<span class="hljs-property">ADD_TODO</span>, <span class="hljs-attr">text</span>: text&#125;<br>    &#125;,<br>    <span class="hljs-title function_">del_todo</span>(<span class="hljs-params">idx</span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>:types.<span class="hljs-property">DEL_TODO</span>, <span class="hljs-attr">index</span>: idx&#125;<br>    &#125;,<br>    <span class="hljs-title function_">toggle_todo</span>(<span class="hljs-params">index</span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>:types.<span class="hljs-property">TOGGLE_TODO</span>, index&#125;<br>    &#125;,<br>    <span class="hljs-title function_">del_todo</span>(<span class="hljs-params">index</span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>:types.<span class="hljs-property">DEL_TODO</span>, index&#125;<br>    &#125;,<br>    <span class="hljs-title function_">switch_type</span>(<span class="hljs-params">newType</span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">type</span>:types.<span class="hljs-property">SWITCH_TYPE</span>, newType&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我在action.js中定义的修改状态的命令，会通过connect 的 mapDispatchToProps方法变为props绑定在reac组件上。</p><p>我们可以方便得使用去调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onCLick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>this.props.del_todo() &#125;&gt;test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="8-深入"><a href="#8-深入" class="headerlink" title="8. 深入"></a>8. 深入</h4><p>了解到这里，我们会发现并没有使用store.dispatch方法去发出命令，但是state已经修改，view也变化了，那么到底发生了什么？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">store.<span class="hljs-title function_">dispatch</span>(actions.<span class="hljs-title function_">increase</span>())<br></code></pre></td></tr></table></figure><p><strong>关键的是connect()</strong></p><p>connect原理简化版</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,&#123;<span class="hljs-title class_">Component</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;bindActionCreators&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> propTypes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">mapStateToProps,mapDispatchToProps</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">WrapedComponent</span>)&#123;<br>      <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span>&#123;<br>          <span class="hljs-keyword">static</span> contextTypes = &#123;<br>              <span class="hljs-attr">store</span>:propTypes.<span class="hljs-property">object</span><br>          &#125;<br>          <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props,context</span>)&#123;<br>            <span class="hljs-variable language_">super</span>(props,context);<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span> = context.<span class="hljs-property">store</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-title function_">mapStateToProps</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-title function_">getState</span>());<br>          &#125;<br>          <span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>)&#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">unsubscribe</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-title function_">mapStateToProps</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-title function_">getState</span>()));<br>              &#125;);<br>          &#125;<br>          <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>)&#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unsubscribe</span>();<br>          &#125;<br>          <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>              <span class="hljs-keyword">let</span> actions= &#123;&#125;;<br>              <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> mapDispatchToProps == <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>                actions = <span class="hljs-title function_">mapDispatchToProps</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-property">disaptch</span>);<br>              &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> mapDispatchToProps == <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>                  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;object&#x27;</span>, mapDispatchToProps)<br>                actions = <span class="hljs-title function_">bindActionCreators</span>(mapDispatchToProps,<span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-property">dispatch</span>);<br>              &#125;<br>                <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrapedComponent</span> &#123;<span class="hljs-attr">...this.state</span>&#125; &#123;<span class="hljs-attr">...actions</span>&#125;/&gt;</span></span><br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">ProxyComponent</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.state的返回 connect中对于Provided父组件上传来的store,通过将状态返回</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">mapStateToProps</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-title function_">getState</span>());<br></code></pre></td></tr></table></figure><p>通过 Redux 的辅助函数 bindActionCreators()，用dispatch监听每一个action。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">bindActionCreators</span>(mapDispatchToProps,<span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-property">dispatch</span>);<br></code></pre></td></tr></table></figure><p>所以调用props上的方法时，会自动发起store.dispach（XXX）事件，发出命令</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript Reflect映射对象</title>
    <link href="/blog/2022/03/03/js-reflect/"/>
    <url>/blog/2022/03/03/js-reflect/</url>
    
    <content type="html"><![CDATA[<h1 id="JS-Reflect映射对象"><a href="#JS-Reflect映射对象" class="headerlink" title="JS-Reflect映射对象"></a>JS-Reflect映射对象</h1><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p><code>Reflect</code>是一个对象，翻译过来是反射的意思，它提供了很多操作<code>JavaScript</code>对象的方法， 是为了弥补<code>Object</code>中对象的一些缺陷。且所有属性和方法都是静态的。</p><h4 id="为什么会有Reflect"><a href="#为什么会有Reflect" class="headerlink" title="为什么会有Reflect"></a>为什么会有Reflect</h4><p>在早期，<code>JavaScript</code>这门语言中的一些内部方法都被部署到了<code>Object</code>这个对象上。就例如<code>getPrototype</code>、<code>deinfeProperty</code>等<code>API</code>、类似<code>in</code>、<code>delete</code>操作符都放到了<code>Object</code>对象上了。但<code>Object</code>作为一个构造函数（<code>Reflect</code>并非一个构造函数，不能通过new关键字调用），这些方法放到它身上并不合适，所以在<code>ES6</code>之后的内部新方法会部署到<code>Reflect</code>对象中。</p><h4 id="使用Reflect对象操作Object对象"><a href="#使用Reflect对象操作Object对象" class="headerlink" title="使用Reflect对象操作Object对象"></a>使用Reflect对象操作Object对象</h4><p>Reflect对象让我们操作<code>Object</code>对象不再是通过点语法了，而是变成了函数行为。</p><p>我们看下面的例子，获取对象属性可以使用<code>Reflect.get</code>方法、将对象的属性赋值可以使用<code>Reflect.set</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;_island&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;;<br><br><span class="hljs-comment">// 获取对应属性的值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// _island</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// _island</span><br><br><span class="hljs-comment">// 对对象的属性赋值操作</span><br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// abc</span><br><br><br><span class="hljs-comment">// 判断一个对象中是否有该属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> obj); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(obj, <span class="hljs-string">&quot;name&quot;</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="Reflect中的方法"><a href="#Reflect中的方法" class="headerlink" title="Reflect中的方法"></a>Reflect中的方法</h4><table><thead><tr><th>对象中的方法</th><th>说明</th></tr></thead><tbody><tr><td>Reflect.apply()</td><td>对一个函数进行<code>apply</code>调用</td></tr><tr><td>Reflect.construct()</td><td>对构造函数进行<code>new</code>操作</td></tr><tr><td>Reflect.defineProperty()</td><td>定义一个属性</td></tr><tr><td>Reflect.deleteProperty()</td><td>删除一个属性</td></tr><tr><td>Reflect.get()</td><td>获取一个属性</td></tr><tr><td>Reflect.getOwnPropertyDescriptor()</td><td>获取一个属性描述符</td></tr><tr><td>Reflect.getPrototypeOf()</td><td>获取一个对象的原型</td></tr><tr><td>Reflect.has()</td><td>判断一个属性是否在对象中</td></tr><tr><td>Reflect.isExtensible()</td><td>判断可以扩展</td></tr><tr><td>Reflect.ownKeys()</td><td>获取一个对象中的<code>key</code>集合</td></tr><tr><td>Reflect.preventExtensions()</td><td>使一个对象不可扩展</td></tr><tr><td>Reflect.set()</td><td>设置一个属性</td></tr><tr><td>Reflect.setPrototypeOf()</td><td>设置一个对象的原型</td></tr></tbody></table><p><code>Reflect</code>对象中一些方法与<code>Object</code>相同，但它们存在一些细微的区别，如果你想更加了解可以阅读<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods">Reflect和Object中的方法区别</a>。</p><p>在返回值方便<code>Reflect</code>对象中的方法设计的更加合理。比如<code>defineProperty</code>方法，如果没有将属性设置成功，在<code>Reflect</code>中会返回<code>boolean</code>值，而<code>Object</code>对象中如果没有定义成功则会抛出<code>TypeError</code>。</p><h4 id="Reflect搭配Proxy"><a href="#Reflect搭配Proxy" class="headerlink" title="Reflect搭配Proxy"></a>Reflect搭配Proxy</h4><p><code>Reflect</code>对象中的方法和上一篇文章将到的<code>Proxy</code>对象的方法的对应的，<code>Proxy</code>对象中的方法也能在<code>Reflect</code>对象中调用。</p><p>通常我们将<code>Reflect</code>对象搭配<code>Proxy</code>一起使用，我们看下面这个<code>Reflect</code>搭配<code>Proxy</code>对象使用的案例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;_island&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-comment">// 原来的写法</span><br>    <span class="hljs-comment">// return target[key]</span><br>    <span class="hljs-comment">// 使用Reflect</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, newVal, receiver</span>) &#123;<br>    <span class="hljs-comment">// 原来的写法</span><br>    <span class="hljs-comment">// target[key]=newVal</span><br>    <span class="hljs-comment">// 使用Reflect</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newVal, receiver);<br>  &#125;,<br>&#125;);<br><br>objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// abc</span><br></code></pre></td></tr></table></figure><p>在上面，<code>Proxy</code>对象中<code>get</code>、<code>set</code>捕获器多了一个<code>receiver</code>参数，这是这两个捕获器特有的，这个<code>receiver</code>参数是当前代理的目标。</p><p>当<code>Proxy</code>和<code>Reflect</code>搭配使用时，<code>Proxy</code>对象会拦截对应的操作，后者完成对应的操作，如果传入<code>receiver</code>，那么<code>Reflect.get</code>属性会触发<code>Proxy.defineProperty</code>捕获器。我们再上面这里案例上再新增一些代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;_island&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-comment">// 原来的写法</span><br>    <span class="hljs-comment">// return target[key]</span><br>    <span class="hljs-comment">// 使用Reflect</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, newVal, receiver</span>) &#123;<br>    <span class="hljs-comment">// 原来的写法</span><br>    <span class="hljs-comment">// target[key]=newVal</span><br>    <span class="hljs-comment">// 使用Reflect</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newVal, receiver);<br>  &#125;,<br>  <span class="hljs-attr">defineProperty</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, attr</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;defineProperty&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, key, attr);<br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(target, key, attr);<br>  &#125;<br>&#125;);<br><br>objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>); <br><span class="hljs-comment">// defineProperty</span><br><span class="hljs-comment">// &#123; name: &#x27;_island&#x27; &#125; name &#123; value: &#x27;abc&#x27; &#125;</span><br><span class="hljs-comment">// &#123; name: &#x27;abc&#x27; &#125;</span><br><span class="hljs-comment">// abc</span><br></code></pre></td></tr></table></figure><p>传入在我们获取代理对象中的<code>name</code>属性时，当<code>Reflect</code>有<code>receiver</code>参数传入时，获取属性值时会获取到<code>receiver</code>中的，所以会触发<code>defineProperty</code>捕获器，如果没有传入<code>receiver</code>参数，则不会触发<code>defineProperty</code>捕获器。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>Reflect</code>对象中集合了<code>JavaScript</code>内部方法</li><li>操作<code>Object</code>对象的方式变成了函数行为</li><li><code>Reflect</code>对象中的方法返回结果更加合理</li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Reflect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3父子组件通信方式</title>
    <link href="/blog/2022/03/02/vue-component-communication/"/>
    <url>/blog/2022/03/02/vue-component-communication/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3父子组件通信方式"><a href="#Vue3父子组件通信方式" class="headerlink" title="Vue3父子组件通信方式"></a>Vue3父子组件通信方式</h1><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>本篇文章是全部采用的这种组合式API写法，相对于选项式来说，组合式API这种写法更加自由，具体可以参考Vue文档对两种方式的描述。</p><p>七种组件通信方式：</p><ul><li>props</li><li>emit</li><li>v-model</li><li>refs</li><li>provide&#x2F;inject</li><li>eventBus</li><li>vuex&#x2F;pinia(状态管理工具)</li></ul><h2 id="二-Props方式"><a href="#二-Props方式" class="headerlink" title="二.Props方式"></a>二.Props方式</h2><p><code>Props</code>方式是Vue中最常见的一种<strong>父传子</strong>的一种方式，使用也比较简单。</p><p>根据上面的demo，我们将数据以及对数据的操作定义在父组件，子组件仅做列表的一个渲染；</p><p>父组件代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">child-components</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-components</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-wrap input-group&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-group-append&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleAdd&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span><br>        添加<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponents</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-string">&#x27;CSS&#x27;</span>])</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-comment">// add 触发后的事件处理函数</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAdd</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  list.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(value.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">  value.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件只需要对父组件传递的值进行渲染即可，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent list-group&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;i in props.list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;i&quot;</span>&gt;</span>&#123;&#123; i &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; defineProps &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">list</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> [],</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三-emit方式"><a href="#三-emit方式" class="headerlink" title="三.emit方式"></a>三.emit方式</h2><p><code>emit</code>方式也是Vue中最常见的组件通信方式，该方式用于<strong>子传父</strong>；</p><p>根据上面的demo，我们将列表定义在父组件，子组件只需要传递添加的值即可。</p><p>子组件代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-wrap input-group&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-group-append&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSubmit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span><br>        添加<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, defineEmits &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> emits = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;add&#x27;</span>])</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">emits</span>(<span class="hljs-string">&#x27;add&#x27;</span>, value.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">  value.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在子组件中点击【添加】按钮后，<code>emit</code>一个自定义事件，并将添加的值作为参数传递。</p><p>父组件代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent list-group&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;i in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;i&quot;</span>&gt;</span>&#123;&#123; i &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">child-components</span> @<span class="hljs-attr">add</span>=<span class="hljs-string">&quot;handleAdd&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-components</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponents</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-string">&#x27;CSS&#x27;</span>])</span><br><span class="language-javascript"><span class="hljs-comment">// add 触发后的事件处理函数</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAdd</span> = value =&gt; &#123;</span><br><span class="language-javascript">  list.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(value)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在父组件中只需要监听子组件自定义的事件，然后执行对应的添加操作。</p><h2 id="四-v-model方式"><a href="#四-v-model方式" class="headerlink" title="四.v-model方式"></a>四.v-model方式</h2><p><code>v-model</code>是Vue中一个比较出色的语法糖，就比如下面这段代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> /&gt;</span><br><br></code></pre></td></tr></table></figure><p>就是下面这段代码的简写形势</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> @<span class="hljs-attr">update:title</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span> /&gt;</span><br><br></code></pre></td></tr></table></figure><p><code>v-model</code>确实简便了不少，现在我们就来看一下上面那个demo，如何用v-model实现。</p><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-wrap input-group&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-group-append&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleAdd&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span><br>        添加<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, defineEmits, defineProps &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">list</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> [],</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> emits = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;update:list&#x27;</span>])</span><br><span class="language-javascript"><span class="hljs-comment">// 添加操作</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAdd</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> arr = props.<span class="hljs-property">list</span></span><br><span class="language-javascript">  arr.<span class="hljs-title function_">push</span>(value.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">  <span class="hljs-title function_">emits</span>(<span class="hljs-string">&#x27;update:list&#x27;</span>, arr)</span><br><span class="language-javascript">  value.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在子组件中我们首先定义<code>props</code>和<code>emits</code>，然后添加完成之后<code>emit</code>指定事件。</p><blockquote><p>注：<code>update:*</code>是Vue中的固定写法，<code>*</code>表示<code>props</code>中的某个属性名。</p></blockquote><p>父组件中使用就比较简单，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent list-group&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;i in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;i&quot;</span>&gt;</span>&#123;&#123; i &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">child-components</span> <span class="hljs-attr">v-model:list</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-components</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponents</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-string">&#x27;CSS&#x27;</span>])</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="五-refs方式"><a href="#五-refs方式" class="headerlink" title="五.refs方式"></a>五.refs方式</h2><p>在使用选项式API时，我们可以通过<code>this.$refs.name</code>的方式获取指定元素或者组件，但是组合式API中就无法使用哪种方式获取。如果我们想要通过<code>ref</code>的方式获取组件或者元素，需要定义一个同名的Ref对象，在组件挂载后就可以访问了。</p><p>示例代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent list-group&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;i in childRefs?.list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;i&quot;</span>&gt;</span><br>      &#123;&#123; i &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 子组件 ref的值与&lt;script&gt;中的保持一致 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">child-components</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;childRefs&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-components</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponents</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> childRefs = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-wrap input-group&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-group-append&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleAdd&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span><br>        添加<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, defineExpose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-string">&#x27;CSS&#x27;</span>])</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-comment">// add 触发后的事件处理函数</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAdd</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  list.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(value.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">  value.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-title function_">defineExpose</span>(&#123; list &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>setup</code>组件默认是关闭的，也即通过模板<code>ref</code>获取到的组件的公开实例，不会暴露任何在<code>&lt;script setup&gt;</code>中声明的绑定。如果需要公开需要通过<code>defineExpose</code>API暴露。</p><h2 id="六-provide-inject方式"><a href="#六-provide-inject方式" class="headerlink" title="六.provide&#x2F;inject方式"></a>六.provide&#x2F;inject方式</h2><p><code>provide</code>和<code>inject</code>是Vue中提供的一对API，该API可以实现父组件向子组件传递数据，无论层级有多深，都可以通过这对API实现。示例代码如下所示：</p><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">child-components</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-components</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-wrap input-group&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-group-append&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleAdd&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span><br>        添加<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponents</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-string">&#x27;CSS&#x27;</span>])</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-comment">// 向子组件提供数据</span></span><br><span class="language-javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;list&#x27;</span>, list.<span class="hljs-property">value</span>)</span><br><span class="language-javascript"><span class="hljs-comment">// add 触发后的事件处理函数</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAdd</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  list.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(value.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">  value.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent list-group&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;i in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;i&quot;</span>&gt;</span>&#123;&#123; i &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-comment">// 接受父组件提供的数据</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;list&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的是使用<code>provide</code>进行数据传递时，尽量<code>readonly</code>进行数据的包装，避免子组件修改父级传递过去的数据。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue组件通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript箭头函数与普通函数的区别</title>
    <link href="/blog/2022/03/02/js-ArrowFunction-function/"/>
    <url>/blog/2022/03/02/js-ArrowFunction-function/</url>
    
    <content type="html"><![CDATA[<h1 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h1><h2 id="一-介绍箭头函数-Arrow-Function"><a href="#一-介绍箭头函数-Arrow-Function" class="headerlink" title="一.介绍箭头函数(Arrow Function)"></a>一.介绍箭头函数(Arrow Function)</h2><blockquote><p>ES6中允许使用“箭头”<strong>（&#x3D;&gt;）</strong> 来定义函数。箭头函数相当于匿名函数，并且简化了函数定义。</p></blockquote><p>我们来看一下如何使用 <strong>（&#x3D;&gt;）</strong> 来声明一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 箭头函数</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">foo</span> = (<span class="hljs-params">name</span>) =&gt; <span class="hljs-string">`我是<span class="hljs-subst">$&#123;name&#125;</span>`</span><br><span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;南玖&#x27;</span>) <span class="hljs-comment">// 我是南玖</span><br><br><span class="hljs-comment">// 等同于下面这个普通函数</span><br><span class="hljs-keyword">let</span> foo2 = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`我是<span class="hljs-subst">$&#123;name&#125;</span>`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数有两种格式，一种像上面的，只包含一个表达式，连<code>{ ... }</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>{ ... }</code>和<code>return</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">foo</span> = (<span class="hljs-params">name</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(name)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`我是<span class="hljs-subst">$&#123;name&#125;</span>`</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;前端南玖&#x27;</span><br>&#125;<br><span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;南玖&#x27;</span>) <span class="hljs-comment">// 我是南玖</span><br></code></pre></td></tr></table></figure><p>如果箭头函数返回的是一个字面量对象，则需要用括号包裹该字面量对象返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">foo</span> = (<span class="hljs-params">name</span>) =&gt; (&#123;<br>    name,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&#x27;front end&#x27;</span><br>&#125;)<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> foo2 = <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    name,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&#x27;front end&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二-箭头函数与普通函数的区别"><a href="#二-箭头函数与普通函数的区别" class="headerlink" title="二.箭头函数与普通函数的区别"></a>二.箭头函数与普通函数的区别</h2><p>我们可以通过打印箭头函数和普通函数来看看两者到底有什么区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = name =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>&#125;<br><span class="hljs-keyword">let</span> fn2 = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(fn) <span class="hljs-comment">// </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(fn2) <span class="hljs-comment">// </span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  fn</span><br><span class="hljs-title function_">fn</span>()<br><span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;fn&quot;</span><br><span class="hljs-attr">arguments</span>: (...)<br><span class="hljs-attr">caller</span>: (...)<br>[[<span class="hljs-title class_">FunctionLocation</span>]]: <span class="hljs-title class_">VM62</span>:<span class="hljs-number">1</span><br>[[<span class="hljs-title class_">Prototype</span>]]: ƒ ()<br><br><span class="hljs-comment">//  fn2</span><br><br>ƒ <span class="hljs-title function_">fn2</span>(name)<br><span class="hljs-attr">arguments</span>: <span class="hljs-literal">null</span><br><span class="hljs-attr">caller</span>: <span class="hljs-literal">null</span><br><span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;fn2&quot;</span><br><span class="hljs-attr">prototype</span>: &#123;<span class="hljs-attr">constructor</span>: ƒ&#125;<br>[[<span class="hljs-title class_">FunctionLocation</span>]]: <span class="hljs-title class_">VM62</span>:<span class="hljs-number">4</span><br>[[<span class="hljs-title class_">Prototype</span>]]: ƒ ()<br></code></pre></td></tr></table></figure><p>从打印结果来看，箭头函数与普通函数相比，缺少了<code>caller，arguments，prototype</code></p><h3 id="1-声明方式不同，匿名函数"><a href="#1-声明方式不同，匿名函数" class="headerlink" title="1.声明方式不同，匿名函数"></a>1.声明方式不同，匿名函数</h3><ul><li>声明一个普通函数需要使用关键字<code>function</code>来完成，并且使用<code>function</code>既可以声明成一个<strong>具名函数</strong>也可以声明成一个<strong>匿名函数</strong></li><li>声明一个箭头函数则只需要使用箭头就可以，无需使用关键字<code>function</code>，比普通函数声明更简洁。</li><li>箭头函数只能声明成<strong>匿名函数</strong>，但可以通过表达式的方式让箭头函数具名</li></ul><h3 id="2-this指向不同"><a href="#2-this指向不同" class="headerlink" title="2.this指向不同"></a>2.this指向不同</h3><p>对于普通函数来说，内部的<code>this</code>指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的<code>this</code>对象，内部的<code>this</code>就是定义时上层作用域中的<code>this</code>。也就是说，箭头函数内部的<code>this</code>指向是固定的，相比之下，普通函数的<code>this</code>指向是可变的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;南玖&#x27;</span><br><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;nanjiu&#x27;</span>,<br>    <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;say:&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;,<br>    <span class="hljs-attr">say2</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;say2:&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br>person.<span class="hljs-title function_">say</span>() <span class="hljs-comment">// say: nanjiu</span><br>person.<span class="hljs-title function_">say2</span>() <span class="hljs-comment">// say2: 南玖</span><br></code></pre></td></tr></table></figure><p>这里第一个<code>say</code>定义的是一个普通函数，并且它是作为对象<code>person</code>的方法来进行调用的，所以它的<code>this</code>指向的就是<code>person</code>，所以它应该会输出<code>say: nanjiu</code></p><p>而第二个<code>say2</code>定义的是一个箭头函数，我们知道箭头函数本身没有<code>this</code>，它的<code>this</code>永远指向它定义时所在的上层作用域，所以<code>say2</code>的<code>this</code>应该指向的是全局window，所以它会输出<code>say2: 南玖</code></p><p><strong>我们也可以通过<code>Babel</code> 转箭头函数产生的 <code>ES5</code> 代码来证明箭头函数没有自己的<code>this</code>，而是引用的上层作用域中<code>this</code>。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;id:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>  &#125;, <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">// ES5</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;id:&#x27;</span>, _this.<span class="hljs-property">id</span>);<br>  &#125;, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的<code>this</code>，而是引用的上层作用域中<code>this</code>。</p><h3 id="3-箭头函数的this永远不会变，call、apply、bind也无法改变"><a href="#3-箭头函数的this永远不会变，call、apply、bind也无法改变" class="headerlink" title="3.箭头函数的this永远不会变，call、apply、bind也无法改变"></a>3.箭头函数的this永远不会变，call、apply、bind也无法改变</h3><p>我们可以用call、apply、bind来改变普通函数的this指向，但是由于箭头函数的this指向在它定义时就已经确定了，永远指向它定义时的上层作用域中的this，所以使用这些方法永远也改变不了箭头函数<code>this</code>的指向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;南玖&#x27;</span><br><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;nanjiu&#x27;</span>,<br>    <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;say:&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;,<br>    <span class="hljs-attr">say2</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;say2:&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><br>person.<span class="hljs-property">say</span>.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;小明&#x27;</span>&#125;) <span class="hljs-comment">// say: 小明</span><br>person.<span class="hljs-property">say2</span>.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;小红&#x27;</span>&#125;) <span class="hljs-comment">// say2: 南玖</span><br></code></pre></td></tr></table></figure><p>还是上面那个例子，只不过我们在调用的时候使用<code>call</code>试图改变<code>this</code>指向，第一个<code>say</code>是一个普通函数，它经过call调用，打印出的是<code>say: 小明</code>，这说明普通函数的this已经改变了，第二个<code>say2</code>是一个箭头函数，它也经过call调用，但它打印出的仍然是<code>say2: 南玖</code>，这就能够证明<strong>箭头函数的this永远不会变，即使使用call、apply、bind也无法改变</strong></p><h3 id="4-箭头函数没有原型prototype"><a href="#4-箭头函数没有原型prototype" class="headerlink" title="4.箭头函数没有原型prototype"></a>4.箭头函数没有原型prototype</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = name =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>&#125;<br><span class="hljs-keyword">let</span> fn2 = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(fn2.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// &#123;constructor: ƒ&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-箭头函数不能当成一个构造函数"><a href="#5-箭头函数不能当成一个构造函数" class="headerlink" title="5.箭头函数不能当成一个构造函数"></a>5.箭头函数不能当成一个构造函数</h3><p>为什么箭头函数不能当成一个构造函数呢？我们先来用<code>new</code>调用一下看看会发生什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = name =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>&#125;<br><br><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;nanjiu&#x27;</span>)<br></code></pre></td></tr></table></figure><p>结果符合我们的预期，这样调用会报错。</p><p>我们知道new内部实现其实是分为以下四步：</p><ul><li>新建一个空对象</li><li>链接到原型</li><li>绑定this，执行构造函数</li><li>返回新对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 1.新建一个空对象</span><br><span class="hljs-keyword">let</span> obj = &#123;&#125;<br><span class="hljs-comment">// 2.获得构造函数</span><br><span class="hljs-keyword">let</span> con = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span><br><span class="hljs-comment">// 3.链接原型</span><br>obj.<span class="hljs-property">__proto__</span> = con.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-comment">// 4.绑定this，执行构造函数</span><br><span class="hljs-keyword">let</span> res = con.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>)<br><span class="hljs-comment">// 5.返回新对象</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span> ? res : obj<br>&#125;<br></code></pre></td></tr></table></figure><p>因为箭头函数没有自己的<code>this</code>，它的<code>this</code>其实是继承了外层执行环境中的<code>this</code>，且<code>this</code>指向永远不会变，并且箭头函数没有原型<code>prototype</code>，没法让他的实例的<code>__proto__</code>属性指向，所以箭头函数也就无法作为构造函数，否则用<code>new</code>调用时会报错！</p><h4 id="没有new-target"><a href="#没有new-target" class="headerlink" title="没有new.target"></a>没有new.target</h4><p><code>new</code>是从构造函数生成实例对象的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，这个属性一般用在构造函数中，返回<code>new</code>调用的那个构造函数。如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，所以这个属性可以用来确定构造函数是怎么调用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fn:&#x27;</span>,<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>)<br>&#125;<br><br><span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;nanjiu&#x27;</span>) <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;nanjiu&#x27;</span>) <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">fn: ƒ fn(name) &#123;</span><br><span class="hljs-comment">    console.log(&#x27;fn:&#x27;,new.target)</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn2</span> = (<span class="hljs-params">name</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fn2&#x27;</span>,<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>)<br>&#125;<br><span class="hljs-title function_">fn2</span>(<span class="hljs-string">&#x27;nan&#x27;</span>) <span class="hljs-comment">// 报错 Uncaught SyntaxError: new.target expression is not allowed here</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>new.target</code>属性一般用在构造函数中，返回<code>new</code>调用的那个构造函数</li><li>箭头函数的this指向全局对象，在箭头函数中使用<code>new.target</code>会报错</li><li>箭头函数的this指向普通函数，它的<code>new.target</code>就是指向该普通函数的引用</li></ul><h3 id="6-箭头函数没有自己的arguments"><a href="#6-箭头函数没有自己的arguments" class="headerlink" title="6.箭头函数没有自己的arguments"></a>6.箭头函数没有自己的arguments</h3><h4 id="箭头函数处于全局作用域中，则没有arguments"><a href="#箭头函数处于全局作用域中，则没有arguments" class="headerlink" title="箭头函数处于全局作用域中，则没有arguments"></a>箭头函数处于全局作用域中，则没有arguments</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = name =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>&#125;<br><span class="hljs-keyword">let</span> fn2 = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>&#125;<br><span class="hljs-title function_">fn2</span>() <span class="hljs-comment">// Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="hljs-title function_">fn</span>()  <span class="hljs-comment">// 报错 Uncaught ReferenceError: arguments is not defined</span><br></code></pre></td></tr></table></figure><p>还是用这两个函数来比较，普通函数能够打印出<code>arguments</code>，箭头函数使用<code>arguments</code>则会报错，因为箭头函数自身是没有arguments的，然后它会往上层作用域中去查找<code>arguments</code>，由于全局作用域中并没有定义<code>arguments</code>，所以会报错。</p><h4 id="箭头函数处于普通函数的函数作用域中，arguments则是上层普通函数的arguments"><a href="#箭头函数处于普通函数的函数作用域中，arguments则是上层普通函数的arguments" class="headerlink" title="箭头函数处于普通函数的函数作用域中，arguments则是上层普通函数的arguments"></a>箭头函数处于普通函数的函数作用域中，arguments则是上层普通函数的arguments</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fn2 = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fn2:&#x27;</span>,<span class="hljs-variable language_">arguments</span>)<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = name =&gt; &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fn:&#x27;</span>,<span class="hljs-variable language_">arguments</span>)<br>    &#125;<br>    <span class="hljs-title function_">fn</span>()<br>&#125;<br><span class="hljs-title function_">fn2</span>(<span class="hljs-string">&#x27;nanjiu&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这里两个函数打印的<code>arguments</code>相同，都是fn2函数的<code>arguments</code>。</p><h4 id="可以使用rest参数代替"><a href="#可以使用rest参数代替" class="headerlink" title="可以使用rest参数代替"></a>可以使用rest参数代替</h4><p>ES6 引入 <code>rest</code> 参数，用于获取函数不定数量的参数数组，这个API是用来替代<code>arguments</code>的，形式为<code>...变量名</code>，rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn3</span> = (<span class="hljs-params">a,...arr</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,arr) <span class="hljs-comment">//1, [2,3,4,5,6]</span><br>&#125;<br><br><span class="hljs-title function_">fn3</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p><strong>上面就是rest参数的基本用法，需要注意的是：</strong></p><ul><li><code>rest</code>参数只能作为函数的最后一个参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a, ...b, c</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数的<code>length</code>属性，不包括<code>rest</code>参数</li></ul><p><strong>rest参数与arguments的比较：</strong></p><ul><li>箭头函数和普通函数都可以使用<code>rest</code>参数，而<code>arguments</code>只能普通函数使用</li><li>接受参数<code>rest</code>比<code>arguments</code>更加灵活</li><li><code>rest</code>参数是一个真正的数组，而<code>arguments</code>是一个类数组对象，不能直接使用数组方法</li></ul><h3 id="7-箭头函数不能重复函数参数名称"><a href="#7-箭头函数不能重复函数参数名称" class="headerlink" title="7.箭头函数不能重复函数参数名称"></a>7.箭头函数不能重复函数参数名称</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">name,name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fn2:&#x27;</span>,name)<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn2</span> = (<span class="hljs-params">name,name</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fn&#x27;</span>,name)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;nan&#x27;</span>,<span class="hljs-string">&#x27;jiu&#x27;</span>) <span class="hljs-comment">// &#x27;jiu&#x27;</span><br><span class="hljs-title function_">fn2</span>(<span class="hljs-string">&#x27;nan&#x27;</span>,<span class="hljs-string">&#x27;jiu&#x27;</span>) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><h3 id="8-不可以使用yield命令，因此箭头函数不能用作-Generator-函数。"><a href="#8-不可以使用yield命令，因此箭头函数不能用作-Generator-函数。" class="headerlink" title="8.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。"></a>8.不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</h3><p>这个可能是由于历史原因哈，TC39 在 2013 年和 2016 年分别讨论过两次，从<code>*()</code>、<code>*=&gt;</code>、<code>=*&gt;</code>、<code>=&gt;*</code> 中选出了<code>=&gt;*</code>，勉强进入了 stage 1。而且因为有了<strong>异步生成器（async generator）</strong>，所以还得同时考虑**异步箭头生成器（async arrow generator）**的东西，之前生成器 99.999% 的用途都是拿它来实现<code>异步编程</code>，并不是真的需要生成器本来的用途，自从有了 <code>async/await</code>，<code>generator</code>生成器越来越没人用了。猜测可能是因为这个原因添加一个使用频率不高的语法，给规范带来较大的复杂度可能不值当。</p><h2 id="三-箭头函数不适用场景"><a href="#三-箭头函数不适用场景" class="headerlink" title="三.箭头函数不适用场景"></a>三.箭头函数不适用场景</h2><h3 id="对象方法，且方法中使用了this"><a href="#对象方法，且方法中使用了this" class="headerlink" title="对象方法，且方法中使用了this"></a>对象方法，且方法中使用了this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;南玖&#x27;</span><br><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;nanjiu&#x27;</span>,<br>    <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;say:&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;,<br>    <span class="hljs-attr">say2</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;say2:&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><br>person.<span class="hljs-title function_">say</span>() <span class="hljs-comment">// say: nanjiu</span><br>person.<span class="hljs-title function_">say2</span>() <span class="hljs-comment">//say2: 南玖</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>person.say2()</code>方法是一个箭头函数，调用<code>person.say2()</code>时，使得<code>this</code>指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致<code>say2()</code>箭头函数定义时的作用域就是全局作用域。而<code>say()</code>定义的是一个普通函数，它内部的this就指向调用它的那个对象，所以使用普通函数符合预期。</p><h3 id="当函数需要动态this时"><a href="#当函数需要动态this时" class="headerlink" title="当函数需要动态this时"></a>当函数需要动态this时</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.btn&#x27;</span>);<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;on&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这里很显然会报错，因为按钮点击的回调是一个箭头函数，而箭头函数内部的<code>this</code>永远都是指向它的上层作用域中的this，在这里就是<code>window</code>，所以会报错。这里只需要将箭头函数改成普通函数就能正常调用了！</p><h2 id="四-～练习"><a href="#四-～练习" class="headerlink" title="四.～练习"></a>四.～练习</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;南玖&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo2</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>),<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo3</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo4</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;nan&#x27;</span>)<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;jiu&#x27;</span>)<br><br>person1.<span class="hljs-title function_">foo1</span>() <span class="hljs-comment">// &#x27;nan&#x27;</span><br>person1.<span class="hljs-property">foo1</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// &#x27;jiu&#x27;</span><br><br>person1.<span class="hljs-title function_">foo2</span>() <span class="hljs-comment">// &#x27;nan&#x27;</span><br>person1.<span class="hljs-property">foo2</span>.<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// &#x27;nan&#x27;</span><br><br>person1.<span class="hljs-title function_">foo3</span>()() <span class="hljs-comment">// &#x27;南玖&#x27;</span><br>person1.<span class="hljs-property">foo3</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// &#x27;南玖&#x27;</span><br>person1.<span class="hljs-title function_">foo3</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// &#x27;jiu&#x27;</span><br><br>person1.<span class="hljs-title function_">foo4</span>()() <span class="hljs-comment">// &#x27;nan&#x27;</span><br>person1.<span class="hljs-property">foo4</span>.<span class="hljs-title function_">call</span>(person2)() <span class="hljs-comment">// &#x27;jiu&#x27;</span><br>person1.<span class="hljs-title function_">foo4</span>().<span class="hljs-title function_">call</span>(person2) <span class="hljs-comment">// &#x27;nan&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>全局代码执行，<code>person1 = new Person(&#39;nan&#39;),person2 = new Person(&#39;jiu&#39;)</code>执行完，<code>person1</code>中的<code>this.name</code>为<code>nan</code>，<code>person2</code>中的<code>this.name</code>为<code>jiu</code>，OK这一点清楚后，继续往下看：</p><ul><li>执行<code>person1.foo1()</code>，<code>foo1</code>为普通函数，所以this应该指向<code>person1</code>，打印出<code>nan</code></li><li>执行<code>person1.foo1.call(person2)</code>，<code>foo1</code>为普通函数，并且用call改变了this指向，所以它里面的this应该指向<code>person2</code>，打印出<code>jiu</code></li><li>执行<code>person1.foo2()</code>，<code>foo2</code>为箭头函数，它的this指向上层作用域，也就是person1，所以打印出<code>nan</code></li><li>执行<code>person1.foo2.call(person2)</code>，箭头函数的this指向无法使用call改变，所以它的this还是指向person1，打印出<code>nan</code></li><li>执行<code>person1.foo3()()</code>，这里先执行<code>person1.foo3()</code>，它返回了一个<strong>普通函数</strong>，接着再执行这个函数，此时就相当于在全局作用域中执行了一个普通函数，所以它的this指向window，打印出<code>南玖</code></li><li>执行<code>person1.foo3.call(person2)()</code>这个与上面类似，也是返回了一个<strong>普通函数</strong>再执行，其实前面的执行都不用关心，它也是相当于在全局作用域中执行了一个普通函数，所以它的this指向window，打印出<code>南玖</code></li><li>执行<code>person1.foo3().call(person2)</code>这里就是把foo3返回的<strong>普通函数</strong>的this绑定到person2上，所以打印出<code>jiu</code></li><li>执行<code>person1.foo4()()</code>，先执行<code>person1.foo4()</code>返回了一个<strong>箭头函数</strong>，再执行这个箭头函数，由于箭头函数的this始终指向它的上层作用域，所以打印出<code>nan</code></li><li>执行<code>person1.foo4.call(person2)()</code>，与上面类似只不过使用call把上层作用域的this改成了person2，所以打印出<code>jiu</code></li><li>执行<code>person1.foo4().call(person2)</code>，这里是先执行了<code>person1.foo4()</code>，返回了箭头函数，再试图通过call改变改变该箭头函数的this指向，上面我们说到<strong>箭头函数的this始终指向它的上层作用域</strong>，所以打印出<code>nan</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>箭头函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript宏任务和微任务</title>
    <link href="/blog/2022/02/21/js-eventLoop/"/>
    <url>/blog/2022/02/21/js-eventLoop/</url>
    
    <content type="html"><![CDATA[<h1 id="JS宏任务和微任务"><a href="#JS宏任务和微任务" class="headerlink" title="JS宏任务和微任务"></a>JS宏任务和微任务</h1><h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><p>了解宏任务和微任务之前，我们先了解一下事件循环和任务队列，还要需要知道的专业名词术语：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">synchronous：同步任务<br>asynchronous：异步任务<br>execution context stack：执行栈<br>heap：堆<br>stack：栈<br></code></pre></td></tr></table></figure><h4 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h4><p>​JavaScript 语言的一大特点就是单线程，同一个时间只能做一件事。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop 的方案应用而生。Event Loop 包含两类：一类是基于 [Browsing Context]，一种是基于 [Worker]。二者的运行是独立的，也就是说，每一个 JavaScript 运行的”线程环境”都有一个独立的 Event Loop，每一个 Web Worker 也有一个独立的 Event Loop。</p><h4 id="任务队列（task-queue-callback-queue）"><a href="#任务队列（task-queue-callback-queue）" class="headerlink" title="任务队列（task queue&#x2F;callback queue）"></a>任务队列（task queue&#x2F;callback queue）</h4><p>​根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。setTimeout&#x2F;Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。</p><h3 id="二-宏任务和微任务"><a href="#二-宏任务和微任务" class="headerlink" title="二.宏任务和微任务"></a>二.宏任务和微任务</h3><h4 id="1-宏任务（macro-task）"><a href="#1-宏任务（macro-task）" class="headerlink" title="1.宏任务（macro-task）"></a>1.宏任务（macro-task）</h4><p>​每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p><h5 id="宏任务包含："><a href="#宏任务包含：" class="headerlink" title="宏任务包含："></a>宏任务包含：</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">script(整体代码)<br>setTimeout<br>setInterval<br>I/O<br>UI交互事件<br>postMessage<br>MessageChannel<br>setImmediate(Node.js 环境)<br></code></pre></td></tr></table></figure><h4 id="2-微任务（micro-task）"><a href="#2-微任务（micro-task）" class="headerlink" title="2.微任务（micro-task）"></a>2.微任务（micro-task）</h4><p>​在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。</p><h5 id="微任务包含："><a href="#微任务包含：" class="headerlink" title="微任务包含："></a>微任务包含：</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">Promise.then<br>Object.observe<br>MutationObserver<br>process.nextTick(Node.js 环境)<br></code></pre></td></tr></table></figure><h4 id="3-运行机制"><a href="#3-运行机制" class="headerlink" title="3.运行机制"></a>3.运行机制</h4><p>JS引擎常驻于内存中，等待宿主将JS代码或函数传递给它。也就是等待宿主环境分配宏观任务，反复等待 - 执行即为事件循环。 </p><p>Event Loop中，每一次循环称为tick，每一次tick的任务如下：</p><blockquote><p>执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；<br>检查是否存在微任务，有则会执行至微任务队列为空；<br>如果宿主为浏览器，可能会渲染页面；<br>开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）。</p></blockquote><h4 id="4-实例代码"><a href="#4-实例代码" class="headerlink" title="4.实例代码"></a>4.实例代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise&#x27;</span>)<br>  <span class="hljs-title function_">resolve</span>()<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;then1&#x27;</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;then2&#x27;</span>)<br>  &#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;end&#x27;</span>)<br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//start </span><br><span class="hljs-comment">//promise</span><br><span class="hljs-comment">//end</span><br><span class="hljs-comment">//then1</span><br><span class="hljs-comment">//then2</span><br><span class="hljs-comment">//setTimeout</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>宏任务和微任务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中常见性能优化</title>
    <link href="/blog/2022/02/17/vue-code-optimize/"/>
    <url>/blog/2022/02/17/vue-code-optimize/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue中常见性能优化"><a href="#Vue中常见性能优化" class="headerlink" title="Vue中常见性能优化"></a>Vue中常见性能优化</h1><h3 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化:"></a>编码优化:</h3><p>1.不要将所有的数据都放在data中，data中的数据都会增加getter和setter，会收集对应的watcher；<br>2.vue 在 v-for 时给每项元素绑定事件需要用事件代理；<br>3.SPA 页面采用keep-alive缓存组件；<br>4.拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染 )；<br>5.v-if 当值为false时内部指令不会执行,具有阻断功能，很多情况下使用v-if替代v-show；<br>6.key 保证唯一性 ( 默认 vue 会采用就地复用策略 )；<br>7.Object.freeze 冻结数据；<br>8.合理使用路由懒加载、异步组件；<br>9.尽量采用runtime运行时版本；<br>10.数据持久化的问题 （防抖、节流）。</p><h3 id="Vue-加载性能优化"><a href="#Vue-加载性能优化" class="headerlink" title="Vue 加载性能优化:"></a>Vue 加载性能优化:</h3><p>1.第三方模块按需导入 ( babel-plugin-component )；<br>2.滚动到可视区域动态加载 ( <a href="https://tangbc.github.io/vue-virtual-scroll-list">https://tangbc.github.io/vue-virtual-scroll-list</a> )；<br>3.图片懒加载 (<a href="https://github.com/hilongjw/vue-lazyload.git)%E3%80%82">https://github.com/hilongjw/vue-lazyload.git)。</a></p><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验:"></a>用户体验:</h3><p>1.app-skeleton 骨架屏；<br>2.app-shell app壳 ；<br>3.pwa serviceworker。</p><h3 id="SEO-优化："><a href="#SEO-优化：" class="headerlink" title="SEO 优化："></a>SEO 优化：</h3><p>1.预渲染插件 prerender-spa-plugin；<br>2.务端渲染 ssr。</p><h3 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化:"></a>打包优化:</h3><p>1.使用 cdn 的方式加载第三方模块；<br>2.多线程打包 happypack splitChunks 抽离公共文件；<br>3.sourceMap 生成。</p><h3 id="缓存，压缩"><a href="#缓存，压缩" class="headerlink" title="缓存，压缩"></a>缓存，压缩</h3><p>1.客户端缓存、服务端缓存；<br>2.服务端 gzip 压缩</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件的生命周期</title>
    <link href="/blog/2022/02/17/vue-lifecycle/"/>
    <url>/blog/2022/02/17/vue-lifecycle/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue组件的生命周期"><a href="#Vue组件的生命周期" class="headerlink" title="Vue组件的生命周期"></a>Vue组件的生命周期</h1><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>​        beforeCreate–&gt;created–&gt;beforeMount–&gt;mounted–&gt;beforeUpdate–&gt;updated–&gt;beforeDestroy–&gt;destroyed</p><h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p>​        创建-&gt;挂载-&gt;更新-&gt;销毁</p><h3 id="beforeCreate【创建前-】"><a href="#beforeCreate【创建前-】" class="headerlink" title="beforeCreate【创建前 】"></a>beforeCreate【创建前 】</h3><p>​         在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据。</p><h3 id="created【创建后-】"><a href="#created【创建后-】" class="headerlink" title="created【创建后 】"></a>created【创建后 】</h3><p>​        实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch&#x2F;event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成</p><h3 id="beforeMount【挂载前】"><a href="#beforeMount【挂载前】" class="headerlink" title="beforeMount【挂载前】"></a>beforeMount【挂载前】</h3><p>​        挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。</p><h3 id="mounted【挂载后】"><a href="#mounted【挂载后】" class="headerlink" title="mounted【挂载后】"></a>mounted【挂载后】</h3><p>​       挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。</p><h3 id="beforeUpdate【更新前】"><a href="#beforeUpdate【更新前】" class="headerlink" title="beforeUpdate【更新前】"></a>beforeUpdate【更新前】</h3><p>​       在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程</p><h3 id="updated【更新后】"><a href="#updated【更新后】" class="headerlink" title="updated【更新后】"></a>updated【更新后】</h3><p>​        在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用</p><h3 id="beforeDestroy【销毁前】"><a href="#beforeDestroy【销毁前】" class="headerlink" title="beforeDestroy【销毁前】"></a>beforeDestroy【销毁前】</h3><p>​      在实例销毁之前调用，实例仍然完全可用，</p><ol><li>这一步还可以用this来获取实例，</li><li>一般在这一步做一些重置的操作，比如清除掉组件中的定时器  和 监听的dom事件</li></ol><h3 id="destroyed【销毁后】"><a href="#destroyed【销毁后】" class="headerlink" title="destroyed【销毁后】"></a>destroyed【销毁后】</h3><p>​      在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue生命周期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS grid布局</title>
    <link href="/blog/2022/02/17/css-grid/"/>
    <url>/blog/2022/02/17/css-grid/</url>
    
    <content type="html"><![CDATA[<h1 id="前端布局之Grid布局"><a href="#前端布局之Grid布局" class="headerlink" title="前端布局之Grid布局"></a>前端布局之Grid布局</h1><h4 id="1-网格布局方向"><a href="#1-网格布局方向" class="headerlink" title="1.网格布局方向"></a>1.网格布局方向</h4><p><code>display: grid</code>指定一个容器采用（纵向）网格布局</p><p><code>display: inline-grid</code>指定一个容器采用（横向）网格布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JS Bin<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">span</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-id">#container</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: grid;</span><br><span class="language-css">  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">50px</span> <span class="hljs-number">50px</span> <span class="hljs-number">50px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">50px</span> <span class="hljs-number">50px</span> <span class="hljs-number">50px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>;</span><br><span class="language-css">  <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#e5e4e9</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ef342a</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-2</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f68f26</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-3</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4ba946</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-4</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0376c2</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-5</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#c077af</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-6</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f8d29d</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-7</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#b5a87f</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-8</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#d0e4a9</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-9</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4dc7ec</span>;&#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>foo<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-4&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-5&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-6&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-7&quot;</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-8&quot;</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-9&quot;</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>bar<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-网格布局行和列"><a href="#2-网格布局行和列" class="headerlink" title="2.网格布局行和列"></a>2.网格布局行和列</h4><p><code>grid-template-columns</code>属性定义每一列的列<strong>宽</strong></p><p><code>grid-template-rows</code>属性定义每一行的行<strong>高</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JS Bin<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#container</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: grid;</span><br><span class="language-css">  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4em</span>;</span><br><span class="language-css">  <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#e5e4e9</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"> <span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ef342a</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-2</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f68f26</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-3</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4ba946</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-4</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0376c2</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-5</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#c077af</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-6</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f8d29d</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-7</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#b5a87f</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-8</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#d0e4a9</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-9</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4dc7ec</span>;&#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-4&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-5&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-6&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-7&quot;</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-8&quot;</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-9&quot;</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>（1）repeat()</strong></p><p><strong>（2）auto-fill 关键字</strong></p><p><strong>（3）fr 关键字</strong></p><p><strong>（4）minmax()</strong></p><p><strong>（5）auto 关键字</strong></p><h4 id="3-网格布局的行间距和列间距"><a href="#3-网格布局的行间距和列间距" class="headerlink" title="3.网格布局的行间距和列间距"></a>3.网格布局的行间距和列间距</h4><p><code>grid-row-gap</code>属性设置行与行的间隔（行间距）</p><p><code>grid-column-gap</code>属性设置列与列的间隔（列间距）</p><p><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JS Bin<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#container</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: grid;</span><br><span class="language-css">  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">grid-row</span>-<span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">grid-column</span>-<span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">    <span class="hljs-comment">/* grid-gap: 20px 20px; 简称 */</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4em</span>;</span><br><span class="language-css">  <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#e5e4e9</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"> <span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ef342a</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-2</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f68f26</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-3</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4ba946</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-4</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0376c2</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-5</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#c077af</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-6</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f8d29d</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-7</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#b5a87f</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-8</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#d0e4a9</span>;&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.item-9</span> &#123;<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4dc7ec</span>;&#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-4&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-5&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-6&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-7&quot;</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-8&quot;</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item item-9&quot;</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-网格布局的区域"><a href="#4-网格布局的区域" class="headerlink" title="4.网格布局的区域"></a>4.网格布局的区域</h4><p><code>grid-template-areas</code>属性用于定义区域</p><h4 id="5-网格布局的元素顺序"><a href="#5-网格布局的元素顺序" class="headerlink" title="5.网格布局的元素顺序"></a>5.网格布局的元素顺序</h4><p>默认的放置顺序是”先行后列”</p><p><code>grid-auto-flow</code>属性决定，默认值是<code>row</code>，即”先行后列”。也可以将它设成<code>column</code>，变成”先列后行”。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>grid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP协议和FTP协议</title>
    <link href="/blog/2022/02/17/tcp-ftp/"/>
    <url>/blog/2022/02/17/tcp-ftp/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP协议和FTP协议"><a href="#TCP协议和FTP协议" class="headerlink" title="TCP协议和FTP协议"></a>TCP协议和FTP协议</h1><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.<strong>定义</strong>：</h4><p>​传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 提出</p><h4 id="2-TCP-协议简述"><a href="#2-TCP-协议简述" class="headerlink" title="2.TCP 协议简述"></a>2.TCP 协议简述</h4><p>​TCP 提供面向有连接的通信传输，面向有连接是指在传送数据之前必须先建立连接，数据传送完成后要释放连接。</p><p>​无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP&#x2F;IP协议中，TCP协议提供可靠的连接服务，连接是通过<strong>三次握手</strong>进行初始化的。同时由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是<strong>全双工模式</strong>，所以需要<strong>四次挥手</strong>关闭连接。</p><h4 id="3-TCP-三次握手建立连接"><a href="#3-TCP-三次握手建立连接" class="headerlink" title="3.TCP 三次握手建立连接"></a>3.TCP 三次握手建立连接</h4><p>​所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个报文。</p><p>​三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p><p>​TCP 三次握手跟现实生活中的人与人打电话是很类似的：</p><blockquote><p>三次握手：<br>“喂，你听得到吗？”<br>“我听得到呀，你听得到我吗？”<br>“我能听到你，今天 balabala……”</p></blockquote><p>​经过三次的互相确认，大家就会认为对方对听的到自己说话，并且愿意下一步沟通，否则，对话就不一定能正常下去了。</p><h4 id="4-TCP-四次挥手关闭连接"><a href="#4-TCP-四次挥手关闭连接" class="headerlink" title="4.TCP 四次挥手关闭连接"></a>4.TCP 四次挥手关闭连接</h4><p>​四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p><p>​由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p><blockquote><p>客户端申请断开连接即FIN （我这边准备断开连接了）<br>服务端接收信息返回，表示我已经接收到（收到，请稍等，我这边准备一下）<br>客户端发送信息表示可以断开连接(我准备好了，你可以断开连接了）<br>服务端接受信息，返回数据表示已接受信息(好的，拜拜！）</p></blockquote><h3 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h3><h4 id="1-定义：-1"><a href="#1-定义：-1" class="headerlink" title="1.定义："></a>1.<strong>定义</strong>：</h4><p>​文件传输协议（File Transfer Protocol，FTP）是用于在[网络]上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程， 保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。</p><h4 id="2-传输方式"><a href="#2-传输方式" class="headerlink" title="2.传输方式"></a>2.传输方式</h4><p>​i.ASCII传输方式</p><p>​ii.二进制传输模式</p><h4 id="3-支持模式"><a href="#3-支持模式" class="headerlink" title="3.支持模式"></a>3.支持模式</h4><p>​FTP支持两种模式：Standard （PORT方式，主动方式），Passive （PASV，被动方式）。</p><h4 id="4-工作原理"><a href="#4-工作原理" class="headerlink" title="4.工作原理"></a>4.工作原理</h4><p>​FTP 采用 Internet 标准文件传输协议 FTP 的用户界面， 向用户提供了一组用来管理计算机之间文件传输的应用程序。</p><p>​FTP 是基于客户———服务器（C&#x2F;S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。</p><p>​开发任何基于 FTP 的客户端软件都必须遵循 FTP 的工作原理，FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接：</p><p>​一条是数据连接，用于数据传送；</p><p>​另一条是控制连接，用于传送控制信息（命令和响应）；</p><p>​这种将命令和数据分开传送的思想大大提高了 FTP 的效率，而其它客户服务器应用程序一般只有一条 TCP 连接。客户有三个构件：用户接口、客户控制进程和客户数据传送进程。服务器有两个构件：服务器控制进程和服务器数据传送进程。在整个交互的 FTP 会话中，控制连接始终是处于连接状态的，数据连接则在每一次文件传送时先打开后关闭。</p>]]></content>
    
    
    <categories>
      
      <category>browser</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FTP TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React基础-hooks</title>
    <link href="/blog/2022/02/17/react-hooks/"/>
    <url>/blog/2022/02/17/react-hooks/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Hooks-详解"><a href="#React-Hooks-详解" class="headerlink" title="React Hooks 详解"></a>React Hooks 详解</h1><h3 id="为什么会有Hooks？"><a href="#为什么会有Hooks？" class="headerlink" title="为什么会有Hooks？"></a>为什么会有Hooks？</h3><p>介绍Hooks之前，首先要给大家说一下React的组件创建方式，一种是类组件，一种是纯函数组件，并且React团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。也就是说组件的最佳写法应该是函数，而不是类。<br>但是我们知道，在以往开发中类组件和纯函数组件的区别是很大的，纯函数组件有着类组件不具备的多种特点，简单列举几条</p><ul><li>纯函数组件没有状态</li><li>纯函数组件没有生命周期</li><li>纯函数组件没有<code>this</code></li><li>只能是纯函数</li></ul><p>这就注定，我们所推崇的函数组件，只能做UI展示的功能，涉及到状态的管理与切换，我们不得不用类组件或者redux，但我们知道类组件的也是有缺点的，比如，遇到简单的页面，你的代码会显得很重，并且每创建一个类组件，都要去继承一个React实例，至于Redux,更不用多说，很久之前Redux的作者就说过，“能用React解决的问题就不用Redux”,等等一系列的话。关于React类组件redux的作者又有话说</p><blockquote><ul><li>大型组件很难拆分和重构，也很难测试。</li><li>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。</li><li>组件类引入了复杂的编程模式，比如 render props 和高阶组件。</li></ul></blockquote><p>下面我们用类组件做一个简单的计数器</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.PureComponent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>=&#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>  addcount = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> newCount = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">count</span>: newCount +=<span class="hljs-number">1</span><br>  &#125;)<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.addcount&#125;</span>&gt;</span>count++<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">AddCount</span><br></code></pre></td></tr></table></figure><p>可以看出来，上面的代码确实很重。<br>为了解决这种，<em>类组件功能齐全却很重，纯函数很轻便却有上文几点重大限制</em>，React团队设计了React Hooks<br><strong>React Hooks就是加强版的函数组件，我们可以完全不使用 <code>class</code>，就能写出一个全功能的组件</strong></p><h3 id="什么是Hooks"><a href="#什么是Hooks" class="headerlink" title="什么是Hooks?"></a>什么是Hooks?</h3><p>‘Hooks’的单词意思为“钩子”。<br>**React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。**而React Hooks 就是我们所说的“钩子”。<br>那么Hooks要怎么用呢？“你需要写什么功能，就用什么钩子”。对于常见的功能，React为我们提供了一些常用的钩子，当然有特殊需要，我们也可以写自己的钩子。下面是React为我们提供的默认的四种最常用钩子</p><blockquote><ul><li>useState()</li><li>userContext()</li><li>userReducer()</li><li>useEffect()</li></ul></blockquote><p>不同的钩子为函数引入不同的外部功能，我们发现上面四种钩子都带有<code>use</code>前缀，React约定，钩子<em>一律使用</em> <code>use</code>前缀命名。所以，你自己定义的钩子都要命名为useXXX。</p><h3 id="React-Hooks的用法"><a href="#React-Hooks的用法" class="headerlink" title="React Hooks的用法"></a>React Hooks的用法</h3><p>下面介绍四种默认钩子的用法</p><h5 id="一、userState-状态钩子"><a href="#一、userState-状态钩子" class="headerlink" title="一、userState():状态钩子"></a>一、userState():状态钩子</h5><p>我们知道，纯函数组件没有状态，<code>useState()</code>用于为函数组件引入状态。<br>下面我们使用Hooks重写上面的计数器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">AddCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [ count, setCount ] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">addcount</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> newCount = count<br>    <span class="hljs-title function_">setCount</span>(newCount+=<span class="hljs-number">1</span>)<br>  &#125; <br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;addcount&#125;</span>&gt;</span>count++<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">AddCount</span> <br></code></pre></td></tr></table></figure><p>通过上面的代码，我们实现了一个功能完全一样的计数器，代码看起来更加的轻便简洁，没有了继承，没有了渲染逻辑，没有了生命周期等。这就是hooks存在的意义。<br>在<code>useState()</code>中，它接受状态的初始值作为参数，即上例中计数的初始值，它返回一个数组，其中数组第一项为一个变量，指向状态的当前值。类似<code>this.state</code>,第二项是一个函数，用来更新状态,类似<code>setState</code>。该函数的命名，我们约定为<code>set</code>前缀加状态的变量名。</p><h5 id="二、useContext-共享状态钩子"><a href="#二、useContext-共享状态钩子" class="headerlink" title="二、useContext():共享状态钩子"></a>二、useContext():共享状态钩子</h5><p>该钩子的作用是，在组件之间共享状态。关于Context这里不再赘述，其作用就是可以做状态的分发，在React16.X以后支持，避免了react逐层通过Props传递数据。<br>下面是一个例子，现在假设有A组件和B组件需要共享一个状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs react">import React,&#123; useContext &#125; from &#x27;react&#x27;<br>const Ceshi = () =&gt; &#123;<br>  const AppContext = React.createContext(&#123;&#125;)<br>  const A =() =&gt; &#123;<br>    const &#123; name &#125; = useContext(AppContext)<br>    return (<br>        &lt;p&gt;我是A组件的名字&#123;name&#125;&lt;span&gt;我是A的子组件&#123;name&#125;&lt;/span&gt;&lt;/p&gt;<br>    )<br>&#125;<br>const B =() =&gt; &#123;<br>  const &#123; name &#125; = useContext(AppContext)<br>  return (<br>      &lt;p&gt;我是B组件的名字&#123;name&#125;&lt;/p&gt;<br>  )<br>&#125;<br>  return (<br>    &lt;AppContext.Provider value=&#123;&#123;name: &#x27;hook测试&#x27;&#125;&#125;&gt;<br>    &lt;A/&gt;<br>    &lt;B/&gt;<br>    &lt;/AppContext.Provider&gt;<br>  )<br>&#125;<br>export default Ceshi <br></code></pre></td></tr></table></figure><h5 id="三、useReducer-Action钩子"><a href="#三、useReducer-Action钩子" class="headerlink" title="三、useReducer():Action钩子"></a>三、useReducer():Action钩子</h5><p>我们知道，在使用React的过程中，如遇到状态管理，我们一般会用到Redux,而React本身是不提供状态管理的。而<code>useReducer()</code>为我们提供了状态管理。首先，关于redux我们都知道，其原理是我们通过用户在页面中发起action,从而通过reducer方法来改变state,从而实现页面和状态的通信。而Reducer的形式是<code>(state, action) =&gt; newstate</code>。类似，我们的<code>useReducer()</code>是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs react">const [state, dispatch] = useReducer(reducer, initialState)<br></code></pre></td></tr></table></figure><p>它接受reducer函数和状态的初始值作为参数，返回一个数组，其中第一项为<em>当前的</em>状态值，第二项为发送action的dispatch函数。下面我们依然用来实现一个计数器。<br>和redux一样，我们是需要通过页面组件发起action来调用reducer方法，从而改变状态，达到改变页面UI的这样一个过程。所以我们会先写一个Reducer函数，然后通过useReducer()返回给我们的state和dispatch来驱动这个数据流。思路就是这样，下面我们上代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,&#123;useReducer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">AddCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state, action</span>) =&gt;  &#123;<br> <span class="hljs-keyword">if</span>(action.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;&#x27;</span>add)&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>  ...state,<br>  <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> +<span class="hljs-number">1</span>,<br>  &#125;<br> &#125;<span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-keyword">return</span> state<br>  &#125;<br> &#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addcount</span> = (<span class="hljs-params"></span>) =&gt; &#123; <br>  <span class="hljs-title function_">dispatch</span>(&#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;add&#x27;</span><br>  &#125;)<br> &#125;<br><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">0</span>&#125;)<br><span class="hljs-keyword">return</span> (<br><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;addcount&#125;</span>&gt;</span>count++<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/&gt;</span></span><br>)<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">AddCount</span><br></code></pre></td></tr></table></figure><p>通过代码我们看到了，我们使用<code>useReducer()</code>代替了Redux的功能，但<code>useReducer</code>无法为我们提供中间件等功能，加入你有这些需求，还是需要用到redux。</p><h5 id="四、useEffect-副作用钩子"><a href="#四、useEffect-副作用钩子" class="headerlink" title="四、useEffect():副作用钩子"></a>四、useEffect():副作用钩子</h5><p>熟悉redux-saga的同学一定对<code>Effect</code>不陌生,它可以用来更好的处理副作用，如异步请求等，我们的<code>useEffect()</code>也是为函数组件提供了处理副作用的钩子。依然我们会把请求房子<code>componentDidMount</code>里面，在函数组件中我们可以使用<code>useEffect()</code>。其具体用法如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;,[array])<br></code></pre></td></tr></table></figure><p><code>useEffect()</code>接受两个参数，第一个参数是你要进行的异步操作，第二个参数是一个数组，用来给出Effect的依赖项。只要这个数组发生变化，<code>useEffect()</code>就会执行。当第二项省略不填时，<code>useEffect()</code>会在每次组件渲染时执行。这一点类似于类组件的<code>componentDidMount</code>。下面我们通过代码模拟一个异步加载数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">AsyncPage</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br><span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span> &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>)<br>    &#125;,<span class="hljs-number">5000</span>)<br>  &#125;)<br><span class="hljs-keyword">return</span> (<br>loading ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>异步请求完成<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">AsyncPage</span> <br></code></pre></td></tr></table></figure><p>上面的代码实现了一个异步加载，下面我们再做一个<code>useEffect()</code>依赖第二项数组变化的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs react">import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;<br><br>const AsyncPage = (&#123;name&#125;) =&gt; &#123;<br>const [loading, setLoading] = useState(true)<br>const [person, setPerson] = useState(&#123;&#125;)<br><br>  useEffect(() =&gt; &#123;<br>    setLoading(true)<br>    setTimeout(()=&gt; &#123;<br>      setLoading(false)<br>      setPerson(&#123;name&#125;)<br>    &#125;,2000)<br>  &#125;,[name])<br>  return (<br>    &lt;&gt;<br>      &#123;loading?&lt;p&gt;Loading...&lt;/p&gt;:&lt;p&gt;&#123;person.name&#125;&lt;/p&gt;&#125;<br>    &lt;/&gt;<br>  )<br>&#125;<br><br>const PersonPage = () =&gt;&#123;<br>  const [state, setState] = useState(&#x27;&#x27;)<br>  const changeName = (name) =&gt; &#123;<br>    setState(name)<br>  &#125;<br>  return (<br>    &lt;&gt;<br>      &lt;AsyncPage name=&#123;state&#125;/&gt;<br>      &lt;button onClick=&#123;() =&gt; &#123;changeName(&#x27;名字1&#x27;)&#125;&#125;&gt;名字1&lt;/button&gt;<br>      &lt;button onClick=&#123;() =&gt; &#123;changeName(&#x27;名字2&#x27;)&#125;&#125;&gt;名字2&lt;/button&gt;<br>    &lt;/&gt;<br>  )<br>&#125;<br><br>export default PersonPage <br></code></pre></td></tr></table></figure><p>上面代码中，通过改变传给<code>AsyncPage</code>的props,从而调用<code>useEffect()</code>。</p><h5 id="五、创建自己的Hooks"><a href="#五、创建自己的Hooks" class="headerlink" title="五、创建自己的Hooks"></a>五、创建自己的Hooks</h5><p>以上我们介绍了四种最常用的react提供给我们的默认React Hooks,有时候我们需要创建我们自己想要的Hooks,来满足更便捷的开发，在小编看来，无非就是根据业务场景对以上四种Hooks进行组装，从而得到满足自己需求的钩子。<br>比如，我们要将我们上面的代码功能封装成Hooks,代码如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">usePerson</span> = (<span class="hljs-params">name</span>) =&gt; &#123;<br><span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">const</span> [person, setPerson] = <span class="hljs-title function_">useState</span>(&#123;&#125;)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span> &#123;<br>      <span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>)<br>      <span class="hljs-title function_">setPerson</span>(&#123;name&#125;)<br>    &#125;,<span class="hljs-number">2000</span>)<br>  &#125;,[name])<br>  <span class="hljs-keyword">return</span> [loading,person]<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">AsyncPage</span> = (<span class="hljs-params">&#123;name&#125;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [loading, person] = <span class="hljs-title function_">usePerson</span>(name)<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        &#123;loading?<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;person.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>  &#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">PersonPage</span> = (<span class="hljs-params"></span>) =&gt;&#123;<br>  <span class="hljs-keyword">const</span> [state, setState]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">changeName</span> = (<span class="hljs-params">name</span>) =&gt; &#123;<br>    <span class="hljs-title function_">setState</span>(name)<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AsyncPage</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;state&#125;/</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;changeName(&#x27;名字1&#x27;)&#125;&#125;&gt;名字1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;changeName(&#x27;名字2&#x27;)&#125;&#125;&gt;名字2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">PersonPage</span> <br></code></pre></td></tr></table></figure><p>上面代码中，我们将之前的例子封装成了自己的Hooks,便于共享。其中，我们定义<code>usePerson()</code>为我们的自定义Hooks,它接受一个字符串，返回一个数组，数组中包括两个数据的状态，之后我们在使用<code>usePerson()</code>时，会根据我们传入的参数不同而返回不同的状态，然后很简便的应用于我们的页面中。</p><p>至此，关于React Hooks的讲解结束，它为我们带来了React翻天覆地的变化，也让我们感受到了React的未来，不过，假如你不会Hooks也是没有关系的。根据官方文档的话来说</p><blockquote><ul><li><strong>完全可选的。</strong> 你无需重写任何已有代码就可以在一些组件中尝试 Hook。但是如果你不想，你不必现在就去学习或使用 Hook。</li><li><strong>100% 向后兼容的。</strong> Hook 不包含任何破坏性改动。</li><li><strong>现在可用。</strong> Hook 已发布于 v16.8.0。</li><li><strong>没有计划从 React 中移除 class。</strong></li><li><strong>Hook 不会影响你对 React 概念的理解。</strong> 恰恰相反，Hook 为已知的 React 概念提供了更直接的 API：props， state，context，refs 以及生命周期。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript tree结构数据</title>
    <link href="/blog/2022/02/17/js-treeData/"/>
    <url>/blog/2022/02/17/js-treeData/</url>
    
    <content type="html"><![CDATA[<h1 id="tree结构数据"><a href="#tree结构数据" class="headerlink" title="tree结构数据"></a>tree结构数据</h1><h1 id="1-扁平数据转tree数据"><a href="#1-扁平数据转tree数据" class="headerlink" title="1.扁平数据转tree数据"></a>1.扁平数据转tree数据</h1><ul><li>首先，随意书写一段有关系的数据：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = [<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;马云&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">1</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;前端技术专家&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">2</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;首席科学家&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">1</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;前端架构师&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">3</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;前端工程师&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">4</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;前端菜鸟&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">5</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;前端小白&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">6</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;马岳父&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">8</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;QQ&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">8</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;微信&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">8</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;王者荣耀&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">8</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;绝地求生&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">8</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;QQ会员&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">13</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">9</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;QQ空间&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">14</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">9</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;QQ钱包&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">9</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;沙漠地图&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">12</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;公众号&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">17</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">10</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;群聊&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">10</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;小程序&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">19</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">10</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;花木兰&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">11</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;芈月&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">21</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">11</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;马可波罗&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">22</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">11</span> &#125;,<br>];<br></code></pre></td></tr></table></figure><ul><li>如何得到这样的层次结构数据？</li><li>我们一个一个来看；数据中的key代表当前数据的唯一标识，而parent则代表其父级。我们要做的就是：遍历data数组，根据parent和key的对应关系，生成tree数据，这里我们用children来装子数据。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//封装getTree方法，将数组转化为tree.</span><br><br><span class="hljs-keyword">import</span> &#123; cloneDeep &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<span class="hljs-comment">//lodash库里引入cloneDeep深克隆方法</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getTree</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br><br>  <span class="hljs-keyword">const</span> temp = <span class="hljs-title function_">cloneDeep</span>(data);<span class="hljs-comment">//深克隆一份外来数据data，以防下面的处理修改data本身</span><br>  <span class="hljs-keyword">const</span> parents = temp.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> !item.<span class="hljs-property">parent</span>); <span class="hljs-comment">//过滤出最高父集</span><br>  <span class="hljs-keyword">const</span> children = temp.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">parent</span>);<span class="hljs-comment">//过滤出孩子节点</span><br>  <br>  <span class="hljs-comment">//遍历孩子节点，根据孩子的parent从temp里面寻找对应的node节点，将孩子添加在node的children属性之中。</span><br>  children.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> node = temp.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> el.<span class="hljs-property">key</span> === item.<span class="hljs-property">parent</span>);<br>    node &amp;&amp; (node.<span class="hljs-property">children</span> ? node.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(item) : node.<span class="hljs-property">children</span> = [item]);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> parents;<span class="hljs-comment">//返回拼装好的数据。</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>封装好geTree方法，调用：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> tree=<span class="hljs-title function_">getTree</span>(data);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tree);<br></code></pre></td></tr></table></figure><ul><li>数组转tree的内容到这里就结束了。</li></ul><h1 id="2-tree数据转扁平数据"><a href="#2-tree数据转扁平数据" class="headerlink" title="2.tree数据转扁平数据"></a>2.tree数据转扁平数据</h1><ul><li>数组转tree会了，那接下来就是tree转数组了。</li><li>先随意定义一段数据：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> treeData = [<br>  &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;太极&quot;</span>,<br>    <span class="hljs-attr">key</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;两仪&quot;</span>,<br>        <span class="hljs-attr">key</span>: <span class="hljs-number">2</span>,<br>        <span class="hljs-attr">parent</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">children</span>: [<br>          &#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;老阳&quot;</span>,<br>            <span class="hljs-attr">key</span>: <span class="hljs-number">3</span>,<br>            <span class="hljs-attr">parent</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">children</span>: [&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;乾卦&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">3</span> &#125;],<br>          &#125;,<br>          &#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;少阳&quot;</span>,<br>            <span class="hljs-attr">key</span>: <span class="hljs-number">4</span>,<br>            <span class="hljs-attr">parent</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">children</span>: [<br>              &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;巽卦&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">4</span> &#125;,<br>              &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;兑卦&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">4</span> &#125;,<br>              &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;离卦&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">4</span> &#125;,<br>            ],<br>          &#125;,<br>          &#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;老阴&quot;</span>,<br>            <span class="hljs-attr">key</span>: <span class="hljs-number">5</span>,<br>            <span class="hljs-attr">parent</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">children</span>: [&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;坤卦&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">5</span> &#125;],<br>          &#125;,<br>          &#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;少阴&quot;</span>,<br>            <span class="hljs-attr">key</span>: <span class="hljs-number">6</span>,<br>            <span class="hljs-attr">parent</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">children</span>: [<br>              &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;艮卦&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">6</span> &#125;,<br>              &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;坎卦&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">13</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">6</span> &#125;,<br>              &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;震卦&quot;</span>, <span class="hljs-attr">key</span>: <span class="hljs-number">14</span>, <span class="hljs-attr">parent</span>: <span class="hljs-number">6</span> &#125;,<br>            ],<br>          &#125;,<br>        ],<br>      &#125;,<br>    ],<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><ul><li>子曰：“加我数年，五十以学易，可以无大过矣。”可见孔子对易经的推崇。以上数据是易经中太极到八卦演化过程，甚为奇妙，可以说宇宙万象皆在这演化规律之中：太极-&gt;两仪-&gt;四象-&gt;八卦。我们要做的就是将这一段tree形数据转化为扁平结构。话不多说，直接上才艺。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getFlatData</span>=(<span class="hljs-params">data</span>)=&gt;&#123;<br>    <span class="hljs-keyword">const</span> flatData=[];<br>    data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>      <span class="hljs-comment">//解构当前item,去掉item中的children，将纯净的node（不含children的单条数据）添加到flatData中。如果children存在就递归执行getFlatData方法，直至添加了所有。</span><br>        <span class="hljs-keyword">const</span> &#123;children,...node&#125;=item<br>        flatData.<span class="hljs-title function_">push</span>(node);<br>        children&amp;&amp;flagData.<span class="hljs-title function_">push</span>(...<span class="hljs-title function_">getFlatData</span>(children));<br>    &#125;)<br>    <span class="hljs-keyword">return</span> flatData;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>方法写好了，执行代码：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getFlatData</span>(treeData));<br></code></pre></td></tr></table></figure><ul><li>tree数据转扁平结构到这就结束了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP与HTTPS的区别</title>
    <link href="/blog/2022/02/16/http-https/"/>
    <url>/blog/2022/02/16/http-https/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h1><h3 id="一、HTTP和HTTPS的基本概念"><a href="#一、HTTP和HTTPS的基本概念" class="headerlink" title="一、HTTP和HTTPS的基本概念"></a>一、HTTP和HTTPS的基本概念</h3><p>　　HTTP：（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>　　HTTPS：（Hyper Text Transfer Protocol over SecureSocket Layer）是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h3 id="二、HTTP与HTTPS有什么区别？"><a href="#二、HTTP与HTTPS有什么区别？" class="headerlink" title="二、HTTP与HTTPS有什么区别？"></a>二、HTTP与HTTPS有什么区别？</h3><p>　　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>　　HTTPS和HTTP的区别主要如下：</p><p>　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="三、HTTPS的优点"><a href="#三、HTTPS的优点" class="headerlink" title="三、HTTPS的优点"></a><strong>三、HTTPS的优点</strong></h3><p>　　尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><p>　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h3 id="四、HTTPS的缺点"><a href="#四、HTTPS的缺点" class="headerlink" title="四、HTTPS的缺点"></a><strong>四、HTTPS的缺点</strong></h3><p>　　虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><p>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p><p>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p><p>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>　  （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p>]]></content>
    
    
    <categories>
      
      <category>browser</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React基础-jsx语法</title>
    <link href="/blog/2022/02/16/react-basic1/"/>
    <url>/blog/2022/02/16/react-basic1/</url>
    
    <content type="html"><![CDATA[<h1 id="React基础–-jsx语法"><a href="#React基础–-jsx语法" class="headerlink" title="React基础– jsx语法"></a>React基础– jsx语法</h1><h2 id="一、React-简介"><a href="#一、React-简介" class="headerlink" title="一、React 简介"></a>一、React 简介</h2><h3 id="1-关于-React"><a href="#1-关于-React" class="headerlink" title="1. 关于 React"></a>1. 关于 React</h3><blockquote><p>什么是 React ？</p></blockquote><p><strong>React</strong> 是一个用于构建用户界面的 JavaScript 库。</p><ul><li>是一个将数据渲染为 HTML 视图的开源 JS 库</li><li>它遵循基于组件的方法，有助于构建可重用的 UI 组件</li><li>它用于开发复杂的交互式的 web 和移动 UI</li></ul><blockquote><p>React 有什么特点？</p></blockquote><ol><li>使用虚拟 DOM 而不是真正的 DOM</li><li>它可以用服务器渲染</li><li>它遵循单向数据流或数据绑定</li><li>高效</li><li>声明式编码，组件化编码</li></ol><blockquote><p>React 的一些主要优点？</p></blockquote><ol><li>它提高了应用的性能</li><li>可以方便在客户端和服务器端使用</li><li>由于使用 JSX，代码的可读性更好</li><li>使用React，编写 UI 测试用例变得非常容易</li></ol><h3 id="2-Hello-React"><a href="#2-Hello-React" class="headerlink" title="2. Hello React"></a>2. Hello React</h3><p>首先需要引入几个 react 包，我直接用的是老师下载好的</p><ul><li>React 核心库、操作 DOM 的 react 扩展库、将 jsx 转为 js 的 babel 库</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello,React<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.test&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="3-虚拟-DOM-和真实-DOM-的两种创建方法"><a href="#3-虚拟-DOM-和真实-DOM-的两种创建方法" class="headerlink" title="3. 虚拟 DOM 和真实 DOM 的两种创建方法"></a>3. 虚拟 DOM 和真实 DOM 的两种创建方法</h3><h4 id="3-1-JS-创建虚拟-DOM"><a href="#3-1-JS-创建虚拟-DOM" class="headerlink" title="3.1 JS 创建虚拟 DOM"></a>3.1 JS 创建虚拟 DOM</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.创建虚拟DOM,创建嵌套格式的dom</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span>=<span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;h1&#x27;</span>,&#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;title&#x27;</span>&#125;,<span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>,&#123;&#125;,<span class="hljs-string">&#x27;hello,React&#x27;</span>))<br><span class="hljs-comment">//2.渲染虚拟DOM到页面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.test&#x27;</span>))<br></code></pre></td></tr></table></figure><h4 id="3-2-Jsx-创建虚拟DOM"><a href="#3-2-Jsx-创建虚拟DOM" class="headerlink" title="3.2 Jsx 创建虚拟DOM"></a>3.2 Jsx 创建虚拟DOM</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//1.创建虚拟DOM</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = (  <span class="hljs-comment">/* 此处一定不要写引号，因为不是字符串 */</span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Hello,React<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>)<br><span class="hljs-comment">//2.渲染虚拟DOM到页面</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.test&#x27;</span>))<br></code></pre></td></tr></table></figure><blockquote><p>js 的写法并不是常用的，常用jsx来写，毕竟JSX更符合书写的习惯</p></blockquote><h2 id="二、jsx-语法"><a href="#二、jsx-语法" class="headerlink" title="二、jsx 语法"></a>二、jsx 语法</h2><p> <strong>定义：JSX是一种JavaScript的语法扩展（eXtension），也在很多地方称之为JavaScript XML，因为看起来就是一段XML语法；</strong></p><ol><li>定义虚拟DOM，不能使用<code>“”</code></li><li>标签中混入JS表达式的时候使用<code>{}</code></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">id = &#123;myId.<span class="hljs-title function_">toUpperCase</span>()&#125;<br></code></pre></td></tr></table></figure><ol><li>样式的类名指定不能使用class，使用<code>className</code></li><li>内敛样式要使用<code>{{}}</code>包裹</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">style=&#123;&#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;skyblue&#x27;</span>,<span class="hljs-attr">fontSize</span>:<span class="hljs-string">&#x27;24px&#x27;</span>&#125;&#125;<br></code></pre></td></tr></table></figure><ol><li>不能有多个根标签，只能有一个根标签</li><li>标签必须闭合，自闭合也行</li><li>如果小写字母开头，就将标签转化为 html 同名元素，如果 html 中无该标签对应的元素，就报错；如果是大写字母开头，react 就去渲染对应的组件，如果没有就报错</li></ol><h4 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h4><p>写在花括号里</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>小丞<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    &#123;/*注释...*/&#125;</span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;example&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><h4 id="2-数组"><a href="#2-数组" class="headerlink" title="2. 数组"></a>2. 数组</h4><p>JSX 允许在模板中插入数组，数组自动展开全部成员</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> arr = [<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>小丞<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>,<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>同学<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>,<br>];<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;arr&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;example&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><h3 id="tip-JSX-小练习"><a href="#tip-JSX-小练习" class="headerlink" title="tip: JSX 小练习"></a>tip: JSX 小练习</h3><p>根据动态数据生成 <code>li</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> data = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>]<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VDOM</span> = (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">            &#123;</span><br><span class="language-xml">                data.map((item,index)=&gt;&#123;</span><br><span class="language-xml">                    return <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">                &#125;)</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="hljs-variable constant_">VDOM</span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.test&#x27;</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jsx语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue 指令的本质是什么?</title>
    <link href="/blog/2022/02/16/vue-command/"/>
    <url>/blog/2022/02/16/vue-command/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-指令的本质是什么？"><a href="#vue-指令的本质是什么？" class="headerlink" title="vue 指令的本质是什么？"></a>vue 指令的本质是什么？</h1><h3 id="1-用过哪些-vue-内置指令？"><a href="#1-用过哪些-vue-内置指令？" class="headerlink" title="1.用过哪些 vue 内置指令？"></a>1.用过哪些 vue 内置指令？</h3><p><strong>v-text</strong></p><p>相当于原生 js 中的 innerText。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;p v-text=&quot;msg1&quot;&gt;hello world&lt;/p&gt;<br>&lt;p&gt;&#123;&#123; msg2 &#125;&#125;&lt;/p&gt;<br>data() &#123;<br>  return &#123;<br>    msg: &#x27;hello lin&#x27;,<br>    msg2: &#x27;hell paul&#x27;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>v-html</strong></p><p>相当于原生 js 中的 innerHtml。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div v-html=&quot;htmlStr&quot;&gt;&lt;/div&gt;<br><br>data() &#123;<br>  return &#123;<br>    htmlStr: &#x27;&lt;div style=&quot;color: red&quot;&gt;hello world &lt;/div&gt;&#x27;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>v-pre</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;span v-pre&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;<br></code></pre></td></tr></table></figure><p>因为 vue 的插值语法为<code>&#123;&#123; &#125;&#125;</code>，所以 vue 提供了 v-pre 这个指令来显示原始 Mustache 标签。</p><p><strong>v-once</strong></p><p>只渲染元素和组件<strong>一次</strong>。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 单个元素 --&gt;<br>&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;/span&gt;<br>&lt;!-- 有子元素 --&gt;<br>&lt;div v-once&gt;<br>  &lt;h1&gt;comment&lt;/h1&gt;<br>  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;!-- 组件 --&gt;<br>&lt;my-component v-once :comment=&quot;msg&quot;&gt;&lt;/my-component&gt;<br>&lt;!-- `v-for` 指令--&gt;<br>&lt;ul&gt;<br>  &lt;li v-for=&quot;i in list&quot; v-once&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p><strong>v-cloak</strong></p><p>基本用不到，因为在单文件的开发模式下这个指令没用，在 html 里直接写模版的时候才需要用到，就不介绍了。</p><h3 id="2-vue-指令的本质是什么？"><a href="#2-vue-指令的本质是什么？" class="headerlink" title="2.vue 指令的本质是什么？"></a>2.vue 指令的本质是什么？</h3><blockquote><p>指令的本质是语法糖，或者说标志位。</p></blockquote><p>其实，vue 指令并不是很高大上的东西，它只是语法糖，或者说是标志位，是用来帮助我们简化代码的。</p><p>在 vue 的编译阶段，从 template 编译转化到 render 函数的过程中，会把这些指令编译成对应的 js 代码，实现对应的功能。</p><p>这也是为什么 jsx 不支持 vue 指令，需要配置 babel 插件<code>@vue/babel-preset-jsx</code> 和 <code>@vue/babel-helper-vue-jsx-merge-props</code> 才行，因为 jsx 本身也是语法糖，也是会被编译成 render 函数的。</p><h3 id="3-如何实现-vue-自定义指令？"><a href="#3-如何实现-vue-自定义指令？" class="headerlink" title="3.如何实现 vue 自定义指令？"></a>3.如何实现 vue 自定义指令？</h3><p>Vue 允许注册自定义指令，有全局注册和局部注册两种方式。</p><p><strong>注册全局指令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">Vue.directive(&#x27;focus&#x27;, &#123;<br>  inserted: function (el) &#123;<br>    el.focus()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>注册局部指令</strong></p><p>组件中接受一个 <code>directives</code> 的选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">directives: &#123;<br>  focus: &#123;<br>    inserted: function (el) &#123;<br>      el.focus()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> property，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input v-focus /&gt;<br></code></pre></td></tr></table></figure><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><ul><li>bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作，此时获取父节点为null。</li><li>inserted: 被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中），此时可以获取到父节点。</li><li>update: 所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</li><li>componentUpdated: 指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</li><li>unbind: 只调用一次， 指令与元素解绑时调用。</li></ul><p>我们通过下面这个例子来感受下这几个钩子函数的调用时机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button v-if=&quot;showBtn&quot; v-append-text=&quot;`hello $&#123;number&#125;`&quot; @click=&quot;number++&quot;&gt;按钮&lt;/button&gt;<br>&lt;button @click=&quot;showBtn = !showBtn&quot;&gt;销毁&lt;/button&gt;<br><br>data() &#123;<br>  return &#123;<br>     showBtn: true,<br>     number: 1<br>  &#125;<br>&#125;<br>directives: &#123;<br>  appendText: &#123;<br>    bind() &#123;<br>      console.log(&#x27;bind :&gt;&gt; &#x27;)<br>    &#125;,<br>    inserted(el, binding) &#123;<br>      el.appendChild(document.createTextNode(binding.value))<br>      console.log(&#x27;inserted :&gt;&gt; &#x27;, el, binding)<br>    &#125;,<br>    update() &#123;<br>      console.log(&#x27;update :&gt;&gt; &#x27;)<br>    &#125;,<br>    componentUpdated(el, binding) &#123;<br>      el.removeChild(el.childNodes[el.childNodes.length - 1])<br>      el.appendChild(document.createTextNode(binding.value))<br>      console.log(&#x27;componentUpdated :&gt;&gt; &#x27;)<br>    &#125;,<br>    unbind() &#123;<br>      console.log(&#x27;unbind :&gt;&gt; &#x27;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个指令 <code>v-append-text</code> 实现的功能是，向元素中插入 textNode。</p><h3 id="4-用过哪些自定义指令？"><a href="#4-用过哪些自定义指令？" class="headerlink" title="4.用过哪些自定义指令？"></a>4.用过哪些自定义指令？</h3><p>汇总一下我看到过或用过的比较好用的指令。</p><h4 id="cm-directives"><a href="#cm-directives" class="headerlink" title="cm-directives"></a><a href="https://link.juejin.cn/?target=https://github.com/Michael-lzg/v-directives">cm-directives</a></h4><ul><li><p>复制粘贴指令 v-copy</p></li><li><p>长按指令 v-longpress</p></li><li><p>输入框防抖指令 v-debounce</p></li><li><p>禁止表情及特殊字符 v-emoji</p></li><li><p>权限校验指令 v-premission</p></li><li><p>实现页面水印 v-waterMarker</p></li><li><p>拖拽指令 v-draggable</p></li></ul><p>这个库包含上面七个指令，可以选择 npm 安装 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/cm-directives">cm-directives</a>使用。</p><p>更建议 copy 一下这个库的指令代码到我们自己的项目，毕竟很多时候会改造一下，比如v-premission，一般要和自家的后端商量约定一下，其他指令 copy 下来可以直接用，这个库的 <a href="https://link.juejin.cn/?target=https://github.com/Michael-lzg/v-directives">README.md</a> 写得非常详细。</p><h4 id="v-loading-加载"><a href="#v-loading-加载" class="headerlink" title="v-loading 加载"></a><a href="https://link.juejin.cn/?target=https://element.eleme.cn/%23/zh-CN/component/loading">v-loading</a> 加载</h4><p><a href="https://link.juejin.cn/?target=https://element.eleme.cn/%23/zh-CN/component/loading">element-ui</a> 自带的指令，支持全屏和局部加载。</p><h4 id="v-track-埋点解决方案"><a href="#v-track-埋点解决方案" class="headerlink" title="v-track 埋点解决方案"></a><a href="https://link.juejin.cn/?target=https://github.com/l-hammer/v-track">v-track</a> 埋点解决方案</h4><p>v-track通过 Vue 自定义指令的方式将埋点代码与业务代码完全解耦~</p><h4 id="v-stickto-一个支持多DOM元素自动吸顶的vue指令"><a href="#v-stickto-一个支持多DOM元素自动吸顶的vue指令" class="headerlink" title="v-stickto 一个支持多DOM元素自动吸顶的vue指令"></a><a href="https://link.juejin.cn/?target=https://github.com/wormsan/vue-stickto">v-stickto</a> 一个支持多DOM元素自动吸顶的vue指令</h4><h4 id="v-lazyload-懒加载图片"><a href="#v-lazyload-懒加载图片" class="headerlink" title="v-lazyload 懒加载图片"></a><a href="https://link.juejin.cn/?target=https://www.cnblogs.com/lzq035/p/14183553.html">v-lazyload</a> 懒加载图片</h4><p>其实 img 标签是支持 lazy 属性的，就是兼容性不太好，所以一般懒加载还是要用支持懒加载的图片组件（比如<a href="https://link.juejin.cn/?target=https://element.eleme.cn/%23/zh-CN/component/image">element-ui</a>），或者写个指令来实现。</p><p>可以参考下这篇文章的 v-lazyload</p><p>这里还有别人总结的更多的指令，用起来会大大提高开发效率。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>vue 指令的本质是 语法糖，帮助我们简化代码和提高开发效率。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue 指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue2和vue3的双向数据绑定</title>
    <link href="/blog/2022/01/07/vue-v-model/"/>
    <url>/blog/2022/01/07/vue-v-model/</url>
    
    <content type="html"><![CDATA[<h1 id="vue2和vue3的双向数据绑定"><a href="#vue2和vue3的双向数据绑定" class="headerlink" title="vue2和vue3的双向数据绑定"></a>vue2和vue3的双向数据绑定</h1><h2 id="1-vue2"><a href="#1-vue2" class="headerlink" title="1.vue2"></a>1.vue2</h2><h4 id="基于Object-defineProperty-实现"><a href="#基于Object-defineProperty-实现" class="headerlink" title="基于Object.defineProperty()实现"></a>基于Object.defineProperty()实现</h4><blockquote><p>Object.defineProperty() 在一个对象上定义一个新的属性，或者修改这个对象上已经存在的属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, prop, desc)<br></code></pre></td></tr></table></figure><ol><li>obj: 目标对象</li><li>prop: 对象的key</li><li>desc: 属性描述</li></ol><h5 id="desc-参数为一个对象，里面的属性是"><a href="#desc-参数为一个对象，里面的属性是" class="headerlink" title="desc 参数为一个对象，里面的属性是"></a>desc 参数为一个对象，里面的属性是</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = &#123;&#125;<br><span class="hljs-keyword">let</span> backup = <span class="hljs-literal">null</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Person</span>, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-comment">// key 的值</span><br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否可写，默认false</span><br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否可枚举，是否可for in</span><br>    <span class="hljs-attr">configurable</span>: ture, <span class="hljs-comment">// 是否可配置，是否可删除等，默认fasle</span><br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 获取数据方法</span><br>        <span class="hljs-keyword">return</span> backup<br>    &#125;,<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>) &#123;  <span class="hljs-comment">// 更改方法，接受参数为新值</span><br>        backup = newVal<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>Object.defineProperty(obj, prop, desc)的vue双向数据绑定</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">vue</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span> = &#123;<br>        <span class="hljs-attr">testData</span>: <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = docunment.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">virtualDom</span> = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>()<br>&#125;<br>vue.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">observer</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> backup = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;<br>        backup = data[key] <span class="hljs-comment">// 先备份数据</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> backup === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observer</span>(backup)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, &#123;<br>                <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                    <span class="hljs-comment">// 依赖收集</span><br>                    <span class="hljs-keyword">return</span> backup <span class="hljs-comment">// 一定要return出去才可以</span><br>                &#125;,<br>                <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>) &#123;<br>                    backup = newVal<br>                    self.<span class="hljs-title function_">render</span>() <span class="hljs-comment">// 刷新视图</span><br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br>vue.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-title function_">functin</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">virtualDom</span> = <span class="hljs-string">&#x27;a test vue&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>.<span class="hljs-property">testData</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-property">innerHtml</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">virtualDom</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-vue3-基于Proxy"><a href="#2-vue3-基于Proxy" class="headerlink" title="2.vue3 基于Proxy"></a>2.vue3 基于Proxy</h2><h5 id="与Object-defineProperty-obj-prop-desc-方式相比有以下优势："><a href="#与Object-defineProperty-obj-prop-desc-方式相比有以下优势：" class="headerlink" title="与Object.defineProperty(obj, prop, desc)方式相比有以下优势："></a>与Object.defineProperty(obj, prop, desc)方式相比有以下优势：</h5><ol><li>丢掉麻烦的备份数据</li><li>省去for in 循环</li><li>可以监听数组变化</li><li>代码更简化</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">vue</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span> = &#123;<br>        <span class="hljs-attr">testData</span>: <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = docunment.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">virtualDom</span> = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>()<br>&#125;<br>vue.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">observer</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>, &#123;<br>        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, vceiver</span>) &#123;<br>            <span class="hljs-keyword">return</span> target[key]<br>        &#125;,<br>        <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, value, vceiver</span>) &#123;<br>            target[key] = value<br>            slef.<span class="hljs-title function_">render</span>()<br>        &#125;<br>    &#125;)<br>&#125;<br>vue.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-title function_">functin</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">virtualDom</span> = <span class="hljs-string">&#x27;a test vue&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>.<span class="hljs-property">testData</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>.<span class="hljs-property">innerHtml</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">virtualDom</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>v-model</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3+TS项目开发使用笔记</title>
    <link href="/blog/2022/01/07/vue3.0-mark/"/>
    <url>/blog/2022/01/07/vue3.0-mark/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3-TS项目开发使用笔记"><a href="#Vue3-TS项目开发使用笔记" class="headerlink" title="Vue3-TS项目开发使用笔记"></a>Vue3-TS项目开发使用笔记</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vue3出来已经有一段时间了，在团队中，也进行了大量的业务实践，也有了一些自己的思考。</p><p>总的来说，Vue3无论是在底层的原理上，还是在业务的实际开发中，都有了长足的进步。</p><p>使用 proxy 代替之前的 Object.defineProperty 的API，性能更加优异，也解决了之前vue在处理对象、数组上的缺陷；在diff算法上，使用了静态标记的方式，大大提升了Vue的执行效率。</p><p>在使用的层面，我们从options Api，变成了composition Api，慢慢的在实际的业务中，我们抛弃了原本的data、methods、computed那种隔离式的写法。compositon Api，它更加聚焦，它讲究的是相关业务的聚合性。同时，在composition Api中，为了防止过于重的业务逻辑，它提供了一种关注点分离的方式，大大的提升了我们代码的可读性。</p><p>完全良好的支持了TypeScript，类型校验也成为了以后Vue3进行大型项目开发的质量保障，同时这也是面向了趋势 – 前端的未来就是TypeScript！</p><h2 id="1、compositon-Api"><a href="#1、compositon-Api" class="headerlink" title="1、compositon Api"></a>1、compositon Api</h2><p>compositon Api的本质，体现在代码里面，也就是一个setup函数，在这个setup函数中，返回的数据，会用到该组件的模板中。return的这个对象，一定程度上，代表了之前vue2中的data属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineComponent, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Gift&#x27;</span>,<br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> &#123;<br>            counter<br>        &#125;<br>    &#125;<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><p>这时候，对于大多数初学者来说，可能存在的疑惑就是，那么我能不能定义options Api的写法，比如data、computed、watch、methods等等。</p><p>这里我需要明确的是，Vue3是完全兼容Vue2的这种options Api的写法，但是从理念上来说，更加推荐setup的方式，来写我们的组件。原因如下：Vue3的存在，本身是为了解决Vue2的问题的，Vue2的问题就是在于，聚合性不足，会导致代码越来越臃肿！setup的方式，能够让data、方法逻辑、依赖关系等聚合在一块，更方便维护。</p><p>也就是说，以后我们尽量不要写单独的data、computed、watch、methods等等，不是Vue3不支持，而是和Vue3的理念违背。</p><p>components属性，也就是一个组件的子组件，这个配置在Vue2和3的差异不大，Vue2怎么用，Vue3依然那么用。</p><h3 id="1、ref-和-reactive的区别？"><a href="#1、ref-和-reactive的区别？" class="headerlink" title="1、ref 和 reactive的区别？"></a>1、ref 和 reactive的区别？</h3><p>在功能方面，ref 和 reactive，都是可以实现响应式数据！</p><p>在语法层面，两个有差异。ref定义的响应式数据需要用[data].value的方式进行更改数据；reactive定义的数据需要[data].[prpoerty]的方式更改数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">actTitle</span>: <span class="hljs-title class_">Ref</span>&lt;string&gt; = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;活动名称&#x27;</span>);<br><br><span class="hljs-keyword">const</span> actData = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">list</span>: [],<br>    <span class="hljs-attr">total</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">curentPage</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">pageSize</span>: <span class="hljs-number">10</span><br>&#125;);<br><br>actTitle.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;活动名称2&#x27;</span>;<br><br>actData.<span class="hljs-property">total</span> = <span class="hljs-number">100</span>;<br>复制代码<br></code></pre></td></tr></table></figure><p>但是在应用的层面，还是有差异的，通常来说：单个的普通类型的数据，我们使用ref来定义响应式。表单场景中，描述一个表单的key:value这种对象的场景，使用reactive；在一些场景下，某一个模块的一组数据，通常也使用reactive的方式，定义数据。</p><p>那么，对象是不是非要使用reactive来定义呢？其实不是的，都可以，根据自己的业务场景，具体问题具体分析！ref他强调的是一个数据的value的更改，reactive强调的是定义的对象的某一个属性的更改。</p><h3 id="2、周期函数"><a href="#2、周期函数" class="headerlink" title="2、周期函数"></a>2、周期函数</h3><p>周期函数，在Vue3中，是被单独使用的，使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineComponent, ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Gift&#x27;</span>,<br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 处理业务，一般进行数据请求</span><br>        &#125;)<br>        <span class="hljs-keyword">return</span> &#123;<br>            counter<br>        &#125;<br>    &#125;<br>&#125;)<br><br>复制代码<br></code></pre></td></tr></table></figure><h3 id="3、store使用"><a href="#3、store使用" class="headerlink" title="3、store使用"></a>3、store使用</h3><p>在Vue2中，其实可以直接通过this.$store进行获取，但是在Vue3中，其实没有this这个概念，使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; defineComponent, ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Gift&#x27;</span>,<br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>();<br>        <span class="hljs-keyword">const</span> storeData = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store); <span class="hljs-comment">// 配合computed，获取store的值。</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            counter,<br>            storeData<br>        &#125;<br>    &#125;<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="4、router的使用"><a href="#4、router的使用" class="headerlink" title="4、router的使用"></a>4、router的使用</h3><p>在Vue2中，是通过this.$router的方式，进行路由的函数式编程，但是Vue3中，是这么使用的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; defineComponent, ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Gift&#x27;</span>,<br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>();<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;AddGift&quot;</span> &#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<br>            counter,<br>            onClick<br>        &#125;<br>    &#125;<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="2、关注点分离"><a href="#2、关注点分离" class="headerlink" title="2、关注点分离"></a>2、关注点分离</h2><p>关注点分离，应该分两层意思：第一层意思就是，Vue3的setup，本身就把相关的数据，处理逻辑放到一起，这就是一种关注点的聚合，更方便我们看业务代码。</p><p>第二层意思，就是当setup变的更大的时候，我们可以在setup内部，提取相关的一块业务，做到第二层的关注点分离。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; defineComponent, ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> useMerchantList <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./merchant.js&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Gift&#x27;</span>,<br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>();<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;AddGift&quot;</span> &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 在该示例中，我们把获取商家列表的相关业务分离出去。也就是下面的merchant.ts</span><br>        <span class="hljs-keyword">const</span> &#123;merchantList&#125; = <span class="hljs-title function_">useMerchantList</span>();<br>        <span class="hljs-keyword">return</span> &#123;<br>            counter,<br>            onClick,<br>            merchantList<br>        &#125;<br>    &#125;<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><p>merchant.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; getMerchantlist &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/api/rights/gift&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useMerchantList</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt; &#123;<br>  <span class="hljs-keyword">const</span> merchantList = <span class="hljs-title function_">ref</span>([]);<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchMerchantList</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getMerchantlist</span>(&#123;&#125;);<br>    merchantList.<span class="hljs-property">value</span> = res?.<span class="hljs-property">data</span>?.<span class="hljs-property">child</span>;<br>  &#125;;<br><br>  <span class="hljs-title function_">onMounted</span>(fetchMerchantList);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    merchantList<br>  &#125;;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="3、TypeScript支持"><a href="#3、TypeScript支持" class="headerlink" title="3、TypeScript支持"></a>3、TypeScript支持</h2><p>这一部分内容，准确的来说，是TS的内容，不过它与Vue3项目开发，息息相关，所以真的想用Vue3，我们还是得了解TS的使用。</p><p>不过这一部分，我不会介绍TS的基础语法，主要是在业务场景中，如何组织TS。</p><p>使用TS进行业务开发，一个核心的思维是，先关注数据结构，再根据数据结构进行页面开发。以前的前端开发模式是，先写页面，后关注数据。</p><p>比如要写一个礼品列表的页面，我们可能要定义这么一些interface。总而言之，我们需要关注的是：页面数据的interface、接口返回的数据类型、接口的入参类型等等。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 礼品创建、编辑、列表中的每一项，都会是这个数据类型。</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGiftItem</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">desc</span>: <span class="hljs-built_in">string</span>;<br>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-comment">// 全局相应的类型定义</span><br><span class="hljs-comment">// 而且一般来说，我们不确认，接口返回的类型到底是什么（可能是null、可能是对象、也可能是数组），所以使用范型来定义interface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRes</span>&lt;T&gt; &#123;<br>    <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">data</span>: T<br>&#125;<br><span class="hljs-comment">// 接口返回数据类型定义</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IGiftInfo</span> &#123;<br>    <span class="hljs-attr">list</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">IGiftItem</span>&gt;;<br>    <span class="hljs-attr">pageNum</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">pageSize</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">total</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>在一个常见的接口请求中，我们一般使用TS这么定义一个数据请求，数据请求的req类型，数据请求的res类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getGiftlist = (<br>  <span class="hljs-attr">params</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;<br>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">IRes</span>&lt;<span class="hljs-title class_">IGiftInfo</span>&gt;&gt; =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Http</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/apis/gift/list&quot;</span>, params);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript sort方法排序</title>
    <link href="/blog/2022/01/07/js-sort/"/>
    <url>/blog/2022/01/07/js-sort/</url>
    
    <content type="html"><![CDATA[<h1 id="javascript-sort方法排序"><a href="#javascript-sort方法排序" class="headerlink" title="javascript sort方法排序"></a>javascript sort方法排序</h1><h3 id="1-字母排序"><a href="#1-字母排序" class="headerlink" title="1.字母排序"></a>1.字母排序</h3><p>sort默认的排序方式为字母排序，根据二十六个字母依次排列，单词之间比较，则先比较第一个字母，如果第一个字母相同则比较第二个字母，以此类推。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1.字母排序（sort默认排序）</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;za&quot;</span>,<span class="hljs-string">&quot;zb&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;xc&quot;</span>,<span class="hljs-string">&quot;xa&quot;</span>];<br>arr.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br><span class="hljs-comment">// 运行结果：[&quot;a&quot;, &quot;b&quot;, &quot;xa&quot;, &quot;xc&quot;, &quot;za&quot;, &quot;zb&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="2-数字排序"><a href="#2-数字排序" class="headerlink" title="2.数字排序"></a>2.数字排序</h3><p>sort()中参数可以是方法函数，可以升序和降序输出结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//2.sort数字排序</span><br><span class="hljs-keyword">var</span> array = [<span class="hljs-number">100</span>,<span class="hljs-number">10</span>,<span class="hljs-number">50</span>,<span class="hljs-number">800</span>,<span class="hljs-number">320</span>,<span class="hljs-number">34</span>,<span class="hljs-number">53</span>];<br>array.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-comment">//a-b升序，b-a降序</span><br>    <span class="hljs-keyword">return</span> b-a;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array);<br><span class="hljs-comment">//运行结果：[800, 320, 100, 53, 50, 34, 10]</span><br></code></pre></td></tr></table></figure><p>**注意：**其中a,b都是表示这个数组里面的元素，如果是a-b则表示升序，如果是b-a则表示降序。</p><h3 id="3-数组对象排序"><a href="#3-数组对象排序" class="headerlink" title="3.数组对象排序"></a>3.数组对象排序</h3><p>最重要的还是这个对象属性排序，当后台给我们前端很多数据并且没有排序时，我们一般都是要重新进行排序，而后台给的数据往往是好几层，不会像前面那种简单的就一个数组，这个时候就要用sort中对象属性排序了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 3.对象属性排序</span><br><span class="hljs-keyword">var</span> obj = [<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;lucy&quot;</span>, <span class="hljs-attr">num</span>:<span class="hljs-number">400</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;nancy&quot;</span>, <span class="hljs-attr">num</span>:<span class="hljs-number">110</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;maria&quot;</span>, <span class="hljs-attr">num</span>:<span class="hljs-number">200</span>&#125;<br>];<br>obj.<span class="hljs-title function_">sort</span>(<span class="hljs-title function_">compare</span>(<span class="hljs-string">&quot;num&quot;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<br><br><span class="hljs-comment">//数组对象属性值排序</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">property</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<br>        <span class="hljs-comment">//value1 - value2升序</span><br>        <span class="hljs-comment">//value2 - value1降序</span><br>        <span class="hljs-keyword">var</span> value1 = a[property];<br>        <span class="hljs-keyword">var</span> value2 = b[property];<br>        <span class="hljs-keyword">return</span> value1 - value2;<span class="hljs-comment">//升序</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//[</span><br><span class="hljs-comment">// &#123;name:&quot;nancy&quot;, num:110&#125;,</span><br><span class="hljs-comment">// &#123;name:&quot;maria&quot;, num:200&#125;,</span><br><span class="hljs-comment">// &#123;name:&quot;lucy&quot;, num:400&#125;</span><br><span class="hljs-comment">//]</span><br></code></pre></td></tr></table></figure><p>**注意：**compare()中参数必须是这个对象的属性名称，而你要比较的这些对象里面，一定要有这个属性名称，否则会出错。</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sort()</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript数组的高级方法</title>
    <link href="/blog/2022/01/07/js-ArrayMthods/"/>
    <url>/blog/2022/01/07/js-ArrayMthods/</url>
    
    <content type="html"><![CDATA[<h1 id="javascript数组的高级方法"><a href="#javascript数组的高级方法" class="headerlink" title="javascript数组的高级方法"></a>javascript数组的高级方法</h1><h4 id="一-过滤方法-filter"><a href="#一-过滤方法-filter" class="headerlink" title="一.过滤方法 filter"></a>一.过滤方法 filter</h4><p><code>filter</code> 为数组中的每个元素调用一次 <code>callback</code> 函数，并利用所有使得 <code>callback</code> 返回 true 或<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">等价于 true 的值</a>的元素创建一个新数组。<code>callback</code> 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 <code>callback</code> 测试的元素会被跳过，不会被包含在新数组中。</p><blockquote><p>传入三个参数：</p><ol><li>元素的值（item）</li><li>元素的索引（index）</li><li>被遍历的数组本身（arr）</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// filter案例:过滤数组中大于五的数 </span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">24</span>];<br><span class="hljs-keyword">let</span> bigThanEightArr = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>) =&gt;</span> &#123; <br>    <span class="hljs-comment">// console.log(item, index, arr);</span><br>    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">6</span> <br>&#125;, <span class="hljs-variable language_">this</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bigThanEightArr); <span class="hljs-comment">//[8,10,24]</span><br></code></pre></td></tr></table></figure><h4 id="二-map方法"><a href="#二-map方法" class="headerlink" title="二.map方法"></a>二.map方法</h4><p><code>map</code> 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</p><blockquote><p>使用三个参数：<br>1.<code>currentValue</code>：callback数组中正在处理的当前元素。<br>2.<code>index</code>可选:<code>callback</code> 数组中正在处理的当前元素的索引。<br>3.<code>array</code>可选:<code>map</code> 方法调用的数组。<br>4.<code>thisArg</code>可选:执行 <code>callback</code> 函数时值被用作<code>this</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// map案例:将原数组每个元素都乘以2</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">24</span>];<br><span class="hljs-keyword">let</span> doubleArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, index, arr</span>) =&gt;</span> item * <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubleArr); <span class="hljs-comment">//[10, 12, 16, 20, 48]</span><br></code></pre></td></tr></table></figure><h4 id="三-reduce方法"><a href="#三-reduce方法" class="headerlink" title="三.reduce方法"></a>三.reduce方法</h4><p><code>reduce</code>为数组中的每一个元素依次执行<code>callback</code>函数，不包括数组中被删除或从未被赋值的元素。</p><blockquote><p>接受四个参数：<br>1.<code>accumulator</code>：累计器<br>2.<code>currentValue</code>：当前值<br>3.<code>currentIndex</code>：当前索引<br>4.<code>array</code>：数组</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：</span><br><span class="hljs-comment">//如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；</span><br><span class="hljs-comment">//如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。</span><br><br><span class="hljs-comment">//无原始参数（initialValue）</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>)&#123;<br>  <span class="hljs-keyword">return</span> accumulator + currentValue;<br>&#125;);<br><span class="hljs-comment">//10</span><br><br><span class="hljs-comment">//有原始参数</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> accumulator + currentValue<br>&#125;, <span class="hljs-number">10</span>)<br><span class="hljs-comment">//20</span><br><br></code></pre></td></tr></table></figure><h4 id="四-查找数组的元素，find方法"><a href="#四-查找数组的元素，find方法" class="headerlink" title="四.查找数组的元素，find方法"></a>四.查找数组的元素，find方法</h4><p><code>find()</code> 方法返回数组中满足提供的测试函数的<strong>第一个元素的值</strong>。否则返回 <code>undefined</code></p><blockquote><p>1.<code>callback</code></p><p>在数组每一项上执行的函数，接收 3 个参数：<code>element</code>当前遍历到的元素。<code>index</code>可选当   前遍历到的索引。<code>array</code>可选数组本身。<br>2.<code>thisArg</code>可选<br>执行回调时用作<code>this</code> 的对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">80</span>, <span class="hljs-number">12</span>];<br><span class="hljs-keyword">let</span> element = arr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">currentValue, index, arr</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> currentValue &gt; <span class="hljs-number">70</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element); <span class="hljs-comment">//80</span><br></code></pre></td></tr></table></figure><h4 id="五-查找数组元素的索引-findIndex"><a href="#五-查找数组元素的索引-findIndex" class="headerlink" title="五.查找数组元素的索引(findIndex)"></a>五.查找数组元素的索引(findIndex)</h4><p><code>indIndex()</code>方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。</p><blockquote><p>1.<code>callback</code></p><p>针对数组中的每个元素, 都会执行该回调函数, 执行时会自动传入下面三个参数:<code>element</code>当前元素。<code>index</code>当前元素的索引。<code>array</code>调用<code>findIndex</code>的数组。<br>2.<code>thisArg</code>可选<br>执行回调时用作<code>this</code> 的对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以下示例查找数组中素数的元素的索引（如果不存在素数，则返回-1）。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">element, index, array</span>) &#123;<br>      <span class="hljs-keyword">var</span> start = <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">while</span> (start &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(element)) &#123; <span class="hljs-comment">//获取平方根</span><br>        <span class="hljs-keyword">if</span> (element % start++ &lt; <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> element &gt; <span class="hljs-number">1</span>;<br>    &#125;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>].<span class="hljs-title function_">findIndex</span>(isPrime)); <span class="hljs-comment">// -1, not found</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">12</span>].<span class="hljs-title function_">findIndex</span>(isPrime)); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h4 id="六-some方法"><a href="#六-some方法" class="headerlink" title="六.some方法"></a>六.some方法</h4><p><code>some()</code> 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。</p><blockquote><p><code>callback</code></p><p>用来测试每个元素的函数，接受三个参数：</p><p>​<code>element</code>数组中正在处理的元素。</p><p>​<code>index</code> 可选数组中正在处理的元素的索引值。</p><p>​<code>array</code>可选<code>some()</code>被调用的数组。</p><p><code>thisArg</code>可选</p><p>执行 <code>callback</code> 时使用的 <code>this</code> 值。</p></blockquote><h5 id="1-测试数组元素的值"><a href="#1-测试数组元素的值" class="headerlink" title="1.测试数组元素的值"></a>1.测试数组元素的值</h5><p>下面的例子检测在数组中是否有元素大于 10。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isBiggerThan10</span>(<span class="hljs-params">element, index, array</span>) &#123;<br>  <span class="hljs-keyword">return</span> element &gt; <span class="hljs-number">10</span>;<br>&#125;<br><br>[<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">some</span>(isBiggerThan10);  <span class="hljs-comment">// false</span><br>[<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">some</span>(isBiggerThan10); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h5 id="2-使用箭头函数测试数组元素的值"><a href="#2-使用箭头函数测试数组元素的值" class="headerlink" title="2.使用箭头函数测试数组元素的值"></a>2.使用箭头函数测试数组元素的值</h5><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a> 可以通过更简洁的语法实现相同的用例.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">10</span>);  <span class="hljs-comment">// false</span><br>[<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">10</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h5 id="3-判断数组元素中是否存在某个值"><a href="#3-判断数组元素中是否存在某个值" class="headerlink" title="3 判断数组元素中是否存在某个值"></a>3 判断数组元素中是否存在某个值</h5><p>此例中为模仿 <code>includes()</code> 方法, 若元素在数组中存在, 则回调函数返回值为 <code>true</code> :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;mango&#x27;</span>, <span class="hljs-string">&#x27;guava&#x27;</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAvailability</span>(<span class="hljs-params">arr, val</span>) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">some</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">arrVal</span>) &#123;<br>    <span class="hljs-keyword">return</span> val === arrVal;<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">checkAvailability</span>(fruits, <span class="hljs-string">&#x27;kela&#x27;</span>);   <span class="hljs-comment">// false</span><br><span class="hljs-title function_">checkAvailability</span>(fruits, <span class="hljs-string">&#x27;banana&#x27;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h5 id="4-使用箭头函数判断数组元素中是否存在某个值"><a href="#4-使用箭头函数判断数组元素中是否存在某个值" class="headerlink" title="4 [使用箭头函数判断数组元素中是否存在某个值"></a>4 [使用箭头函数判断数组元素中是否存在某个值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;mango&#x27;</span>, <span class="hljs-string">&#x27;guava&#x27;</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkAvailability</span>(<span class="hljs-params">arr, val</span>) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">arrVal</span> =&gt;</span> val === arrVal);<br>&#125;<br><br><span class="hljs-title function_">checkAvailability</span>(fruits, <span class="hljs-string">&#x27;kela&#x27;</span>);   <span class="hljs-comment">// false</span><br><span class="hljs-title function_">checkAvailability</span>(fruits, <span class="hljs-string">&#x27;banana&#x27;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h5 id="5-将任意值转换为布尔类型"><a href="#5-将任意值转换为布尔类型" class="headerlink" title="5 [将任意值转换为布尔类型"></a>5 [将任意值转换为布尔类型</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-variable constant_">TRUTHY_VALUES</span> = [<span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;true&#x27;</span>, <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getBoolean</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-string">&#x27;use strict&#x27;</span>;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    value = value.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">trim</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">TRUTHY_VALUES</span>.<span class="hljs-title function_">some</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) &#123;<br>    <span class="hljs-keyword">return</span> t === value;<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">getBoolean</span>(<span class="hljs-literal">false</span>);   <span class="hljs-comment">// false</span><br><span class="hljs-title function_">getBoolean</span>(<span class="hljs-string">&#x27;false&#x27;</span>); <span class="hljs-comment">// false</span><br><span class="hljs-title function_">getBoolean</span>(<span class="hljs-number">1</span>);       <span class="hljs-comment">// true</span><br><span class="hljs-title function_">getBoolean</span>(<span class="hljs-string">&#x27;true&#x27;</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="七-every方法"><a href="#七-every方法" class="headerlink" title="七.every方法"></a>七.every方法</h4><p><code>every()</code> 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</p><ul><li><p><code>callback</code></p><p>用来测试每个元素的函数，它可以接收三个参数：<code>element</code>用于测试的当前值。<code>index</code>可选用于测试的当前值的索引。<code>array</code>可选调用 <code>every</code> 的当前数组。</p></li><li><p><code>thisArg</code></p><p>执行 <code>callback</code> 时使用的 <code>this</code> 值。</p></li></ul><h5 id="1检测所有数组元素的大小"><a href="#1检测所有数组元素的大小" class="headerlink" title="1检测所有数组元素的大小"></a>1检测所有数组元素的大小</h5><p>  下例检测数组中的所有元素是否都大于 10。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isBigEnough</span>(<span class="hljs-params">element, index, array</span>) &#123;<br>  <span class="hljs-keyword">return</span> element &gt;= <span class="hljs-number">10</span>;<br>&#125;<br>[<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].<span class="hljs-title function_">every</span>(isBigEnough);   <span class="hljs-comment">// false</span><br>[<span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].<span class="hljs-title function_">every</span>(isBigEnough); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h5 id="2-使用箭头函数"><a href="#2-使用箭头函数" class="headerlink" title="2 [使用箭头函数]"></a>2 [使用箭头函数]</h5><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>为上面的检测过程提供了更简短的语法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt;= <span class="hljs-number">10</span>); <span class="hljs-comment">// false</span><br>[<span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">130</span>, <span class="hljs-number">44</span>].<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt;= <span class="hljs-number">10</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高级函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常用命令</title>
    <link href="/blog/2022/01/07/linux-git/"/>
    <url>/blog/2022/01/07/linux-git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><h3 id="1-新建Gitee仓库"><a href="#1-新建Gitee仓库" class="headerlink" title="1.新建Gitee仓库"></a>1.新建Gitee仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init <br>git add . <span class="hljs-comment">#.代表所有文件都添加</span><br>git commit -m <span class="hljs-string">&quot;lyc&quot;</span>  <span class="hljs-comment">#引号里面是备注信息</span><br>git remote add origin https://gitee.com/RyanChaw/cnjy-parent.git <span class="hljs-comment">#https://gitee.com/RyanChaw/cnjy-parent.git 是刚刚复制的</span><br>git pull --rebase origin master<br>git push -u origin master<br></code></pre></td></tr></table></figure><h3 id="2-Git拉取代码"><a href="#2-Git拉取代码" class="headerlink" title="2.Git拉取代码"></a>2.Git拉取代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> <span class="hljs-string">&#x27;https://gitee.com/a937321983/blog.git&#x27;</span> <span class="hljs-comment"># 将远程仓库克隆到本地</span><br></code></pre></td></tr></table></figure><h3 id="3-提交代码"><a href="#3-提交代码" class="headerlink" title="3.提交代码"></a>3.提交代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;第一次提交&quot;</span><br>git pull origin 远程分支名  <span class="hljs-comment">#将远程的拉下来</span><br>git push origin master <span class="hljs-comment">#将远程的提交上去</span><br></code></pre></td></tr></table></figure><h3 id="4-git分支管理"><a href="#4-git分支管理" class="headerlink" title="4. git分支管理"></a>4. git分支管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch <span class="hljs-comment">#查看本地分支</span><br>git branch -a <span class="hljs-comment">#查看远程分支</span><br>git checkout 分支名 <span class="hljs-comment">#切换分支</span><br></code></pre></td></tr></table></figure><h3 id="5-查看文件的修改历史"><a href="#5-查看文件的修改历史" class="headerlink" title="5.查看文件的修改历史"></a>5.查看文件的修改历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git blame 文件名 <span class="hljs-comment"># 查看该文件的修改历史</span><br>git blame -L 100,10 文件名 <span class="hljs-comment"># 从100行开始，到110行 逐行查看文件的修改历史</span><br></code></pre></td></tr></table></figure><h3 id="6-清除"><a href="#6-清除" class="headerlink" title="6.清除"></a>6.清除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git clean -n <span class="hljs-comment"># 列出打算清除的档案(首先会对工作区的内容进行提示)</span><br>git clean -f <span class="hljs-comment"># 真正的删除</span><br>git clean -x -f <span class="hljs-comment"># 连.gitignore中忽略的档案也删除</span><br>git status -sb (sb是 short branch) <span class="hljs-comment"># 简洁的输出git status中的信息</span><br></code></pre></td></tr></table></figure><h3 id="7-查看提交信息"><a href="#7-查看提交信息" class="headerlink" title="7.查看提交信息"></a>7.查看提交信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git show HEAD <span class="hljs-comment"># 查看最后一次提交修改的详细信息 也可以用git show 哈希值 查看对应的内容</span><br>git show HEAD^ <span class="hljs-comment"># 查看倒数第二次的提交修改详细信息</span><br>git show HEAD^^ 或者git show HEAD~2 <span class="hljs-comment">#查看前2次变更</span><br>git show HEAD 或 git show 哈希值 或者git show tag(标签名) <span class="hljs-comment">#都可以查看最近一次提交的详细信息</span><br></code></pre></td></tr></table></figure><h3 id="8-回撤操作"><a href="#8-回撤操作" class="headerlink" title="8.回撤操作"></a>8.回撤操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit --amend -m <span class="hljs-string">&quot;提交信息&quot;</span> <span class="hljs-comment"># 回撤上一次提交并与本次工作区一起提交</span><br>git reset HEAD~2 --hard <span class="hljs-comment"># 回撤2步</span><br>git reset --files <span class="hljs-comment"># 从仓库回撤到暂存区</span><br>git reset HEAD <span class="hljs-comment"># 回撤暂存区内容到工作目录</span><br>git reset HEAD --soft <span class="hljs-comment">#回撤提交到暂存区</span><br>git reset HEAD --hard <span class="hljs-comment"># 回撤提交 放弃变更 (慎用)</span><br>git reset HEAD^  <span class="hljs-comment"># 回撤仓库最后一次提交</span><br>git reset --hard commitid <span class="hljs-comment"># 回撤到该次提交id的位置 回撤后本地暂存区可能有内容 本地仓库有要同步的内容 此时 丢弃掉暂存区的内容 并且强制将本地的内容推送至远程仓库 执行下面的命令 git push -u -f origin 分支名 这样就可以完全回撤到提交id的位置</span><br>git reset --soft commitid <span class="hljs-comment"># 回撤到该次提交id的位置 并将回撤内容保存在暂存区</span><br>git push -f -u origin 分支名 <span class="hljs-comment">#所有内容都回撤完了 将回撤后的操作强制推送到远程分支</span><br>git push origin/分支名 --force <span class="hljs-comment">#强制将本地回撤后的操作 强制推送到远程分支</span><br></code></pre></td></tr></table></figure><h3 id="9-查看全部git子命令"><a href="#9-查看全部git子命令" class="headerlink" title="9.查看全部git子命令"></a>9.查看全部git子命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git helper -a <br></code></pre></td></tr></table></figure><h3 id="10-新增、删除本地分支"><a href="#10-新增、删除本地分支" class="headerlink" title="10.新增、删除本地分支"></a>10.新增、删除本地分支</h3><p>1.创建新分支<br>使用 git branch 或 git checkout -b 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch &lt;新分支名&gt;      <span class="hljs-comment"># 仅创建分支，不切换</span><br>git checkout -b &lt;新分支名&gt; <span class="hljs-comment"># 创建并立即切换到新分支</span><br></code></pre></td></tr></table></figure><p>2.删除本地分支（谨慎操作）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d &lt;分支名&gt;  <span class="hljs-comment"># 删除已合并的分支</span><br>git branch -D &lt;分支名&gt;  <span class="hljs-comment"># 强制删除未合并的分支</span><br></code></pre></td></tr></table></figure><h3 id="11-合并分支"><a href="#11-合并分支" class="headerlink" title="11. 合并分支"></a>11. 合并分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将 feature-branch 分支合并到当前分支（main）</span><br>git merge feature-branch<br><br><span class="hljs-comment"># 禁用快进合并（强制创建合并提交）</span><br>git merge --no-ff feature-branch<br></code></pre></td></tr></table></figure><p>快进合并（Fast-Forward）：当目标分支领先于源分支时，Git直接移动指针，无额外提交。<br>–no-ff：即使可以快进也强制创建合并提交，保留分支历史（适合团队协作记录）。</p>]]></content>
    
    
    <categories>
      
      <category>common</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript 闭包</title>
    <link href="/blog/2021/12/28/js-closure/"/>
    <url>/blog/2021/12/28/js-closure/</url>
    
    <content type="html"><![CDATA[<h1 id="JS闭包"><a href="#JS闭包" class="headerlink" title="JS闭包"></a>JS闭包</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1.可以在函数的外部访问到函数内部的局部变量。 </p><p>2.让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>请看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Mozilla&quot;</span>; <span class="hljs-comment">// name 是一个被 init 创建的局部变量</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">displayName</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// displayName() 是内部函数，一个闭包</span><br>        <span class="hljs-title function_">alert</span>(name); <span class="hljs-comment">// 使用了父函数中声明的变量</span><br>    &#125;<br>    <span class="hljs-title function_">displayName</span>();<br>&#125;<br><span class="hljs-title function_">init</span>();<br></code></pre></td></tr></table></figure><p> <code>init()</code> 创建了一个局部变量 <code>name</code> 和一个名为 <code>displayName()</code> 的函数。<br> <code>displayName()</code> 是定义在 <code>init()</code> 里的内部函数，并且仅在 <code>init()</code> 函数体内可用。<br> 请注意，<code>displayName()</code> 没有自己的局部变量。<br> 然而，因为它可以访问到外部函数的变量，所以 <code>displayName()</code> 可以使用父函数 <code>init()</code> 中声明的变量 <code>name</code> 。</p><p>一个有意思的示例 — 一个 <code>makeAdder</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeAdder</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> add5 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> add10 = <span class="hljs-title function_">makeAdder</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add5</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 7</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add10</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-call、apply、bind函数</title>
    <link href="/blog/2021/12/27/js-function/"/>
    <url>/blog/2021/12/27/js-function/</url>
    
    <content type="html"><![CDATA[<h1 id="js-call、apply、bind函数"><a href="#js-call、apply、bind函数" class="headerlink" title="js-call、apply、bind函数"></a>js-call、apply、bind函数</h1><p>函数上下文的三个方法：call()  、 apply()  、 bind() ,他们定义在Function构造函数中，函数执行上下文模，作用可以修改this指向。异同点：都可以修改函数中的this指向，不同点：传参方式不同</p><h3 id="1-bind-函数实现"><a href="#1-bind-函数实现" class="headerlink" title="1.bind()函数实现"></a>1.bind()函数实现</h3><p>bind()语法并不会立即执行函数，而是返回一个修改指向后的新函数，</p><p>常用于回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-keyword">var</span> target = target || <span class="hljs-variable language_">window</span>;<br>    <span class="hljs-keyword">var</span> _args1 = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br>    <span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> _args2 = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">var</span> parasArr = _args1.<span class="hljs-title function_">concat</span>(_args2);<br>        <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> temp ? <span class="hljs-variable language_">this</span> : target, parasArr)<br>    &#125;<br>    temp.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = self.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">temp</span>();<br>    <span class="hljs-keyword">return</span> F;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-call-函数实现"><a href="#2-call-函数实现" class="headerlink" title="2.call()函数实现"></a>2.call()函数实现</h3><p>​call：函数名.call（this修改后的指向,参数1，参数2….）</p><p>​    适用于只有（<em><strong>一个参数</strong></em>）的函数</p><p>​    应用场景：伪数组排序、检测数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> ctx = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] || <span class="hljs-variable language_">window</span>;<br>    ctx.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">var</span> args = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        args.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">arguments</span>[i])<br>    &#125;<br>    <span class="hljs-keyword">var</span> result = ctx.<span class="hljs-title function_">fn</span>(...args);<br>    <span class="hljs-keyword">delete</span> ctx.<span class="hljs-property">fn</span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-apply-函数实现"><a href="#3-apply-函数实现" class="headerlink" title="3.apply()函数实现"></a>3.apply()函数实现</h3><p>apply() ：函数名：apply(this修改后的指向,伪数组&#x2F;数组)</p><p>适用于（<em><strong>多个传参</strong></em>）的函数</p><p>应用场景：伪数转真数组、求数组最大值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> ctx = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] || <span class="hljs-variable language_">window</span>;<br>    ctx.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">var</span> result = ctx.<span class="hljs-title function_">fn</span>();<br>        <span class="hljs-keyword">delete</span> ctx.<span class="hljs-property">fn</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">var</span> result = ctx.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">delete</span> ctx.<span class="hljs-property">fn</span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>call、apply、bind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript十大排序</title>
    <link href="/blog/2021/12/20/js-tenSort/"/>
    <url>/blog/2021/12/20/js-tenSort/</url>
    
    <content type="html"><![CDATA[<h1 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h1><h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1.冒泡排序（Bubble Sort）"></a>1.冒泡排序（Bubble Sort）</h3><h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="(1)算法描述"></a>(1)算法描述</h4><blockquote><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p></blockquote><h4 id="2-算法描述和实现"><a href="#2-算法描述和实现" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>具体算法描述如下：</p><ul><li>&lt;1&gt;.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>&lt;2&gt;.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>&lt;3&gt;.针对所有的元素重复以上的步骤，除了最后一个；</li><li>&lt;4&gt;.重复步骤1~3，直到排序完成。</li></ul><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="(3)代码实现"></a>(3)代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">var</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//相邻元素两两对比</span><br>                <span class="hljs-keyword">var</span> temp = arr[j+<span class="hljs-number">1</span>];<span class="hljs-comment">//元素交换</span><br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2.选择排序（Selection Sort）"></a>2.选择排序（Selection Sort）</h3><h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></blockquote><h4 id="2-算法描述和实现-1"><a href="#2-算法描述和实现-1" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>&lt;1&gt;.初始状态：无序区为R[1..n]，有序区为空；</li><li>&lt;2&gt;.第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>&lt;3&gt;.n-1趟结束，数组有序化了。</li></ul><h4 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="(3)代码实现"></a>(3)代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectionSort</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">var</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">var</span> minIndex, temp;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;选择排序耗时&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>        minIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<span class="hljs-comment">//寻找最小的数</span><br>                minIndex = j;<span class="hljs-comment">//将最小数的索引保存</span><br>            &#125;<br>        &#125;<br>        temp = arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;选择排序耗时&#x27;</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3.插入排序（Insertion Sort）"></a>3.插入排序（Insertion Sort）</h3><h4 id="1-算法简介-1"><a href="#1-算法简介-1" class="headerlink" title="(1)算法简介"></a>(1)算法简介</h4><blockquote><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p></blockquote><h4 id="2-算法描述和实现-2"><a href="#2-算法描述和实现-2" class="headerlink" title="(2)算法描述和实现"></a>(2)算法描述和实现</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>&lt;1&gt;.从第一个元素开始，该元素可以认为已经被排序；</li><li>&lt;2&gt;.取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>&lt;3&gt;.如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>&lt;4&gt;.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>&lt;5&gt;.将新元素插入到该位置后；</li><li>&lt;6&gt;.重复步骤2~5。</li></ul><h4 id="3-代码实现-2"><a href="#3-代码实现-2" class="headerlink" title="(3)代码实现"></a>(3)代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(array).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;Array&#x27;</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">var</span> key = array[i];<br>            <span class="hljs-keyword">var</span> j = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; array[j] &gt; key) &#123;<br>                array[j + <span class="hljs-number">1</span>] = array[j];<br>                j--;<br>            &#125;<br>            array[j + <span class="hljs-number">1</span>] = key;<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;array is not an Array!&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript基础</title>
    <link href="/blog/2021/12/20/js-basics/"/>
    <url>/blog/2021/12/20/js-basics/</url>
    
    <content type="html"><![CDATA[<h1 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h1><h3 id="与"><a href="#与" class="headerlink" title="&#x3D;&#x3D;&#x3D;与&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;与&#x3D;&#x3D;</h3><p> &#x3D;&#x3D; 自动转换数据类型再比较；<br> &#x3D;&#x3D;&#x3D; 不转换类型  （更好）<br> 例外：<br> NaN &#x3D;&#x3D;&#x3D; NaN  &#x2F;&#x2F; false</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>使用反引号来表示多行字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">`这是一个</span><br><span class="hljs-string">多行</span><br><span class="hljs-string">字符串`</span>;<br></code></pre></td></tr></table></figure><p>字符串不可变：使用<code>a[0] = &#39;X&#39;</code>并没有改变效果</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>直接给array的length赋新值会改变Array的大小;<br> length变大则新增元素为undefined;变小则删除超出长度的元素;</p><p>数组方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">slice   <span class="hljs-comment">// 不加参数可以用于复制数组，不改变本身</span><br>pop<br>push<br>unshift <span class="hljs-comment">// 在头部添加</span><br>shift   <span class="hljs-comment">// 在头部删除</span><br>sort    <span class="hljs-comment">// 字母排序</span><br>reverse <span class="hljs-comment">// 反转</span><br>splice  <span class="hljs-comment">// 从指定索引删除若干元素，在从该位置添加若干元素</span><br>concat  <span class="hljs-comment">// 拼接,返回新Array</span><br>join    <span class="hljs-comment">// 使用指定字符拼接数组元素 ==&gt; String</span><br></code></pre></td></tr></table></figure><h3 id="Map-键值对结构，大数据量时具有极快的查找速度"><a href="#Map-键值对结构，大数据量时具有极快的查找速度" class="headerlink" title="Map 键值对结构，大数据量时具有极快的查找速度"></a>Map 键值对结构，大数据量时具有极快的查找速度</h3><p>根据key值迅速获取对应value</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">95</span>], [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">75</span>], [<span class="hljs-string">&#x27;Tracy&#x27;</span>, <span class="hljs-number">85</span>]]);<br>m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;Michael&#x27;</span>); <span class="hljs-comment">// 95</span><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-number">67</span>); <span class="hljs-comment">// 添加新的key-value</span><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">59</span>);<br>m.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;Adam&#x27;</span>); <span class="hljs-comment">// 是否存在key &#x27;Adam&#x27;: true</span><br>m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;Adam&#x27;</span>); <span class="hljs-comment">// 67</span><br>m.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;Adam&#x27;</span>); <span class="hljs-comment">// 删除key &#x27;Adam&#x27;</span><br>m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;Adam&#x27;</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="Set-只有非重复key，没有value值"><a href="#Set-只有非重复key，没有value值" class="headerlink" title="Set 只有非重复key，没有value值"></a>Set 只有非重复key，没有value值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;3&#x27;</span>]);<br>s; <span class="hljs-comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span><br><span class="hljs-comment">// 添加元素</span><br>s.<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>);<br>s; <span class="hljs-comment">// &#123;1, 2, 3, 4&#125;</span><br><span class="hljs-comment">// 删除元素</span><br>s.<span class="hljs-title function_">delete</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="iterable类型"><a href="#iterable类型" class="headerlink" title="iterable类型"></a>iterable类型</h3><p>包括Array、Map、Set等；<br> for。。。in<br> 循环对象的属性名称key；一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。<br> for。。。of<br> 循环对象键值对中的value；更适合遍历没有key的集合，如Set；<br> forEach方法   （更好）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">a.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">element, index, array</span>) &#123;<br>    <span class="hljs-comment">// element: 指向当前元素的值</span><br>    <span class="hljs-comment">// index: 指向当前索引</span><br>    <span class="hljs-comment">// array: 指向Array对象本身</span><br>    <span class="hljs-title function_">alert</span>(element);<br>&#125;);<br><br><span class="hljs-comment">// Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：</span><br><span class="hljs-comment">// Map的回调函数参数依次为value、key和map本身：</span><br></code></pre></td></tr></table></figure><h3 id="函数arguments参数"><a href="#函数arguments参数" class="headerlink" title="函数arguments参数"></a>函数arguments参数</h3><p>它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：<br> 利用arguments，你可以获得调用者传入的所有参数。即使函数不定义任何参数，还是可以拿到参数的值</p><p>当传入参数个数超过函数定义的参数个数，则将多余参数传入rest参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// rest参数只能写在最后，前面用...标识</span><br><span class="hljs-comment">// 传入的参数先绑定a、b，多余的参数以数组形式交给变量rest</span><br><span class="hljs-comment">// 所以，不再需要arguments我们就获取了全部参数。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, b, ...rest</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a = &#x27;</span> + a);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b = &#x27;</span> + b);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest);<br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 结果:</span><br><span class="hljs-comment">// a = 1</span><br><span class="hljs-comment">// b = 2</span><br><span class="hljs-comment">// Array [ 3, 4, 5 ]</span><br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 结果:</span><br><span class="hljs-comment">// a = 1</span><br><span class="hljs-comment">// b = undefined</span><br><span class="hljs-comment">// Array []</span><br></code></pre></td></tr></table></figure><h3 id="全局对象-window"><a href="#全局对象-window" class="headerlink" title="全局对象 window"></a>全局对象 window</h3><p>全局作用域的变量实际绑定到window的一个属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> course = <span class="hljs-string">&#x27;Learn JavaScript&#x27;</span>;<br><span class="hljs-title function_">alert</span>(course); <span class="hljs-comment">// &#x27;Learn JavaScript&#x27;</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">course</span>); <span class="hljs-comment">// &#x27;Learn JavaScript&#x27;</span><br><br><span class="hljs-comment">// 全局变量course 等同于 window.course</span><br><span class="hljs-comment">// alert函数也是window的一个变量</span><br></code></pre></td></tr></table></figure><p>减少全局变量的冲突：声明一个唯一的全局变量{}；然后把所有变量和函数都绑定到这个唯一一个全局变量上。</p><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>for循环中，var i可以在循环块外部被引用；ES6的let i则解决了这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br>    i += <span class="hljs-number">100</span>;      <span class="hljs-comment">// 仍然可以引用变量i</span><br>&#125;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>        sum += i;<br>    &#125;<br>    i += <span class="hljs-number">1</span>;       <span class="hljs-comment">// SyntaxError</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="this丢失问题"><a href="#this丢失问题" class="headerlink" title="this丢失问题"></a>this丢失问题</h3><p>对象方法中的this，必须由对象进行调用该方法才能获取this；<br> 对象方法中的函数，this指向全局对象window；<br> 解决方法1：  that</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 保存当前this  ===&gt; that</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 在方法内部一开始就捕获this</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAgeFromBirth</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>            <span class="hljs-keyword">return</span> y - that.<span class="hljs-property">birth</span>; <span class="hljs-comment">// 用that而不是this</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getAgeFromBirth</span>();<br>    &#125;<br>&#125;;<br><br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><p>解决方法2：  apply与call</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用apply或call，控制函数的this指向传入的首个参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>    <span class="hljs-keyword">return</span> y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: getAge<br>&#125;;<br><br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">// 25</span><br><br><span class="hljs-comment">// apply()把参数打包成Array再传入；</span><br>getAge.<span class="hljs-title function_">apply</span>(xiaoming, []); <span class="hljs-comment">// 25, this指向xiaoming, 参数为空</span><br><span class="hljs-comment">// 把参数按顺序传入。</span><br>getAge.<span class="hljs-title function_">call</span>(xiaoming)<br></code></pre></td></tr></table></figure><p>解决方法3： IFEE思想，bind(this)</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">函数参数`指向`函数<br></code></pre></td></tr></table></figure><h4 id="map逐一映射"><a href="#map逐一映射" class="headerlink" title="map逐一映射"></a>map逐一映射</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// *****</span><br><span class="hljs-comment">// “把f(x)作用在Array的每一个元素并把结果生成一个新的Array”。</span><br><span class="hljs-comment">// *****</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">pow</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];<br>arr.<span class="hljs-title function_">map</span>(pow); <span class="hljs-comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></code></pre></td></tr></table></figure><h4 id="reduce瀑布映射"><a href="#reduce瀑布映射" class="headerlink" title="reduce瀑布映射"></a>reduce瀑布映射</h4><p>原理：[x1, x2, x3, x4].reduce(f) &#x3D; f(f(f(x1, x2), x3), x4)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// *****</span><br><span class="hljs-comment">// 把结果继续和序列的下一个元素做累积计算</span><br><span class="hljs-comment">// *****</span><br><br><span class="hljs-comment">// [1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场：</span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>];<br>arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y;<br>&#125;); <span class="hljs-comment">// 13579</span><br></code></pre></td></tr></table></figure><h4 id="filter过滤"><a href="#filter过滤" class="headerlink" title="filter过滤"></a>filter过滤</h4><p>filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 利用filter，可以巧妙地去除Array的重复元素：</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> r,<br>    arr = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;strawberry&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;strawberry&#x27;</span>];<br><br>r = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">element, index, self</span>) &#123;<br>    <span class="hljs-comment">// indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，被过滤</span><br>    <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">indexOf</span>(element) === index;<br>&#125;);<br><br><span class="hljs-title function_">alert</span>(r.<span class="hljs-title function_">toString</span>());<br></code></pre></td></tr></table></figure><h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h3><p><code>sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：</code><br> 默认把所有元素先转换为String再排序，字符串根据首个字符的ASCII码进行排序<br> sort的自定义排序中，return -1不对调；return 1对调；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 升序排列</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x &lt; y) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; y) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;); <span class="hljs-comment">// [1, 2, 10, 20]</span><br></code></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">x =&gt; x * x   <br><br>等同于  <br><br><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数相当于匿名函数<br> 格式一，只包含一个表达式，可以省略{ … }和return<br> 格式二，包含多条语句，不能省略{ … }和return：</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 两个参数:</span><br>(x, y) =&gt; x * x + y * y<br><br><span class="hljs-comment">// 无参数:</span><br>() =&gt; <span class="hljs-number">3.14</span><br><br><span class="hljs-comment">// 可变参数:</span><br>(x, y, ...rest) =&gt; &#123;<br>    <span class="hljs-keyword">var</span> i, sum = x + y;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;rest.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += rest[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h4><p>返回对象时存在语法冲突{} 所以改为({foo:x})</p><h4 id="this作用域"><a href="#this作用域" class="headerlink" title="this作用域"></a>this作用域</h4><p>箭头函数修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：<br> 也就是说，在对象（第一层）的方法（第二层）的函数（第三层）中，仍然可以用this调用到对象的属性值；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> b = <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <span class="hljs-comment">// 1990</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;    <span class="hljs-comment">//this指向obj对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();<br>    &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">getAge</span>(); <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><h4 id="call-与apply"><a href="#call-与apply" class="headerlink" title="call()与apply()"></a>call()与apply()</h4><p>由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略，直接传入参数即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">year</span>) &#123;<br>        <span class="hljs-keyword">var</span> b = <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <span class="hljs-comment">// 1990</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">y</span>) =&gt; y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <span class="hljs-comment">// this.birth仍是1990</span><br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">birth</span>:<span class="hljs-number">2000</span>&#125;, year);<br>        <span class="hljs-comment">// 原本需要写作fn.call(this, &#123;birth:2000&#125;, year)</span><br>    &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">getAge</span>(<span class="hljs-number">2015</span>); <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><h3 id="generator生成器"><a href="#generator生成器" class="headerlink" title="generator生成器"></a>generator生成器</h3><p>yield 用于return之前的多次返回<br> generator</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> x + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-comment">// 创建generator对象   与函数调用不同，不能直接调用</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">foo</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// &#123;[[GeneratorStatus]]: &quot;suspended&quot;&#125;</span><br><br><span class="hljs-comment">// 实际获取返回值   done属性表示执行完毕</span><br>f.<span class="hljs-title function_">next</span>();    <span class="hljs-comment">// &#123;value: 4, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>();    <span class="hljs-comment">// &#123;value: 5, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>();    <span class="hljs-comment">// &#123;value: 6, done: true&#125;</span><br>f.<span class="hljs-title function_">next</span>();    <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br><br><br><span class="hljs-comment">// 直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x <span class="hljs-keyword">of</span> <span class="hljs-title function_">f</span>(<span class="hljs-number">3</span>)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 依次输出4,5,6</span><br>&#125;<br></code></pre></td></tr></table></figure><p>generator的优点：<br> 1.因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。</p><p>2.把异步回调代码变成形似同步代码（主要是美观，实际仍未异步）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 原来的ajax写法</span><br><span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;http://url-1&#x27;</span>, data1, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, result</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">handle</span>(err);<br>    &#125;<br>    <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;http://url-2&#x27;</span>, data2, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, result</span>) &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">handle</span>(err);<br>        &#125;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;http://url-3&#x27;</span>, data3, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, result</span>) &#123;<br>            <span class="hljs-keyword">if</span> (err) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_">handle</span>(err);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">success</span>(result);<br>        &#125;);<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 使用generator美化之后</span><br><span class="hljs-keyword">try</span> &#123;<br>    r1 = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;http://url-1&#x27;</span>, data1);<br>    r2 = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;http://url-2&#x27;</span>, data2);<br>    r3 = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;http://url-3&#x27;</span>, data3);<br>    <span class="hljs-title function_">success</span>(r3);<br>&#125;<br><span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-title function_">handle</span>(err);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 标准对象typeof 123; // &#x27;number&#x27;typeof NaN; // &#x27;number&#x27;typeof &#x27;str&#x27;; // &#x27;string&#x27;typeof true; // &#x27;boolean&#x27;typeof undefined; // &#x27;undefined&#x27;typeof Math.abs; // &#x27;function&#x27;typeof null; // &#x27;object&#x27;typeof []; // &#x27;object&#x27;typeof &#123;&#125;; // &#x27;object&#x27;// 包装对象  拆包前是Object；解包后是普通数据类型var n = new Number(123); // 123,生成了新的包装类型var b = new Boolean(true); // true,生成了新的包装类型var s = new String(&#x27;str&#x27;); // &#x27;str&#x27;,生成了新的包装类型</span><br></code></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>regExp.test(str);   返回值：false&#x2F;trues<br> 用途：</p><ol><li>切割字符串</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;a,b;; c  d&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/[\s\,\;]+/</span>); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br></code></pre></td></tr></table></figure><ol><li>分组，提取子串</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;<br>re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;010-12345&#x27;</span>); <span class="hljs-comment">// [&#x27;010-12345&#x27;, &#x27;010&#x27;, &#x27;12345&#x27;]</span><br>re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;010 12345&#x27;</span>); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><h4 id="字符串化-stringify"><a href="#字符串化-stringify" class="headerlink" title="字符串化 stringify"></a>字符串化 stringify</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">14</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.65</span>,<br>    <span class="hljs-attr">grade</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&#x27;middle-school&#x27;</span>: <span class="hljs-string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,<br>    <span class="hljs-attr">skills</span>: [<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Lisp&#x27;</span>]<br>&#125;;<br><br><span class="hljs-comment">// 原始字符串显示</span><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming);<br><br><span class="hljs-comment">// 缩进显示 </span><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;  &#x27;</span>);<br><br><span class="hljs-comment">// 传入Array，输出指定的属性</span><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;skills&#x27;</span>], <span class="hljs-string">&#x27;  &#x27;</span>);<br><br><span class="hljs-comment">// 传入一个函数，处理对象的每个键值</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">toUpperCase</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming, convert, <span class="hljs-string">&#x27;  &#x27;</span>);<br><br><span class="hljs-comment">// JSON数据添加toJSON属性，控制JSON应该序列化的数据</span><br><span class="hljs-attr">toJSON</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">// 只输出name和age，并且改变了key：</span><br>            <span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>,<br>            <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span><br>        &#125;;<br>    &#125;<br><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming); <span class="hljs-comment">// &#x27;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="反序列化-JSON-parse"><a href="#反序列化-JSON-parse" class="headerlink" title="反序列化 JSON.parse"></a>反序列化 JSON.parse</h4><p>JSON.parse()还可以接收一个函数，用来转换解析出的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-comment">// 把number * 2:</span><br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;name&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> value + <span class="hljs-string">&#x27;同学&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;); <span class="hljs-comment">// Object &#123;name: &#x27;小明同学&#x27;, age: 14&#125;</span><br></code></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数与普通函数的声明几乎没有区别。<br> 但是必须通过new来调用构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;<br> 如果不写new，这就是一个普通函数，它返回undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 生成的每个实例都会有独立的name属性与hello属性；hello的函数代码重复，浪费内存空间</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//  把hello函数放在prototype下，可以让不同的实例共享同个函数，节省内存空间</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="原型继承-其实ES6的class优化更容易理解、好用"><a href="#原型继承-其实ES6的class优化更容易理解、好用" class="headerlink" title="原型继承(其实ES6的class优化更容易理解、好用)"></a>原型继承(其实ES6的class优化更容易理解、好用)</h3><p><strong>重点理解！！！prototype指向的是一个对象，而不是prototype指向prototype属性</strong></p><p><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Object.prototype ----&gt; null</code><br> 必须想办法把原型链修改为：<br> <code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null</code><br> 不能直接改变指向；<br> 必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype，中间对象可以用一个空函数F来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// PrimaryStudent构造函数:</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PrimaryStudent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-comment">// 调用了Student构造函数，绑定this变量</span><br>    <span class="hljs-comment">// 但是PrimaryStudent的prototype并不指向Student；这并不是继承</span><br>    <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, props);    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = props.<span class="hljs-property">grade</span> || <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 空函数F:</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><br><span class="hljs-comment">// 把F的原型指向Student.prototype:</span><br>F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><br><span class="hljs-comment">// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:</span><br><span class="hljs-title class_">PrimaryStudent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br><br><span class="hljs-comment">// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:</span><br><span class="hljs-title class_">PrimaryStudent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">PrimaryStudent</span>;<br><br><span class="hljs-comment">// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：</span><br><span class="hljs-title class_">PrimaryStudent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getGrade</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span>;<br>&#125;;<br><br><span class="hljs-comment">// 创建xiaoming:</span><br><span class="hljs-keyword">var</span> xiaoming = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrimaryStudent</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">grade</span>: <span class="hljs-number">2</span><br>&#125;);<br>xiaoming.<span class="hljs-property">name</span>; <span class="hljs-comment">// &#x27;小明&#x27;</span><br>xiaoming.<span class="hljs-property">grade</span>; <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// 验证原型:</span><br>xiaoming.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">PrimaryStudent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br>xiaoming.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 验证继承关系:</span><br>xiaoming <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PrimaryStudent</span>; <span class="hljs-comment">// true</span><br>xiaoming <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Student</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 封装空函数继承过程</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherits</span>(<span class="hljs-params">Child, Parent</span>) &#123;<br>    <span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现原型继承链:</span><br><span class="hljs-title function_">inherits</span>(<span class="hljs-title class_">PrimaryStudent</span>, <span class="hljs-title class_">Student</span>);<br></code></pre></td></tr></table></figure><h3 id="class继承-原型继承的优化"><a href="#class继承-原型继承的优化" class="headerlink" title="class继承 &#x3D;&#x3D;&#x3D;&gt; 原型继承的优化"></a>class继承 &#x3D;&#x3D;&#x3D;&gt; 原型继承的优化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 使用class实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br><br>    <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化</span><br><span class="hljs-keyword">var</span> xiaoming = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br>xiaoming.<span class="hljs-title function_">hello</span>();<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用extends关键字实现继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrimaryStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Student</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, grade</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 记得用super调用父类的构造方法!</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>    &#125;<br><br>    <span class="hljs-title function_">myGrade</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;I am at grade &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h3><h4 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h4><p>window对象不但充当全局作用域，而且表示浏览器窗口。</p><p>window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。</p><h4 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h4><p>navigator对象表示浏览器的信息，最常用的属性包括：</p><p>navigator.appName：浏览器名称；<br> navigator.appVersion：浏览器版本；<br> navigator.language：浏览器设置的语言；<br> navigator.platform：操作系统类型；<br> navigator.userAgent：浏览器设定的User-Agent字符串。</p><h4 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h4><p>screen对象表示屏幕的信息，常用的属性有：</p><p>screen.width：屏幕宽度，以像素为单位；<br> screen.height：屏幕高度，以像素为单位；<br> screen.colorDepth：返回颜色位数，如8、16、24。</p><h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><p>location对象表示当前页面的URL信息。例如，一个完整的URL：</p><p><a href="https://link.jianshu.com/?t=http://www.example.com:8080/path/index.html?a=1&b=2#TOP">http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</a><br> 可以用location.href获取。要获得URL各个部分的值，可以这么写：</p><p>location.protocol; &#x2F;&#x2F; ‘http’<br> location.host; &#x2F;&#x2F; ‘<a href="https://link.jianshu.com/?t=http://www.example.com%27">www.example.com&#39;</a><br> location.port; &#x2F;&#x2F; ‘8080’<br> location.pathname; &#x2F;&#x2F; ‘&#x2F;path&#x2F;index.html’<br> location.search; &#x2F;&#x2F; ‘?a&#x3D;1&amp;b&#x3D;2’<br> location.hash; &#x2F;&#x2F; ‘TOP’</p><p>要加载一个新页面：location.assign()<br> 重新加载当前页面，location.reload()</p><h4 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h4><p>document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。</p><p>document对象还有一个cookie属性，可以获取当前页面的Cookie。</p><p>Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user&#x3D;ABC123XYZ(加密的字符串)…，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。</p><p>Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。</p><p>JavaScript可以通过document.cookie读取到当前页面的Cookie：</p><blockquote></blockquote><p>为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。<br> 为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。<br> 效果&#x3D;&#x3D;&gt; 保证浏览器的document对象中就看不到cookie，不能通过客户端脚本访问；只能通过服务器端的http请求</p><h3 id="DOM更新、插入、删除"><a href="#DOM更新、插入、删除" class="headerlink" title="DOM更新、插入、删除"></a>DOM更新、插入、删除</h3><h4 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h4><p>innerHTML： 以HTML的形式插入代码段，可更新节点的结构；<br> innerTEXT： 以字符串的形式插入到节点，内含的html标签失效；<br> <code>element.style.color = &#39;red&#39;;</code>   通过DOM节点的style属性修改css</p><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><p><code>document.createElement(&#39;p&#39;); element.appendChild(newElement)</code>   如果新节点已存在，不是简单在尾部添加，而是剪切该元素到目标位置；如果是一直创建新标签，则一直重复插入；<br> <code>document.createElement(&#39;p&#39;); element.insertBefore(newElement, referenceElement);</code>    如果新节点已存在，就不是简单在节点前添加，而是剪切该元素到目标位置；同append；</p><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">找到目标删除节点，寻至父节点，删除子节点； 被删除的节点仍然保存在内存中，可以再次插入 <br><span class="hljs-comment">// 拿到待删除节点:</span><br><span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;to-be-removed&#x27;</span>);<br><span class="hljs-comment">// 拿到父节点:</span><br><span class="hljs-keyword">var</span> parent = self.<span class="hljs-property">parentElement</span>;<br><span class="hljs-comment">// 删除:</span><br><span class="hljs-keyword">var</span> removed = parent.<span class="hljs-title function_">removeChild</span>(self);<br>removed === self; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>使用onsubmit 与type&#x3D;”submit”进行提交表单；使用click会扰乱form的正常提交</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-form&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return checkForm()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-form&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 可以在此修改form的input...</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 继续下一步:</span></span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// return true来告诉浏览器继续提交</span></span><br><span class="language-javascript">    <span class="hljs-comment">// return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="HTML5中的File-API允许JS读取文件内容"><a href="#HTML5中的File-API允许JS读取文件内容" class="headerlink" title="HTML5中的File API允许JS读取文件内容"></a>HTML5中的File API允许JS读取文件内容</h3><p>html5提供了 <code>File</code> 与 <code>FileReader</code> 两个主要对象，可以获得文件信息并读取文件。<br> File读取文件属性信息； FileReader读取文件内部数据（比如图片的base64）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// fileInput：选择文件的按钮； info：读取的文件属性信息；  preview：页面中的预览框  </span><br><span class="hljs-keyword">var</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-image-file&#x27;</span>),<br>    info = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-file-info&#x27;</span>),<br>    preview = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-image-preview&#x27;</span>);<br><span class="hljs-comment">// 监听change事件:</span><br>fileInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 清除背景图片:</span><br>    preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-comment">// 检查文件是否选择:</span><br>    <span class="hljs-keyword">if</span> (!fileInput.<span class="hljs-property">value</span>) &#123;<br>        info.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;没有选择文件&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取File引用:</span><br>    <span class="hljs-keyword">var</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 获取File信息:</span><br>    info.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;文件: &#x27;</span> + file.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>                     <span class="hljs-string">&#x27;大小: &#x27;</span> + file.<span class="hljs-property">size</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>                     <span class="hljs-string">&#x27;修改: &#x27;</span> + file.<span class="hljs-property">lastModifiedDate</span>;<br>    <span class="hljs-keyword">if</span> (file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/jpeg&#x27;</span> &amp;&amp; file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/png&#x27;</span> &amp;&amp; file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/gif&#x27;</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;不是有效的图片文件!&#x27;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取文件:</span><br>    <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>    reader.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>        <span class="hljs-keyword">var</span><br>            data = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>; <span class="hljs-comment">// &#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;            </span><br>        preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&#x27;</span> + data + <span class="hljs-string">&#x27;)&#x27;</span>;<br>    &#125;;<br>    <span class="hljs-comment">// 以DataURL的形式读取文件:</span><br>    reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>在现代浏览器上写AJAX主要依靠XMLHttpRequest对象<br> 根据状态码判断响应进度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 原生AJAX的写法</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">success</span>(<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-keyword">var</span> textarea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-response-text&#x27;</span>);<br>    textarea.<span class="hljs-property">value</span> = text;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fail</span>(<span class="hljs-params">code</span>) &#123;<br>    <span class="hljs-keyword">var</span> textarea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-response-text&#x27;</span>);<br>    textarea.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;Error code: &#x27;</span> + code;<br>&#125;<br><br><span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>(); <span class="hljs-comment">// 新建XMLHttpRequest对象</span><br><br><span class="hljs-comment">// 定义request的响应回调函数</span><br>request.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 状态发生变化时，函数被回调</span><br>    <span class="hljs-keyword">if</span> (request.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 成功完成</span><br>        <span class="hljs-comment">// 判断响应结果:</span><br>        <span class="hljs-keyword">if</span> (request.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-comment">// 成功，通过responseText拿到响应的文本:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">success</span>(request.<span class="hljs-property">responseText</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 失败，根据响应码判断失败原因:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">fail</span>(request.<span class="hljs-property">status</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// HTTP请求还在继续...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 发送请求:</span><br>request.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/api/categories&#x27;</span>);<br>request.<span class="hljs-title function_">send</span>();<br><br><span class="hljs-comment">// XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。</span><br><span class="hljs-comment">// 最后调用send()方法才是真正发送请求。</span><br><span class="hljs-comment">// GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。</span><br><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请求已发送，请等待响应...&#x27;</span>);<br><br><span class="hljs-comment">// 使用Promise的简化写法</span><br><span class="hljs-comment">// ajax函数将返回Promise对象:</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">method, url, data</span>) &#123;<br>    <span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>        request.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (request.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">if</span> (request.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(request.<span class="hljs-property">responseText</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">reject</span>(request.<span class="hljs-property">status</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        request.<span class="hljs-title function_">open</span>(method, url);<br>        request.<span class="hljs-title function_">send</span>(data);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/api/categories&#x27;</span>);<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) &#123; <span class="hljs-comment">// 如果AJAX成功，获得响应内容</span><br>    log.<span class="hljs-property">innerText</span> = text;<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) &#123; <span class="hljs-comment">// 如果AJAX失败，获得响应代码</span><br>    log.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;ERROR: &#x27;</span> + status;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h4><p>大多数浏览器只允许在js中请求域名、协议、端口相同的URL；因此存在跨域问题。<br> 解决方法：<br> 1.使用flash插件发送http请求；必须安装flash，不考虑。<br> 2.在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器，代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。<br> 3.JSONP，但只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源；通常以函数调用的形式返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">以<span class="hljs-number">163</span>的股票查询<span class="hljs-variable constant_">URL</span>为例，对于<span class="hljs-variable constant_">URL</span>：<span class="hljs-attr">http</span>:<span class="hljs-comment">//api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice，你将得到如下返回(一个带参的函数调用)：</span><br><br><span class="hljs-title function_">refreshPrice</span>(&#123;<span class="hljs-string">&quot;0000001&quot;</span>:&#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-string">&quot;0000001&quot;</span>, ... &#125;);<br>因此我们需要首先在页面中准备好回调函数：<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">refreshPrice</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">var</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-jsonp&#x27;</span>);<br>    p.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;当前价格：&#x27;</span> +<br>        data[<span class="hljs-string">&#x27;0000001&#x27;</span>].<span class="hljs-property">name</span> +<span class="hljs-string">&#x27;: &#x27;</span> + <br>        data[<span class="hljs-string">&#x27;0000001&#x27;</span>].<span class="hljs-property">price</span> + <span class="hljs-string">&#x27;；&#x27;</span> +<br>        data[<span class="hljs-string">&#x27;1399001&#x27;</span>].<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;: &#x27;</span> +<br>        data[<span class="hljs-string">&#x27;1399001&#x27;</span>].<span class="hljs-property">price</span>;<br>&#125;<br><br>最后用<span class="hljs-title function_">getPrice</span>()函数触发：通过新建script标签，访问<span class="hljs-variable constant_">API</span>，调用refreshPrice函数，使用自定义的refreshPrice渲染新数据<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPrice</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> js = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>),<br>        head = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>];<br>    js.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&#x27;</span>;<br>    head.<span class="hljs-title function_">appendChild</span>(js);<br>&#125;<br></code></pre></td></tr></table></figure><p>4.CORS （Cross-Origin Resource Sharing）是HTML5规范定义的如何跨域访问资源。<br> 跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。</p><h3 id="Promise-承诺将来会执行"><a href="#Promise-承诺将来会执行" class="headerlink" title="Promise 承诺将来会执行"></a>Promise 承诺将来会执行</h3><p>效果： 把原本的一种回调细分为两种回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 变量p1是一个Promise对象，它负责执行test函数。test函数在内部是异步执行的</span><br><span class="hljs-comment">// 当test函数执行成功时，我们告诉Promise对象,如果成功，执行.then()</span><br><span class="hljs-comment">// 当test函数执行失败时，我们告诉Promise对象，如果失败，执行.catch()</span><br><span class="hljs-comment">// 通过test函数中的resolve与reject来判断函数执行成功与失败  </span><br><br><br><span class="hljs-comment">// 链式简写</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(test).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span> + result);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;失败：&#x27;</span> + reason);<br>&#125;);<br><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;start new Promise...&#x27;</span>);<br>    <span class="hljs-keyword">var</span> timeOut = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">2</span>;<br>    <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set timeout to: &#x27;</span> + timeOut + <span class="hljs-string">&#x27; seconds.&#x27;</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (timeOut &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;call resolve()...&#x27;</span>);<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;200 OK&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;call reject()...&#x27;</span>);<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;timeout in &#x27;</span> + timeOut + <span class="hljs-string">&#x27; seconds.&#x27;</span>);<br>        &#125;<br>    &#125;, timeOut * <span class="hljs-number">1000</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Done: &#x27;</span> + r);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Failed: &#x27;</span> + reason);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="Promise串行执行异步任务"><a href="#Promise串行执行异步任务" class="headerlink" title="Promise串行执行异步任务"></a>Promise串行执行异步任务</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">job1.<span class="hljs-title function_">then</span>(job2).<span class="hljs-title function_">then</span>(job3).<span class="hljs-title function_">catch</span>(handleError);<br><br><span class="hljs-comment">// job1、2、3都是Promise对象</span><br></code></pre></td></tr></table></figure><h4 id="Promise-并行执行多个异步任务"><a href="#Promise-并行执行多个异步任务" class="headerlink" title="Promise 并行执行多个异步任务"></a>Promise 并行执行多个异步任务</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;P1&#x27;</span>);<br>&#125;);<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">600</span>, <span class="hljs-string">&#x27;P2&#x27;</span>);<br>&#125;);<br><br><br><span class="hljs-comment">// 并行执行异步任务   Promise.all() 以数组形式返回数据</span><br><span class="hljs-comment">// 同时执行p1和p2，并在它们都完成后执行then:</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results); <span class="hljs-comment">// 获得一个Array: [&#x27;P1&#x27;, &#x27;P2&#x27;]</span><br>&#125;);<br><br><br><span class="hljs-comment">// 多个异步任务竞争 ===&gt; 为了容错，只需要获得先返回的结果即可；后完成的任务仍在执行，但执行结果将被丢弃</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// &#x27;P1&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p><code>jQuery === $</code>  &#x2F;&#x2F; 本质上是function，而function也是对象，于是$可以直接调用，也有很多其他属性。</p><p>组合查找： <code>$(&#39;input[name=email]&#39;)</code><br> 多项选择： <code>$(&#39;p.red,p.green&#39;); // 把&lt;p class=&quot;red&quot;&gt;和&lt;p class=&quot;green&quot;&gt;都选出来</code></p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">.<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>.<span class="hljs-title function_">next</span>()  <span class="hljs-comment">// 可加参数，也可不加</span><br>.<span class="hljs-title function_">prev</span>()  <span class="hljs-comment">// 可加参数，也可不加</span><br></code></pre></td></tr></table></figure><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以下的[] 指若干DOM节点</span><br>[].<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">// 过滤掉不符合过滤条件的</span><br>[].<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;S&#x27;</span>) === <span class="hljs-number">0</span><br>        &#125;)   <span class="hljs-comment">// 仅保留S开头的节点</span><br>() =&gt; [].<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span>;<br>&#125;).<span class="hljs-title function_">get</span>();   <span class="hljs-comment">// 用get()拿到包含string的Array</span><br><br>[].<span class="hljs-title function_">first</span>()     <span class="hljs-comment">//获取若干DOM节点的首个节点</span><br>[].<span class="hljs-title function_">last</span>()      <span class="hljs-comment">//获取若干DOM节点的末尾节点</span><br>[].<span class="hljs-title function_">slice</span>()     <span class="hljs-comment">//截取若干DOM节点的若干节点</span><br></code></pre></td></tr></table></figure><h4 id="修改DOM-与-CSS-与-添加、删除DOM"><a href="#修改DOM-与-CSS-与-添加、删除DOM" class="headerlink" title="修改DOM 与 CSS 与 添加、删除DOM"></a>修改DOM 与 CSS 与 添加、删除DOM</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取 </span><br>$().<span class="hljs-title function_">text</span>()<br>$().<span class="hljs-title function_">html</span>()<br><br><span class="hljs-comment">// 修改</span><br>$().<span class="hljs-title function_">text</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>$().<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-comment">// 修改css</span><br>$().<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;key&#x27;</span>,<span class="hljs-string">&#x27;value&#x27;</span>)<br><span class="hljs-keyword">var</span> div = $(<span class="hljs-string">&#x27;#test-div&#x27;</span>);<br>div.<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;color&#x27;</span>); <span class="hljs-comment">// 获取CSS属性</span><br>div.<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;#336699&#x27;</span>); <span class="hljs-comment">// 设置CSS属性</span><br>div.<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// 清除CSS属性</span><br>div.<span class="hljs-title function_">hasClass</span>(<span class="hljs-string">&#x27;highlight&#x27;</span>); <span class="hljs-comment">// false， class是否包含highlight</span><br>div.<span class="hljs-title function_">addClass</span>(<span class="hljs-string">&#x27;highlight&#x27;</span>); <span class="hljs-comment">// 添加highlight这个class</span><br>div.<span class="hljs-title function_">removeClass</span>(<span class="hljs-string">&#x27;highlight&#x27;</span>); <span class="hljs-comment">// 删除highlight这个class</span><br><br><span class="hljs-comment">// 修改display属性</span><br>a.<span class="hljs-title function_">hide</span>(); <span class="hljs-comment">// 隐藏</span><br>a.<span class="hljs-title function_">show</span>(); <span class="hljs-comment">// 显示</span><br><br><span class="hljs-comment">// 获取DOM信息</span><br><span class="hljs-comment">// 浏览器可视窗口大小:</span><br>$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">width</span>(); <span class="hljs-comment">// 800</span><br>$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">height</span>(); <span class="hljs-comment">// 600</span><br><br><span class="hljs-comment">// HTML文档大小:</span><br>$(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">width</span>(); <span class="hljs-comment">// 800</span><br>$(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">height</span>(); <span class="hljs-comment">// 3500</span><br><br><span class="hljs-comment">// 某个div的大小:</span><br><span class="hljs-keyword">var</span> div = $(<span class="hljs-string">&#x27;#test-div&#x27;</span>);<br>div.<span class="hljs-title function_">width</span>(); <span class="hljs-comment">// 600</span><br>div.<span class="hljs-title function_">height</span>(); <span class="hljs-comment">// 300</span><br>div.<span class="hljs-title function_">width</span>(<span class="hljs-number">400</span>); <span class="hljs-comment">// 设置CSS属性 width: 400px，是否生效要看CSS是否有效</span><br>div.<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;200px&#x27;</span>); <span class="hljs-comment">// 设置CSS属性 height: 200px，是否生效要看CSS是否有效</span><br><br><span class="hljs-comment">// 属性操作</span><br>div.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>);    <span class="hljs-comment">// 设置属性</span><br>div.<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">&#x27;name&#x27;</span>);       <span class="hljs-comment">// 移除属性</span><br>div.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;name&#x27;</span>);             <span class="hljs-comment">// 获取属性</span><br><br><span class="hljs-comment">// 无值属性，使用is()来判断</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-radio&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">checked</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span></span><br><span class="language-xml">var radio = $(&#x27;#test-radio&#x27;);</span><br><span class="language-xml">radio.is(&#x27;:checked&#x27;); // true</span><br><span class="language-xml"></span><br><span class="language-xml">// val()方法获取和设置对应的value属性：</span><br><span class="language-xml">$().val()</span><br><span class="language-xml">$().val(&#x27;&#x27;)</span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">// 添加DOM</span><br><span class="language-xml">// 要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加，相当于移动节点</span><br><span class="language-xml">$().append();</span><br><span class="language-xml">$().after();</span><br><span class="language-xml">、删除DOM</span><br><span class="language-xml">$().remove(); //移除本身</span><br></code></pre></td></tr></table></figure><h3 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h3><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>$().on(‘event’, fn)<br> $().on(‘click’, fn)  &#x3D;&#x3D;&#x3D; $().click(fn)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx">鼠标事件<br><span class="hljs-attr">click</span>: 鼠标单击时触发；<br>dblclick：鼠标双击时触发；<br>mouseenter：鼠标进入时触发；<br>mouseleave：鼠标移出时触发；<br>mousemove：鼠标在<span class="hljs-variable constant_">DOM</span>内部移动时触发；<br>hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。<br><br>键盘事件<br>键盘事件仅作用在当前焦点的<span class="hljs-variable constant_">DOM</span>上，通常是&lt;input&gt;和&lt;textarea&gt;。<br>keydown：键盘按下时触发；<br>keyup：键盘松开时触发；<br>keypress：按一次键后触发。<br><br>其他事件<br>focus：当<span class="hljs-variable constant_">DOM</span>获得焦点时触发；<br>blur：当<span class="hljs-variable constant_">DOM</span>失去焦点时触发；<br>change：当&lt;input&gt;、&lt;select&gt;或&lt;textarea&gt;的内容改变时触发；<br>submit：当&lt;form&gt;提交时触发；<br>ready：当页面被载入并且<span class="hljs-variable constant_">DOM</span>树完成初始化后触发。仅作用于<span class="hljs-variable language_">document</span>对象<br>ready事件的三次简化：   <br><span class="hljs-string">`document.on(&#x27;ready&#x27;,fn)`</span> ===&gt;  <span class="hljs-string">`$(document).ready(fn)`</span> ===&gt; <span class="hljs-string">`$(function () &#123;&#125;)`</span><br>如果你遇到$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;...&#125;)的形式，牢记这是<span class="hljs-variable language_">document</span>对象的ready事件处理函数。<br></code></pre></td></tr></table></figure><h4 id="取消绑定"><a href="#取消绑定" class="headerlink" title="取消绑定"></a>取消绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">$().<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;click&#x27;</span>, fn);  <span class="hljs-comment">// fn只能传入绑定时的函数，不可包含定义</span><br><br><span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;click&#x27;</span>)           <span class="hljs-comment">// 一次性移除已绑定的click事件的所有处理函数。</span><br><br><span class="hljs-comment">// 无效的解除绑定，因此此处的fn对应的是一个新函数</span><br>a.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="事件触发条件"><a href="#事件触发条件" class="headerlink" title="事件触发条件"></a>事件触发条件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监控改动</span><br>$().<span class="hljs-title function_">change</span>(fn)<br></code></pre></td></tr></table></figure><h3 id="jQuery-AJAX"><a href="#jQuery-AJAX" class="headerlink" title="jQuery AJAX"></a>jQuery AJAX</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> jqxhr = $.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/api/categories&#x27;</span>, &#123;<br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span><br>&#125;);<br><span class="hljs-comment">// 请求已经发送了</span><br></code></pre></td></tr></table></figure><p>ajax的链式调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ajax的链式调用</span><br><span class="hljs-keyword">var</span> jqxhr = $.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/api/categories&#x27;</span>, &#123;<br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span><br>&#125;).<span class="hljs-title function_">done</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-comment">// 请求成功</span><br>    <span class="hljs-title function_">ajaxLog</span>(<span class="hljs-string">&#x27;成功, 收到的数据: &#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));<br>&#125;).<span class="hljs-title function_">fail</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">xhr, status</span>) &#123;<br>    <span class="hljs-comment">// 请求失败</span><br>    <span class="hljs-title function_">ajaxLog</span>(<span class="hljs-string">&#x27;失败: &#x27;</span> + xhr.<span class="hljs-property">status</span> + <span class="hljs-string">&#x27;, 原因: &#x27;</span> + status);<br>&#125;).<span class="hljs-title function_">always</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 必然调用</span><br>    <span class="hljs-title function_">ajaxLog</span>(<span class="hljs-string">&#x27;请求完成: 无论成功或失败都会调用&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>辅助方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// get方法，直接传参；获取返回的json</span><br><span class="hljs-keyword">var</span> jqxhr = $.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/path/to/resource&#x27;</span>, &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob Lee&#x27;</span>,<br>    <span class="hljs-attr">check</span>: <span class="hljs-number">1</span><br>&#125;).<span class="hljs-title function_">done</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-comment">// data已经被解析为JSON对象了</span><br>&#125;);<br><br><span class="hljs-comment">// post方法，数据作为body被发送</span><br><span class="hljs-keyword">var</span> jqxhr = $.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/path/to/resource&#x27;</span>, &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob Lee&#x27;</span>,<br>    <span class="hljs-attr">check</span>: <span class="hljs-number">1</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="jQuery插件扩展"><a href="#jQuery插件扩展" class="headerlink" title="jQuery插件扩展"></a>jQuery插件扩展</h3><p>给$.fn绑定函数，实现插件的代码逻辑；<br> 插件函数最后要return this;以支持链式调用；<br> 插件函数要有默认值，绑定在$.fn.<pluginName>.defaults上；<br> 用户在调用时可传入设定值以便覆盖默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 给jQuery对象绑定一个新方法是通过扩展$.fn对象实现的。</span><br>$.fn.<span class="hljs-property">highlight</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-comment">// 合并默认值和用户设定值:</span><br>    <span class="hljs-comment">// 使用jQuery提供的辅助方法$.extend(target, obj1, obj2, ...)，它把多个object对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高：</span><br>    <span class="hljs-keyword">var</span> opts = $.<span class="hljs-title function_">extend</span>(&#123;&#125;, $.fn.<span class="hljs-property">highlight</span>.<span class="hljs-property">defaults</span>, options);<br>    <span class="hljs-comment">// 函数内部的this在调用时被绑定为jQuery对象，所以函数内部代码可以正常调用所有jQuery对象的方法。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;backgroundColor&#x27;</span>, opts.<span class="hljs-property">backgroundColor</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;color&#x27;</span>, opts.<span class="hljs-property">color</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 添加添加return this，是因为jQuery对象支持链式操作，我们自己写的扩展方法也要能继续链式下去：</span><br>&#125;<br><br><span class="hljs-comment">// 设定默认值: 把默认值放在这个函数对象当中，允许用户修改，而且比较合适</span><br>$.fn.<span class="hljs-property">highlight</span>.<span class="hljs-property">defaults</span> = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#d85030&#x27;</span>,<br>    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;#fff8de&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 用户使用时，一次性设定默认值；</span><br>$.fn.<span class="hljs-property">highlight</span>.<span class="hljs-property">defaults</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;#fff&#x27;</span>;<br>$.fn.<span class="hljs-property">highlight</span>.<span class="hljs-property">defaults</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;#000&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 特定元素扩展</span><br><span class="hljs-comment">// 示例：给所有指向外链的超链接加上跳转提示</span><br>$.fn.<span class="hljs-property">external</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// return返回的each()返回结果，支持链式调用:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_">each</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 注意: each()内部的回调函数的this绑定为DOM本身!</span><br>        <span class="hljs-keyword">var</span> a = $(<span class="hljs-variable language_">this</span>);<br>        <span class="hljs-keyword">var</span> url = a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;href&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (url &amp;&amp; (url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;http://&#x27;</span>)===<span class="hljs-number">0</span> || url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;https://&#x27;</span>)===<span class="hljs-number">0</span>)) &#123;<br>            a.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&#x27;#0&#x27;</span>)<br>             .<span class="hljs-title function_">removeAttr</span>(<span class="hljs-string">&#x27;target&#x27;</span>)<br>             .<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27; &lt;i class=&quot;uk-icon-external-link&quot;&gt;&lt;/i&gt;&#x27;</span>)<br>             .<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;你确定要前往&#x27;</span> + url + <span class="hljs-string">&#x27;？&#x27;</span>)) &#123;<br>                    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(url);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="捕获、处理错误"><a href="#捕获、处理错误" class="headerlink" title="捕获、处理错误"></a>捕获、处理错误</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;<br><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>try{}包裹的代码，在执行中可能会发生错误，一旦出错，不再执行后续；跳转到catch块进行错误处理；最后无论有无错误，finally都执行。catch与finally可以只出现一个。</p><h4 id="主动抛出错误"><a href="#主动抛出错误" class="headerlink" title="主动抛出错误"></a>主动抛出错误</h4><p>允许抛出任意对象，包括数字、字符串。但是，最好还是抛出一个Error对象。<br> <code>throw new Error(&#39;&#39;);</code><br> 错误会一直向上抛，直到遇到一个有try-catch语句的函数；</p><h3 id="underscore第三方库，提供对Object的方法支持"><a href="#underscore第三方库，提供对Object的方法支持" class="headerlink" title="underscore第三方库，提供对Object的方法支持"></a>underscore第三方库，提供对Object的方法支持</h3><p>使用“_”绑定全局变量；类似于jQuery的“$”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">_.<span class="hljs-title function_">map</span>(obj, fn)        <span class="hljs-comment">// 返回Array</span><br>_.<span class="hljs-title function_">mapObject</span>(obj, fn)  <span class="hljs-comment">// 返回Obejct</span><br><br><span class="hljs-comment">// some 与 every   类似于filter的筛选功能</span><br>_.<span class="hljs-title function_">some</span>(obj, fn)      <span class="hljs-comment">// obj中的至少一个元素满足条件，有一个fn返回true，_.some()就返回true</span><br>_.<span class="hljs-title function_">every</span>(obj, fn)     <span class="hljs-comment">// 对每一个obj的所有元素都满足条件，即每一个fn都返回true，_.every()才返回true</span><br></code></pre></td></tr></table></figure><h4 id="分组-groupBy-obj-fn"><a href="#分组-groupBy-obj-fn" class="headerlink" title="分组 _.groupBy(obj, fn)"></a>分组 _.groupBy(obj, fn)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> scores = [<span class="hljs-number">20</span>, <span class="hljs-number">81</span>, <span class="hljs-number">75</span>, <span class="hljs-number">40</span>, <span class="hljs-number">91</span>, <span class="hljs-number">59</span>, <span class="hljs-number">77</span>, <span class="hljs-number">66</span>, <span class="hljs-number">72</span>, <span class="hljs-number">88</span>, <span class="hljs-number">99</span>];<br><span class="hljs-keyword">var</span> groups = _.<span class="hljs-title function_">groupBy</span>(scores, <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">60</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">80</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 结果:</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//   A: [81, 91, 88, 99],</span><br><span class="hljs-comment">//   B: [75, 77, 66, 72],</span><br><span class="hljs-comment">//   C: [20, 40, 59]</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h4 id="打乱shuffle与随机取sample"><a href="#打乱shuffle与随机取sample" class="headerlink" title="打乱shuffle与随机取sample"></a>打乱shuffle与随机取sample</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">_.<span class="hljs-title function_">shuffle</span>(obj)<br>_.<span class="hljs-title function_">shuffle</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]); <span class="hljs-comment">// [3, 5, 4, 6, 2, 1]</span><br><br>_.<span class="hljs-title function_">sample</span>(obj)<br><span class="hljs-comment">// 随机选1个：</span><br>_.<span class="hljs-title function_">sample</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]); <span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 随机选3个：</span><br>_.<span class="hljs-title function_">sample</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], <span class="hljs-number">3</span>); <span class="hljs-comment">// [6, 1, 4]</span><br></code></pre></td></tr></table></figure><h4 id="Array工具类"><a href="#Array工具类" class="headerlink" title="Array工具类"></a>Array工具类</h4><ul><li>_.first(arr)              &#x2F;&#x2F;  取首</li><li>_.last(arr)               &#x2F;&#x2F;  取尾</li><li>_.flatten(array)          &#x2F;&#x2F; 多层嵌套数组 &#x3D;&#x3D;&#x3D;&gt; 一维数组</li><li>_.range(start, end, step) &#x2F;&#x2F; 快速生成序列，start默认0，step默认1</li></ul><p>zip与unzip与Object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// zip 一一对应，合并</span><br><span class="hljs-keyword">var</span> names = [<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-string">&#x27;Lisa&#x27;</span>, <span class="hljs-string">&#x27;Bart&#x27;</span>];<br><span class="hljs-keyword">var</span> scores = [<span class="hljs-number">85</span>, <span class="hljs-number">92</span>, <span class="hljs-number">59</span>];<br>_.<span class="hljs-title function_">zip</span>(names, scores);<br><span class="hljs-comment">// [[&#x27;Adam&#x27;, 85], [&#x27;Lisa&#x27;, 92], [&#x27;Bart&#x27;, 59]]</span><br><br><br><span class="hljs-comment">// unzip 一一拆解</span><br><span class="hljs-keyword">var</span> namesAndScores = [[<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-number">85</span>], [<span class="hljs-string">&#x27;Lisa&#x27;</span>, <span class="hljs-number">92</span>], [<span class="hljs-string">&#x27;Bart&#x27;</span>, <span class="hljs-number">59</span>]];<br>_.<span class="hljs-title function_">unzip</span>(namesAndScores);<br><span class="hljs-comment">// [[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;], [85, 92, 59]]</span><br><br><br><span class="hljs-comment">// 一一对应，合并为对象</span><br><span class="hljs-keyword">var</span> names = [<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-string">&#x27;Lisa&#x27;</span>, <span class="hljs-string">&#x27;Bart&#x27;</span>];<br><span class="hljs-keyword">var</span> scores = [<span class="hljs-number">85</span>, <span class="hljs-number">92</span>, <span class="hljs-number">59</span>];<br>_.<span class="hljs-title function_">object</span>(names, scores);<br><span class="hljs-comment">// &#123;Adam: 85, Lisa: 92, Bart: 59&#125;</span><br></code></pre></td></tr></table></figure><h3 id="高阶函数-1"><a href="#高阶函数-1" class="headerlink" title="高阶函数"></a>高阶函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">- _.<span class="hljs-title function_">bind</span>(fn, newThis)   <span class="hljs-comment">// 获取方法，传入原来方法的this才能保证方法被获取后成功调用</span><br>- _.<span class="hljs-title function_">partial</span>(fn, constParam)        <span class="hljs-comment">// 为一个函数创建偏函数，为fn固定第一个参数</span><br>- _.<span class="hljs-title function_">partial</span>(fn, _, constParam)     <span class="hljs-comment">// 为一个函数创建偏函数，_占位，为fn固定第二个参数</span><br><br>- _.<span class="hljs-title function_">memoize</span>(fn)  <span class="hljs-comment">// 缓存某个函数在某个参数下的计算结果</span><br>- _.<span class="hljs-title function_">once</span>(fn)     <span class="hljs-comment">// 返回一个只能被调用一次的函数</span><br>- _.<span class="hljs-title function_">delay</span>(fn, time, param)  <span class="hljs-comment">// 同setTimeOut</span><br></code></pre></td></tr></table></figure><h3 id="Object-工具类"><a href="#Object-工具类" class="headerlink" title="Object 工具类"></a>Object 工具类</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php">_.<span class="hljs-title function_ invoke__">keys</span>(obj)     <span class="hljs-comment">// 返回一个object自身所有的key，但不包含从原型链继承下来的</span><br>_.<span class="hljs-title function_ invoke__">allKeys</span>(obj)  <span class="hljs-comment">// allKeys()除了object自身的key，还包含从原型链继承下来的：</span><br>_.<span class="hljs-title function_ invoke__">values</span>(obj)   <span class="hljs-comment">// 返回object自身但不包含原型链继承的所有值</span><br>_.<span class="hljs-title function_ invoke__">invert</span>(obj)   <span class="hljs-comment">// 把object的每个key-value来个交换，key变成value，value变成key</span><br>_.<span class="hljs-title function_ invoke__">extend</span>(obj,obj,obj)  <span class="hljs-comment">//把多个object的key-value合并到第一个object并返回</span><br>_.<span class="hljs-title function_ invoke__">extendOwn</span>()    <span class="hljs-comment">// 和extend()类似，但获取属性时忽略从原型链继承下来的属性</span><br>_.<span class="hljs-keyword">clone</span>()        <span class="hljs-comment">// 复制obj，就不需要遍历每个key了</span><br>_.<span class="hljs-title function_ invoke__">isEqual</span>()      <span class="hljs-comment">// 内容层面的深度比较</span><br></code></pre></td></tr></table></figure><h3 id="像jQuery一样链式调用-chain"><a href="#像jQuery一样链式调用-chain" class="headerlink" title="像jQuery一样链式调用  .chain()"></a>像jQuery一样链式调用  .chain()</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 非链式调用</span><br>_.<span class="hljs-title function_">filter</span>(_.<span class="hljs-title function_">map</span>([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>], <span class="hljs-title class_">Math</span>.<span class="hljs-property">sqrt</span>), <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>);   <span class="hljs-comment">// [1, 3, 5]</span><br><br><br><span class="hljs-comment">// 通过_.chain()实现链式调用</span><br>_.<span class="hljs-title function_">chain</span>([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>])<br> .<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">sqrt</span>)<br> .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>)<br> .<span class="hljs-title function_">value</span>();                 <span class="hljs-comment">// [1, 3, 5]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS flex布局</title>
    <link href="/blog/2021/12/14/css-flex/"/>
    <url>/blog/2021/12/14/css-flex/</url>
    
    <content type="html"><![CDATA[<h1 id="前端布局之Flex布局"><a href="#前端布局之Flex布局" class="headerlink" title="前端布局之Flex布局"></a>前端布局之Flex布局</h1><h4 id="1-内容水平排列-左对齐"><a href="#1-内容水平排列-左对齐" class="headerlink" title="1.内容水平排列-左对齐"></a>1.内容水平排列-左对齐</h4><p>需要在父节点上添加：display:flex;表示使用Flex布局。</p><p>flex-direction:row; &#x2F;* 表示内容直接横排列 *&#x2F;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>:flex;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">             <span class="hljs-comment">/* 默认的主轴是 x 轴 行 row  那么y轴就是侧轴喽 */</span></span><br><span class="language-css">            <span class="hljs-comment">/* 我们的元素是跟着主轴来排列的 */</span></span><br><span class="language-css">            <span class="hljs-attribute">flex-direction</span>:row; <span class="hljs-comment">/* 表示内容直接横排列 */</span></span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: purple;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-内容横排列-反转右对齐"><a href="#2-内容横排列-反转右对齐" class="headerlink" title="2.内容横排列-反转右对齐"></a>2.内容横排列-反转右对齐</h4><p>flex-direction:row-reverse</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>:flex;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">             <span class="hljs-comment">/* 默认的主轴是 x 轴 行 row  那么y轴就是侧轴喽 */</span></span><br><span class="language-css">            <span class="hljs-comment">/* 我们的元素是跟着主轴来排列的 */</span></span><br><span class="language-css">            <span class="hljs-attribute">flex-direction</span>:row-reverse; <span class="hljs-comment">/* 表示内容直接横排列 */</span></span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: purple;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-垂直排列"><a href="#3-垂直排列" class="headerlink" title="3.垂直排列"></a><strong>3.垂直排列</strong></h4><p>flex-direction: column;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>:flex;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">             <span class="hljs-comment">/* 默认的主轴是 x 轴 行 row  那么y轴就是侧轴喽 */</span></span><br><span class="language-css">            <span class="hljs-comment">/* 我们的元素是跟着主轴来排列的 */</span></span><br><span class="language-css">            <span class="hljs-comment">/* flex-direction:row; 表示内容直接横排列 */</span></span><br><span class="language-css">            <span class="hljs-attribute">flex-direction</span>: column;</span><br><span class="language-css"></span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: purple;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-居中对齐"><a href="#4-居中对齐" class="headerlink" title="4.居中对齐"></a><strong>4.居中对齐</strong></h4><p>justify-content:center</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">                <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">800px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">            <span class="hljs-comment">/* 默认的主轴是 x 轴 row */</span></span><br><span class="language-css">            <span class="hljs-attribute">flex-direction</span>: row;</span><br><span class="language-css">            <span class="hljs-comment">/* justify-content: 是设置主轴上子元素的排列方式 */</span></span><br><span class="language-css">            <span class="hljs-comment">/* justify-content: flex-start; */</span></span><br><span class="language-css">            <span class="hljs-comment">/* justify-content: flex-end; */</span></span><br><span class="language-css">            <span class="hljs-comment">/* 让我们子元素居中对齐 */</span></span><br><span class="language-css">            <span class="hljs-comment">/* justify-content: center; */</span></span><br><span class="language-css">            <span class="hljs-comment">/* 平分剩余空间 */</span></span><br><span class="language-css">            <span class="hljs-comment">/* justify-content: space-around; */</span></span><br><span class="language-css">            <span class="hljs-comment">/* 先两边贴边， 在分配剩余的空间 */</span></span><br><span class="language-css">            <span class="hljs-attribute">justify-content</span>:center</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: purple;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="5-垂直均分"><a href="#5-垂直均分" class="headerlink" title="5.垂直均分"></a><strong>5.垂直均分</strong></h4><p>&#x2F;* 我们现在的主轴是y轴 *&#x2F;</p><p>flex-direction: column;</p><p>&#x2F;* justify-content: center; *&#x2F;</p><p>justify-content: space-between;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">800px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">            <span class="hljs-comment">/* 我们现在的主轴是y轴 */</span></span><br><span class="language-css">            <span class="hljs-attribute">flex-direction</span>: column;</span><br><span class="language-css">            <span class="hljs-comment">/* justify-content: center; */</span></span><br><span class="language-css">            <span class="hljs-attribute">justify-content</span>: space-between;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: purple;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript原型和原型链原理</title>
    <link href="/blog/2021/12/14/js-prototype/"/>
    <url>/blog/2021/12/14/js-prototype/</url>
    
    <content type="html"><![CDATA[<h1 id="原型和原型链原理"><a href="#原型和原型链原理" class="headerlink" title="原型和原型链原理"></a>原型和原型链原理</h1><p>1、什么是原型？</p><p>2、什么是原型链？</p><p>3、prototype与__proto__有什么不同，有什么联系？</p><p>4、constructor与面两个有什么联系，怎么用？</p><p>如果你把上面这四个问题都解决了，那你就真正了解了JS的原型和原型链。接下来，咱们一个一个问题去解决。</p><h4 id=""><a href="#" class="headerlink" title="&lt;什么是原型&gt;"></a>&lt;什么是原型&gt;</h4><p>JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是JS自带的函数对象。每个对象都有原型（null和undefined除外），你可以把它理解为对象的默认属性和方法。</p><p>你可以把下面的代码在浏览器打印出来看一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <br><span class="hljs-comment">//Object&#123;&#125;</span><br><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">//undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <br><span class="hljs-comment">//[Symbol(Symbol.unscopables): Object]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <br><span class="hljs-comment">//function()&#123;&#125;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br>hello.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hello.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <br><span class="hljs-comment">//hello world</span><br></code></pre></td></tr></table></figure><p>**Object：**Object是一个函数对象，Object的原型就是一个Object对象，它里面存在着一些对象的方法和属性，例如最常见的toString方法。</p><p>**新建对象：**用new Object或者{}建的对象是普通对象，它没有prototype属性，只有__proto__属性，它指向Object.prototype。</p><p>**Array：**Array也是一个函数对象，它的原型就是Array.prototype，它里面存在着一些数组的方法和属性，例如常见的push，pop等方法。</p><p>**Function：**Function也是一个函数对象，但它有点特殊，它的原型就是一个function空函数。</p><p>**自定义函数：**它的原型就是你给它指定的那个东西。如果你不指定，那它的原型就是一个Object.prototype。</p><h4 id="-1"><a href="#-1" class="headerlink" title="&lt;什么是原型链&gt;"></a>&lt;什么是原型链&gt;</h4><p>在JavaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为<strong>原型链（prototype chain）</strong>。</p><p>JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;<br><span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br><span class="hljs-attr">b</span>:<span class="hljs-number">2</span><br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">toString</span>()); <br><span class="hljs-comment">//不报错，o上没有toString方法，但是Object上有</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;c&quot;</span>)); <br><span class="hljs-comment">//报错，o上没有这个方法，Object上也没有这个方法。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property">a</span>); <span class="hljs-comment">//1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property">c</span>); <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><p>当你用new Object或者直接定义一个对象时，它的原型链就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">o ==》 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ==》 <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>但你访问o上没有的属性或方法时，JS会往Object.prototype上寻找该属性和方法。如果有则直接返回，如果没有，方法则报错，这个方法未定义，属性则返回undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<span class="hljs-attr">age</span>:<span class="hljs-number">24</span>&#125;;<br><span class="hljs-keyword">var</span> tsrot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;tsrot&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tsrot.<span class="hljs-property">name</span>); <span class="hljs-comment">//tsrot</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tsrot.<span class="hljs-property">age</span>);  <span class="hljs-comment">//24</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tsrot.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">//[object Object]</span><br></code></pre></td></tr></table></figure><p>当你用构造函数（构造函数我们一般首字母大写）建立一个对象时，它的原型链就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">tsrot ==》 <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ==》 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ==》 <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>如果没有定义Person.prototype这一环，则直接跳到下一环。</p><p>来点更复杂的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;i am parent&quot;</span>;<br>&#125;<br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<span class="hljs-attr">age</span>:<span class="hljs-number">24</span>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;i am child&quot;</span>;<br>&#125;<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <br><span class="hljs-comment">//让Child的原型指向Parent的原型</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>; <br><span class="hljs-comment">//把child的构造函数指向回来，否则它将指向Parent。</span><br>虽然在这没什么影响，但要养成代码的严谨性<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">name</span>); <span class="hljs-comment">//i am child</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">age</span>); <span class="hljs-comment">//24</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">//[object Object]</span><br></code></pre></td></tr></table></figure><p>当你需要父类的属性和方法时，你可以把它的原型指向父类的原型。此时的原型链就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">child ==》 <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ==》 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ==》 <span class="hljs-literal">null</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <br><span class="hljs-comment">//[1,2,3]</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <br><span class="hljs-comment">//[1,2,3,4]</span><br></code></pre></td></tr></table></figure><p>数组也是一个对象，不过它是由Array构造函数new而来的，所以它的原型链就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">arr ==》 <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ==》 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ==》 <span class="hljs-literal">null</span><br><span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">var</span> hello = <span class="hljs-string">&quot;i am function&quot;</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fun.<span class="hljs-property">name</span>); <br><span class="hljs-comment">//fun</span><br></code></pre></td></tr></table></figure><p>fun是一个函数对象，它是由Function构造函数new而来的，所以它的原型链就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">fun ==》 <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ==》 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ==》 <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>fun它没有name属性，但是Function它有，所以这个name就是Function原型上的。</p><h4 id="-2"><a href="#-2" class="headerlink" title="&lt;prototype与__proto__&gt;"></a>&lt;prototype与__proto__&gt;</h4><p>在Javascript中，每个函数都有一个原型属性prototype指向自身的原型，而由这个函数创建的对象也有一个__proto__属性指向这个原型，而函数的原型是一个对象（函数点prototype也是一个普通对象，Function.prototype除外,它是函数对象，但它很特殊，他没有prototype属性），所以这个对象也会有一个__proto__指向自己的原型，这样逐层深入直到Object对象的原型，这样就形成了原型链。普通对象没有prototype，但有__proto__属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f1.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <br><span class="hljs-comment">//Object&#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> f1.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <br><span class="hljs-comment">//Object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <br><span class="hljs-comment">// Function，这个特殊</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <br><span class="hljs-comment">//Object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <br><span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><p>JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。</p><p><strong>普通对象的__proto__</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;tsrot&quot;</span>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property">__proto__</span>); <br><span class="hljs-comment">//Object&#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <br><span class="hljs-comment">//undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <br><span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><strong>构造对象的__proto__</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;i am parent&quot;</span>;<br>&#125;<br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<span class="hljs-attr">age</span>:<span class="hljs-number">24</span>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;i am child&quot;</span>;<br>&#125;<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">//Object&#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">//Object&#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <br><span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><strong>数组的__proto__</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">__proto__</span>);  <br><span class="hljs-comment">//[Symbol(Symbol.unscopables): Object]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <br><span class="hljs-comment">//[Symbol(Symbol.unscopables): Object]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><strong>函数的__proto__</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">var</span> hello = <span class="hljs-string">&quot;i am function&quot;</span><br>&#125;<br>fun.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;tsrot&quot;</span>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fun.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <br><span class="hljs-comment">//Object &#123;name: &quot;tsrot&quot;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fun.<span class="hljs-property">__proto__</span>); <br><span class="hljs-comment">//function()&#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fun.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === fun.<span class="hljs-property">__proto__</span>); <br><span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fun.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <br><span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原型链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入URL到渲染页面的过程</title>
    <link href="/blog/2021/12/14/url/"/>
    <url>/blog/2021/12/14/url/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器从输入URL到渲染完页面的整个过程"><a href="#浏览器从输入URL到渲染完页面的整个过程" class="headerlink" title="浏览器从输入URL到渲染完页面的整个过程"></a>浏览器从输入URL到渲染完页面的整个过程</h1><p><strong>从输入URL到渲染出整个页面的过程包括三个部分：</strong></p><p>1、DNS解析URL的过程</p><p>2、浏览器发送请求与服务器交互的过程</p><p>3、浏览器对接收到的html页面渲染的过程</p><h4 id="一、DNS解析URL的过程"><a href="#一、DNS解析URL的过程" class="headerlink" title="一、DNS解析URL的过程"></a><strong>一、DNS解析URL的过程</strong></h4><p>   DNS解析的过程就是寻找哪个服务器上有请求的资源。因为ip地址不容易记忆，一般会使用URL域名，如”<a href="http://www.baidu.com“作为网址.dns解析就是将域名翻译成ip地址的过程./">www.baidu.com“作为网址。DNS解析就是将域名翻译成IP地址的过程。</a></p><p>具体过程：</p><p>​    1）浏览器缓存：浏览器会按照一定的频率 缓存DNS记录</p><p> 　2）操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就会取操作系统中找</p><p>　　 3）路由缓存：路由器也有DNS缓存</p><p>　　 4）ISP的DNS服务器：ISP有专门的DNS服务器应对DNS查询请求</p><p>　　 5）根服务器：ISP的DNS服务器找不到之后，就要向根服务器发出请求，进行递归查询</p><h4 id="二、浏览器与服务器交互过程"><a href="#二、浏览器与服务器交互过程" class="headerlink" title="二、浏览器与服务器交互过程"></a><strong>二、浏览器与服务器交互过程</strong></h4><p>　　1）首先浏览器利用tcp协议通过三次握手与服务器建立连接</p><p>　　http请求包括header和body。header中包括请求的方式（get和post）、请求的协议 （http、https、ftp）、请求的地址ip、缓存cookie。body中有请求的内容。</p><p>　　2）浏览器根据解析到的IP地址和端口号发起http的get请求.</p><p>　　3）服务器接收到http请求之后，开始搜索html页面，并使用http返回响应报文</p><p>　　4）若状态码为200显示响应成功，浏览器接收到返回的html页面之后，开始进行页面的渲染</p><h4 id="三、浏览器页面渲染过程"><a href="#三、浏览器页面渲染过程" class="headerlink" title="三、浏览器页面渲染过程"></a><strong>三、浏览器页面渲染过程</strong></h4><p>　　1）浏览器根据深度遍历的方式把html节点遍历成dom 树</p><p>　　2）将css解析成CSS DOM树</p><p>　　3）将dom树和CSS DOM树构造成render树</p><p>　　4）JS根据得到的render树 计算所有节点在屏幕中的位置，进行布局（回流）</p><p>　　5）遍历render树并调用硬件API绘制所有节点（重绘）</p><p>   <strong>补充： 构造render渲染树的过程</strong></p><ol><li>从DOM树的根节点开始遍历每个可见的节点。</li><li>对于每个可见的节点，找到CSS树中的对应的规则，并且应用他们。</li><li>根据每个可见的节点及其对应的样式，组合生成渲染树。</li></ol>]]></content>
    
    
    <categories>
      
      <category>browser</category>
      
    </categories>
    
    
    <tags>
      
      <tag>url</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript作用域及作用域链</title>
    <link href="/blog/2021/12/14/js-actionScope/"/>
    <url>/blog/2021/12/14/js-actionScope/</url>
    
    <content type="html"><![CDATA[<h1 id="JS-作用域及作用域链"><a href="#JS-作用域及作用域链" class="headerlink" title="JS 作用域及作用域链"></a>JS 作用域及作用域链</h1><h3 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h3><p>　　在 Javascript 中，作用域分为 <strong>全局作用域</strong> 和 <strong>函数作用域</strong></p><h4 id="全局作用域："><a href="#全局作用域：" class="headerlink" title="全局作用域："></a>全局作用域：</h4><p>　　代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。</p><h4 id="函数作用域："><a href="#函数作用域：" class="headerlink" title="函数作用域："></a>函数作用域：</h4><p>　　在固定的代码片段才能被访问</p><p>　　作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的。如上，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。</p><p>　　作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p><p>　　变量取值：到创建 这个变量 的函数的作用域中取值</p><h3 id="二、作用域链"><a href="#二、作用域链" class="headerlink" title="二、作用域链"></a>二、作用域链</h3><p>　　<strong>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。</strong></p><p>　　<strong>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">f</span>)&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">20</span>;<br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       f();    <span class="hljs-comment">// 10</span><br>    &#125;)()  <br>&#125;<br><br>show(fn);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>作用域</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
